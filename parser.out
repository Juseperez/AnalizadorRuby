Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    BANG
    BEGIN_S
    BEGIN_U
    B_AND
    B_LEFT_SHIFT
    B_ONES
    B_OR
    B_RIGHT_SHIFT
    B_XOR
    CASE
    CMP
    DEFINEDQ
    ENCODING
    END_U
    ENSURE
    FILE
    INTERPOLATION
    LINE
    MODULE
    QUESTION
    REDO
    RESCUE
    RETRY
    SELF
    SEMICOLON
    SUPER
    UNDEF
    UNLESS
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement_list statement
Rule 3     statement_list -> statement
Rule 4     statement -> BREAK
Rule 5     statement -> NEXT
Rule 6     stmt_block -> statement
Rule 7     stmt_block -> stmt_block statement
Rule 8     stmt_block -> LBRACE statement_list RBRACE
Rule 9     stmt_block -> statement_list
Rule 10    statement -> print_stmt
Rule 11    statement -> input_stmt
Rule 12    statement -> assignment
Rule 13    statement -> while_stmt
Rule 14    statement -> for_stmt
Rule 15    statement -> hash_literal
Rule 16    statement -> function_def
Rule 17    statement -> if_stmt
Rule 18    statement -> optional_then
Rule 19    statement -> stmt_block
Rule 20    statement -> elsif_list
Rule 21    statement -> else_part
Rule 22    statement -> expression
Rule 23    print_stmt -> PRINT expression
Rule 24    print_stmt -> PUTS expression
Rule 25    input_stmt -> variable EQLS LOCAL_VAR
Rule 26    variable -> GLOBAL_VAR
Rule 27    variable -> LOCAL_VAR
Rule 28    variable -> INSTANCE_VAR
Rule 29    variable -> CLASS_VAR
Rule 30    variable -> CONSTANT
Rule 31    assignment -> variable EQLS expression
Rule 32    assignment -> variable PLUSEQLS expression
Rule 33    assignment -> variable MINUSEQLS expression
Rule 34    assignment -> variable MULTEQLS expression
Rule 35    assignment -> variable DIVEQLS expression
Rule 36    assignment -> variable MODEQLS expression
Rule 37    assignment -> variable POWEREQLS expression
Rule 38    while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit
Rule 39    while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit
Rule 40    while_enter -> <empty>
Rule 41    while_exit -> <empty>
Rule 42    for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
Rule 43    for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
Rule 44    for_enter -> <empty>
Rule 45    for_exit -> <empty>
Rule 46    if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S
Rule 47    optional_then -> THEN
Rule 48    optional_then -> empty
Rule 49    elsif_list -> empty
Rule 50    elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block
Rule 51    else_part -> empty
Rule 52    else_part -> ELSE stmt_block
Rule 53    statement -> ELSIF expression_logic optional_then stmt_block
Rule 54    statement -> ELSIF expression
Rule 55    statement -> ELSE stmt_block
Rule 56    statement -> ELSE
Rule 57    expression_logic -> expression_logic ANDAND expression_logic
Rule 58    expression_logic -> expression_logic OROR expression_logic
Rule 59    expression_logic -> expression_logic AND expression_logic
Rule 60    expression_logic -> expression_logic OR expression_logic
Rule 61    expression_logic -> expression_compare
Rule 62    expression_compare -> expression LT expression
Rule 63    expression_compare -> expression LE expression
Rule 64    expression_compare -> expression GT expression
Rule 65    expression_compare -> expression GE expression
Rule 66    expression_compare -> expression EQ expression
Rule 67    expression_compare -> expression NE expression
Rule 68    expression_compare -> expression EQQ expression
Rule 69    expression_compare -> expression MATCH expression
Rule 70    expression_compare -> expression NMATCH expression
Rule 71    expression -> NOT expression
Rule 72    hash_literal -> LBRACE hash_pairs_opt RBRACE
Rule 73    hash_pairs_opt -> <empty>
Rule 74    hash_pairs_opt -> hash_pairs
Rule 75    hash_pairs -> hash_pairs COMMA hash_pair
Rule 76    hash_pairs -> hash_pair
Rule 77    hash_pair -> expression ARROW expression
Rule 78    hash_pair -> SYMBOL COLON expression
Rule 79    hash_pair -> LOCAL_VAR COLON expression
Rule 80    expression -> hash_literal
Rule 81    expression -> expression RANGE_INCL expression
Rule 82    expression -> expression RANGE_EXCL expression
Rule 83    expr_list -> expression
Rule 84    expr_list -> expression COMMA expr_list
Rule 85    array_literal -> LBRACKET RBRACKET
Rule 86    array_literal -> LBRACKET expr_list RBRACKET
Rule 87    primary -> INTEGER
Rule 88    primary -> FLOAT
Rule 89    primary -> STR
Rule 90    primary -> SYMBOL
Rule 91    primary -> variable
Rule 92    primary -> TRUE
Rule 93    primary -> FALSE
Rule 94    primary -> NIL
Rule 95    primary -> LPAREN expression RPAREN
Rule 96    primary -> array_literal
Rule 97    expr_postfix -> LOCAL_VAR LPAREN RPAREN
Rule 98    expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN
Rule 99    expr_postfix -> expr_postfix LBRACKET expression RBRACKET
Rule 100   expr_postfix -> primary
Rule 101   expr_arith -> expr_postfix
Rule 102   assignment -> expr_postfix EQLS expression
Rule 103   function_def -> DEF LOCAL_VAR statement_list END_S
Rule 104   function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
Rule 105   optional_params -> param_list
Rule 106   optional_params -> empty
Rule 107   param_list -> parameter
Rule 108   param_list -> param_list COMMA parameter
Rule 109   parameter -> LOCAL_VAR
Rule 110   parameter -> LOCAL_VAR EQLS expression
Rule 111   empty -> <empty>
Rule 112   function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S
Rule 113   optional_ret -> COLON TYPE
Rule 114   optional_ret -> empty
Rule 115   statement -> RETURN
Rule 116   statement -> RETURN expression
Rule 117   expression -> NIL
Rule 118   expression -> TRUE
Rule 119   expression -> FALSE
Rule 120   class_def -> CLASS CONSTANT stmt_block END_S
Rule 121   class_def -> CLASS CONSTANT opt_inherit stmt_block END_S
Rule 122   opt_inherit -> LT CONSTANT
Rule 123   opt_inherit -> empty
Rule 124   statement -> class_def
Rule 125   property_decl -> INSTANCE_VAR
Rule 126   property_decl -> CLASS_VAR
Rule 127   statement -> property_decl
Rule 128   method_def -> function_def
Rule 129   statement -> method_def
Rule 130   expression -> expression PLUS expression
Rule 131   expression -> expression MINUS expression
Rule 132   expression -> expression MULT expression
Rule 133   expression -> expression DIV expression
Rule 134   expression -> expression MOD expression
Rule 135   expression -> expression POWER expression
Rule 136   expression -> LPAREN expression RPAREN
Rule 137   expression -> INTEGER
Rule 138   expression -> FLOAT
Rule 139   expression -> RATIONAL
Rule 140   expression -> COMPLEX
Rule 141   expression -> STR
Rule 142   expression -> SYMBOL
Rule 143   expression -> REGEXP
Rule 144   expression -> variable
Rule 145   expression -> expr_postfix
Rule 146   expr_postfix -> expr_postfix DOT LOCAL_VAR
Rule 147   expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN
Rule 148   expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
Rule 149   expression -> MINUS expression
Rule 150   valor -> INTEGER
Rule 151   valor -> LOCAL_VAR

Terminals, with rules where they appear

ALIAS                : 
AND                  : 59
ANDAND               : 57
ARROW                : 77
BANG                 : 
BEGIN_S              : 
BEGIN_U              : 
BREAK                : 4
B_AND                : 
B_LEFT_SHIFT         : 
B_ONES               : 
B_OR                 : 
B_RIGHT_SHIFT        : 
B_XOR                : 
CASE                 : 
CLASS                : 120 121
CLASS_VAR            : 29 126
CMP                  : 
COLON                : 78 79 113
COMMA                : 75 84 108
COMPLEX              : 140
CONSTANT             : 30 120 121 122
DEF                  : 103 104 112
DEFINEDQ             : 
DIV                  : 133
DIVEQLS              : 35
DO                   : 38 42
DOT                  : 146 147 148
ELSE                 : 52 55 56
ELSIF                : 50 53 54
ENCODING             : 
END_S                : 38 39 42 43 46 103 104 112 120 121
END_U                : 
ENSURE               : 
EQ                   : 66
EQLS                 : 25 31 102 110
EQQ                  : 68
FALSE                : 93 119
FILE                 : 
FLOAT                : 88 138
FOR                  : 42 43
GE                   : 65
GLOBAL_VAR           : 26
GT                   : 64
IF                   : 46
IN                   : 42 43
INSTANCE_VAR         : 28 125
INTEGER              : 87 137 150
INTERPOLATION        : 
LBRACE               : 8 72
LBRACKET             : 85 86 99
LE                   : 63
LINE                 : 
LOCAL_VAR            : 25 27 42 43 79 97 98 103 104 109 110 112 146 147 148 151
LPAREN               : 95 97 98 104 136 147 148
LT                   : 62 122
MATCH                : 69
MINUS                : 131 149
MINUSEQLS            : 33
MOD                  : 134
MODEQLS              : 36
MODULE               : 
MULT                 : 132
MULTEQLS             : 34
NE                   : 67
NEXT                 : 5
NIL                  : 94 117
NMATCH               : 70
NOT                  : 71
OR                   : 60
OROR                 : 58
PLUS                 : 130
PLUSEQLS             : 32
POWER                : 135
POWEREQLS            : 37
PRINT                : 23
PUTS                 : 24
QUESTION             : 
RANGE_EXCL           : 82
RANGE_INCL           : 81
RATIONAL             : 139
RBRACE               : 8 72
RBRACKET             : 85 86 99
REDO                 : 
REGEXP               : 143
RESCUE               : 
RETRY                : 
RETURN               : 115 116
RPAREN               : 95 97 98 104 136 147 148
SELF                 : 
SEMICOLON            : 
STR                  : 89 141
SUPER                : 
SYMBOL               : 78 90 142
THEN                 : 47
TRUE                 : 92 118
TYPE                 : 113
UNDEF                : 
UNLESS               : 
UNTIL                : 
WHEN                 : 
WHILE                : 38 39
YIELD                : 
error                : 

Nonterminals, with rules where they appear

array_literal        : 96
assignment           : 12
class_def            : 124
else_part            : 21 46
elsif_list           : 20 46 50
empty                : 48 49 51 106 114 123
expr_arith           : 
expr_list            : 84 86 98 148
expr_postfix         : 99 101 102 145 146 147 148
expression           : 22 23 24 31 32 33 34 35 36 37 42 43 54 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 77 77 78 79 81 81 82 82 83 84 95 99 102 110 116 130 130 131 131 132 132 133 133 134 134 135 135 136 149
expression_compare   : 61
expression_logic     : 38 39 46 50 53 57 57 58 58 59 59 60 60
for_enter            : 42 43
for_exit             : 42 43
for_stmt             : 14
function_def         : 16 128
hash_literal         : 15 80
hash_pair            : 75 76
hash_pairs           : 74 75
hash_pairs_opt       : 72
if_stmt              : 17
input_stmt           : 11
method_def           : 129
opt_inherit          : 121
optional_params      : 112
optional_ret         : 112
optional_then        : 18 46 50 53
param_list           : 104 105 108
parameter            : 107 108
primary              : 100
print_stmt           : 10
program              : 0
property_decl        : 127
statement            : 2 3 6 7
statement_list       : 1 2 8 9 38 39 42 43 103 104 112
stmt_block           : 7 19 46 50 52 53 55 120 121
valor                : 
variable             : 25 31 32 33 34 35 36 37 91 144
while_enter          : 38 39
while_exit           : 38 39
while_stmt           : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    $end            reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for $end resolved using rule 1 (program -> statement_list .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! reduce/reduce conflict for $end resolved using rule 1 (program -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 1 (program -> statement_list .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! $end            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 3

    (3) statement_list -> statement .
    (6) stmt_block -> statement .

  ! reduce/reduce conflict for BREAK resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for DEF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for IF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for THEN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NOT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NIL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for STR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for $end resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for END_S resolved using rule 3 (statement_list -> statement .)
    BREAK           reduce using rule 3 (statement_list -> statement .)
    NEXT            reduce using rule 3 (statement_list -> statement .)
    ELSIF           reduce using rule 3 (statement_list -> statement .)
    ELSE            reduce using rule 3 (statement_list -> statement .)
    RETURN          reduce using rule 3 (statement_list -> statement .)
    PRINT           reduce using rule 3 (statement_list -> statement .)
    PUTS            reduce using rule 3 (statement_list -> statement .)
    WHILE           reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    DEF             reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    THEN            reduce using rule 3 (statement_list -> statement .)
    NOT             reduce using rule 3 (statement_list -> statement .)
    NIL             reduce using rule 3 (statement_list -> statement .)
    TRUE            reduce using rule 3 (statement_list -> statement .)
    FALSE           reduce using rule 3 (statement_list -> statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement .)
    INTEGER         reduce using rule 3 (statement_list -> statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement .)
    RATIONAL        reduce using rule 3 (statement_list -> statement .)
    COMPLEX         reduce using rule 3 (statement_list -> statement .)
    STR             reduce using rule 3 (statement_list -> statement .)
    SYMBOL          reduce using rule 3 (statement_list -> statement .)
    REGEXP          reduce using rule 3 (statement_list -> statement .)
    MINUS           reduce using rule 3 (statement_list -> statement .)
    CLASS           reduce using rule 3 (statement_list -> statement .)
    INSTANCE_VAR    reduce using rule 3 (statement_list -> statement .)
    CLASS_VAR       reduce using rule 3 (statement_list -> statement .)
    GLOBAL_VAR      reduce using rule 3 (statement_list -> statement .)
    LOCAL_VAR       reduce using rule 3 (statement_list -> statement .)
    CONSTANT        reduce using rule 3 (statement_list -> statement .)
    LBRACKET        reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)
    END_S           reduce using rule 3 (statement_list -> statement .)

  ! BREAK           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NEXT            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSIF           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RETURN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PRINT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PUTS            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! WHILE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FOR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! DEF             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! IF              [ reduce using rule 6 (stmt_block -> statement .) ]
  ! THEN            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NOT             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NIL             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! TRUE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FALSE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LPAREN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INTEGER         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FLOAT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RATIONAL        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! COMPLEX         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! STR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! SYMBOL          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! REGEXP          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! MINUS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LOCAL_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CONSTANT        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACKET        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! $end            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! END_S           [ reduce using rule 6 (stmt_block -> statement .) ]


state 4

    (4) statement -> BREAK .

    BREAK           reduce using rule 4 (statement -> BREAK .)
    NEXT            reduce using rule 4 (statement -> BREAK .)
    ELSIF           reduce using rule 4 (statement -> BREAK .)
    ELSE            reduce using rule 4 (statement -> BREAK .)
    RETURN          reduce using rule 4 (statement -> BREAK .)
    PRINT           reduce using rule 4 (statement -> BREAK .)
    PUTS            reduce using rule 4 (statement -> BREAK .)
    WHILE           reduce using rule 4 (statement -> BREAK .)
    FOR             reduce using rule 4 (statement -> BREAK .)
    LBRACE          reduce using rule 4 (statement -> BREAK .)
    DEF             reduce using rule 4 (statement -> BREAK .)
    IF              reduce using rule 4 (statement -> BREAK .)
    THEN            reduce using rule 4 (statement -> BREAK .)
    NOT             reduce using rule 4 (statement -> BREAK .)
    NIL             reduce using rule 4 (statement -> BREAK .)
    TRUE            reduce using rule 4 (statement -> BREAK .)
    FALSE           reduce using rule 4 (statement -> BREAK .)
    LPAREN          reduce using rule 4 (statement -> BREAK .)
    INTEGER         reduce using rule 4 (statement -> BREAK .)
    FLOAT           reduce using rule 4 (statement -> BREAK .)
    RATIONAL        reduce using rule 4 (statement -> BREAK .)
    COMPLEX         reduce using rule 4 (statement -> BREAK .)
    STR             reduce using rule 4 (statement -> BREAK .)
    SYMBOL          reduce using rule 4 (statement -> BREAK .)
    REGEXP          reduce using rule 4 (statement -> BREAK .)
    MINUS           reduce using rule 4 (statement -> BREAK .)
    CLASS           reduce using rule 4 (statement -> BREAK .)
    INSTANCE_VAR    reduce using rule 4 (statement -> BREAK .)
    CLASS_VAR       reduce using rule 4 (statement -> BREAK .)
    GLOBAL_VAR      reduce using rule 4 (statement -> BREAK .)
    LOCAL_VAR       reduce using rule 4 (statement -> BREAK .)
    CONSTANT        reduce using rule 4 (statement -> BREAK .)
    LBRACKET        reduce using rule 4 (statement -> BREAK .)
    $end            reduce using rule 4 (statement -> BREAK .)
    RBRACE          reduce using rule 4 (statement -> BREAK .)
    END_S           reduce using rule 4 (statement -> BREAK .)


state 5

    (5) statement -> NEXT .

    BREAK           reduce using rule 5 (statement -> NEXT .)
    NEXT            reduce using rule 5 (statement -> NEXT .)
    ELSIF           reduce using rule 5 (statement -> NEXT .)
    ELSE            reduce using rule 5 (statement -> NEXT .)
    RETURN          reduce using rule 5 (statement -> NEXT .)
    PRINT           reduce using rule 5 (statement -> NEXT .)
    PUTS            reduce using rule 5 (statement -> NEXT .)
    WHILE           reduce using rule 5 (statement -> NEXT .)
    FOR             reduce using rule 5 (statement -> NEXT .)
    LBRACE          reduce using rule 5 (statement -> NEXT .)
    DEF             reduce using rule 5 (statement -> NEXT .)
    IF              reduce using rule 5 (statement -> NEXT .)
    THEN            reduce using rule 5 (statement -> NEXT .)
    NOT             reduce using rule 5 (statement -> NEXT .)
    NIL             reduce using rule 5 (statement -> NEXT .)
    TRUE            reduce using rule 5 (statement -> NEXT .)
    FALSE           reduce using rule 5 (statement -> NEXT .)
    LPAREN          reduce using rule 5 (statement -> NEXT .)
    INTEGER         reduce using rule 5 (statement -> NEXT .)
    FLOAT           reduce using rule 5 (statement -> NEXT .)
    RATIONAL        reduce using rule 5 (statement -> NEXT .)
    COMPLEX         reduce using rule 5 (statement -> NEXT .)
    STR             reduce using rule 5 (statement -> NEXT .)
    SYMBOL          reduce using rule 5 (statement -> NEXT .)
    REGEXP          reduce using rule 5 (statement -> NEXT .)
    MINUS           reduce using rule 5 (statement -> NEXT .)
    CLASS           reduce using rule 5 (statement -> NEXT .)
    INSTANCE_VAR    reduce using rule 5 (statement -> NEXT .)
    CLASS_VAR       reduce using rule 5 (statement -> NEXT .)
    GLOBAL_VAR      reduce using rule 5 (statement -> NEXT .)
    LOCAL_VAR       reduce using rule 5 (statement -> NEXT .)
    CONSTANT        reduce using rule 5 (statement -> NEXT .)
    LBRACKET        reduce using rule 5 (statement -> NEXT .)
    $end            reduce using rule 5 (statement -> NEXT .)
    RBRACE          reduce using rule 5 (statement -> NEXT .)
    END_S           reduce using rule 5 (statement -> NEXT .)


state 6

    (10) statement -> print_stmt .

    BREAK           reduce using rule 10 (statement -> print_stmt .)
    NEXT            reduce using rule 10 (statement -> print_stmt .)
    ELSIF           reduce using rule 10 (statement -> print_stmt .)
    ELSE            reduce using rule 10 (statement -> print_stmt .)
    RETURN          reduce using rule 10 (statement -> print_stmt .)
    PRINT           reduce using rule 10 (statement -> print_stmt .)
    PUTS            reduce using rule 10 (statement -> print_stmt .)
    WHILE           reduce using rule 10 (statement -> print_stmt .)
    FOR             reduce using rule 10 (statement -> print_stmt .)
    LBRACE          reduce using rule 10 (statement -> print_stmt .)
    DEF             reduce using rule 10 (statement -> print_stmt .)
    IF              reduce using rule 10 (statement -> print_stmt .)
    THEN            reduce using rule 10 (statement -> print_stmt .)
    NOT             reduce using rule 10 (statement -> print_stmt .)
    NIL             reduce using rule 10 (statement -> print_stmt .)
    TRUE            reduce using rule 10 (statement -> print_stmt .)
    FALSE           reduce using rule 10 (statement -> print_stmt .)
    LPAREN          reduce using rule 10 (statement -> print_stmt .)
    INTEGER         reduce using rule 10 (statement -> print_stmt .)
    FLOAT           reduce using rule 10 (statement -> print_stmt .)
    RATIONAL        reduce using rule 10 (statement -> print_stmt .)
    COMPLEX         reduce using rule 10 (statement -> print_stmt .)
    STR             reduce using rule 10 (statement -> print_stmt .)
    SYMBOL          reduce using rule 10 (statement -> print_stmt .)
    REGEXP          reduce using rule 10 (statement -> print_stmt .)
    MINUS           reduce using rule 10 (statement -> print_stmt .)
    CLASS           reduce using rule 10 (statement -> print_stmt .)
    INSTANCE_VAR    reduce using rule 10 (statement -> print_stmt .)
    CLASS_VAR       reduce using rule 10 (statement -> print_stmt .)
    GLOBAL_VAR      reduce using rule 10 (statement -> print_stmt .)
    LOCAL_VAR       reduce using rule 10 (statement -> print_stmt .)
    CONSTANT        reduce using rule 10 (statement -> print_stmt .)
    LBRACKET        reduce using rule 10 (statement -> print_stmt .)
    $end            reduce using rule 10 (statement -> print_stmt .)
    RBRACE          reduce using rule 10 (statement -> print_stmt .)
    END_S           reduce using rule 10 (statement -> print_stmt .)


state 7

    (11) statement -> input_stmt .

    BREAK           reduce using rule 11 (statement -> input_stmt .)
    NEXT            reduce using rule 11 (statement -> input_stmt .)
    ELSIF           reduce using rule 11 (statement -> input_stmt .)
    ELSE            reduce using rule 11 (statement -> input_stmt .)
    RETURN          reduce using rule 11 (statement -> input_stmt .)
    PRINT           reduce using rule 11 (statement -> input_stmt .)
    PUTS            reduce using rule 11 (statement -> input_stmt .)
    WHILE           reduce using rule 11 (statement -> input_stmt .)
    FOR             reduce using rule 11 (statement -> input_stmt .)
    LBRACE          reduce using rule 11 (statement -> input_stmt .)
    DEF             reduce using rule 11 (statement -> input_stmt .)
    IF              reduce using rule 11 (statement -> input_stmt .)
    THEN            reduce using rule 11 (statement -> input_stmt .)
    NOT             reduce using rule 11 (statement -> input_stmt .)
    NIL             reduce using rule 11 (statement -> input_stmt .)
    TRUE            reduce using rule 11 (statement -> input_stmt .)
    FALSE           reduce using rule 11 (statement -> input_stmt .)
    LPAREN          reduce using rule 11 (statement -> input_stmt .)
    INTEGER         reduce using rule 11 (statement -> input_stmt .)
    FLOAT           reduce using rule 11 (statement -> input_stmt .)
    RATIONAL        reduce using rule 11 (statement -> input_stmt .)
    COMPLEX         reduce using rule 11 (statement -> input_stmt .)
    STR             reduce using rule 11 (statement -> input_stmt .)
    SYMBOL          reduce using rule 11 (statement -> input_stmt .)
    REGEXP          reduce using rule 11 (statement -> input_stmt .)
    MINUS           reduce using rule 11 (statement -> input_stmt .)
    CLASS           reduce using rule 11 (statement -> input_stmt .)
    INSTANCE_VAR    reduce using rule 11 (statement -> input_stmt .)
    CLASS_VAR       reduce using rule 11 (statement -> input_stmt .)
    GLOBAL_VAR      reduce using rule 11 (statement -> input_stmt .)
    LOCAL_VAR       reduce using rule 11 (statement -> input_stmt .)
    CONSTANT        reduce using rule 11 (statement -> input_stmt .)
    LBRACKET        reduce using rule 11 (statement -> input_stmt .)
    $end            reduce using rule 11 (statement -> input_stmt .)
    RBRACE          reduce using rule 11 (statement -> input_stmt .)
    END_S           reduce using rule 11 (statement -> input_stmt .)


state 8

    (12) statement -> assignment .

    BREAK           reduce using rule 12 (statement -> assignment .)
    NEXT            reduce using rule 12 (statement -> assignment .)
    ELSIF           reduce using rule 12 (statement -> assignment .)
    ELSE            reduce using rule 12 (statement -> assignment .)
    RETURN          reduce using rule 12 (statement -> assignment .)
    PRINT           reduce using rule 12 (statement -> assignment .)
    PUTS            reduce using rule 12 (statement -> assignment .)
    WHILE           reduce using rule 12 (statement -> assignment .)
    FOR             reduce using rule 12 (statement -> assignment .)
    LBRACE          reduce using rule 12 (statement -> assignment .)
    DEF             reduce using rule 12 (statement -> assignment .)
    IF              reduce using rule 12 (statement -> assignment .)
    THEN            reduce using rule 12 (statement -> assignment .)
    NOT             reduce using rule 12 (statement -> assignment .)
    NIL             reduce using rule 12 (statement -> assignment .)
    TRUE            reduce using rule 12 (statement -> assignment .)
    FALSE           reduce using rule 12 (statement -> assignment .)
    LPAREN          reduce using rule 12 (statement -> assignment .)
    INTEGER         reduce using rule 12 (statement -> assignment .)
    FLOAT           reduce using rule 12 (statement -> assignment .)
    RATIONAL        reduce using rule 12 (statement -> assignment .)
    COMPLEX         reduce using rule 12 (statement -> assignment .)
    STR             reduce using rule 12 (statement -> assignment .)
    SYMBOL          reduce using rule 12 (statement -> assignment .)
    REGEXP          reduce using rule 12 (statement -> assignment .)
    MINUS           reduce using rule 12 (statement -> assignment .)
    CLASS           reduce using rule 12 (statement -> assignment .)
    INSTANCE_VAR    reduce using rule 12 (statement -> assignment .)
    CLASS_VAR       reduce using rule 12 (statement -> assignment .)
    GLOBAL_VAR      reduce using rule 12 (statement -> assignment .)
    LOCAL_VAR       reduce using rule 12 (statement -> assignment .)
    CONSTANT        reduce using rule 12 (statement -> assignment .)
    LBRACKET        reduce using rule 12 (statement -> assignment .)
    $end            reduce using rule 12 (statement -> assignment .)
    RBRACE          reduce using rule 12 (statement -> assignment .)
    END_S           reduce using rule 12 (statement -> assignment .)


state 9

    (13) statement -> while_stmt .

    BREAK           reduce using rule 13 (statement -> while_stmt .)
    NEXT            reduce using rule 13 (statement -> while_stmt .)
    ELSIF           reduce using rule 13 (statement -> while_stmt .)
    ELSE            reduce using rule 13 (statement -> while_stmt .)
    RETURN          reduce using rule 13 (statement -> while_stmt .)
    PRINT           reduce using rule 13 (statement -> while_stmt .)
    PUTS            reduce using rule 13 (statement -> while_stmt .)
    WHILE           reduce using rule 13 (statement -> while_stmt .)
    FOR             reduce using rule 13 (statement -> while_stmt .)
    LBRACE          reduce using rule 13 (statement -> while_stmt .)
    DEF             reduce using rule 13 (statement -> while_stmt .)
    IF              reduce using rule 13 (statement -> while_stmt .)
    THEN            reduce using rule 13 (statement -> while_stmt .)
    NOT             reduce using rule 13 (statement -> while_stmt .)
    NIL             reduce using rule 13 (statement -> while_stmt .)
    TRUE            reduce using rule 13 (statement -> while_stmt .)
    FALSE           reduce using rule 13 (statement -> while_stmt .)
    LPAREN          reduce using rule 13 (statement -> while_stmt .)
    INTEGER         reduce using rule 13 (statement -> while_stmt .)
    FLOAT           reduce using rule 13 (statement -> while_stmt .)
    RATIONAL        reduce using rule 13 (statement -> while_stmt .)
    COMPLEX         reduce using rule 13 (statement -> while_stmt .)
    STR             reduce using rule 13 (statement -> while_stmt .)
    SYMBOL          reduce using rule 13 (statement -> while_stmt .)
    REGEXP          reduce using rule 13 (statement -> while_stmt .)
    MINUS           reduce using rule 13 (statement -> while_stmt .)
    CLASS           reduce using rule 13 (statement -> while_stmt .)
    INSTANCE_VAR    reduce using rule 13 (statement -> while_stmt .)
    CLASS_VAR       reduce using rule 13 (statement -> while_stmt .)
    GLOBAL_VAR      reduce using rule 13 (statement -> while_stmt .)
    LOCAL_VAR       reduce using rule 13 (statement -> while_stmt .)
    CONSTANT        reduce using rule 13 (statement -> while_stmt .)
    LBRACKET        reduce using rule 13 (statement -> while_stmt .)
    $end            reduce using rule 13 (statement -> while_stmt .)
    RBRACE          reduce using rule 13 (statement -> while_stmt .)
    END_S           reduce using rule 13 (statement -> while_stmt .)


state 10

    (14) statement -> for_stmt .

    BREAK           reduce using rule 14 (statement -> for_stmt .)
    NEXT            reduce using rule 14 (statement -> for_stmt .)
    ELSIF           reduce using rule 14 (statement -> for_stmt .)
    ELSE            reduce using rule 14 (statement -> for_stmt .)
    RETURN          reduce using rule 14 (statement -> for_stmt .)
    PRINT           reduce using rule 14 (statement -> for_stmt .)
    PUTS            reduce using rule 14 (statement -> for_stmt .)
    WHILE           reduce using rule 14 (statement -> for_stmt .)
    FOR             reduce using rule 14 (statement -> for_stmt .)
    LBRACE          reduce using rule 14 (statement -> for_stmt .)
    DEF             reduce using rule 14 (statement -> for_stmt .)
    IF              reduce using rule 14 (statement -> for_stmt .)
    THEN            reduce using rule 14 (statement -> for_stmt .)
    NOT             reduce using rule 14 (statement -> for_stmt .)
    NIL             reduce using rule 14 (statement -> for_stmt .)
    TRUE            reduce using rule 14 (statement -> for_stmt .)
    FALSE           reduce using rule 14 (statement -> for_stmt .)
    LPAREN          reduce using rule 14 (statement -> for_stmt .)
    INTEGER         reduce using rule 14 (statement -> for_stmt .)
    FLOAT           reduce using rule 14 (statement -> for_stmt .)
    RATIONAL        reduce using rule 14 (statement -> for_stmt .)
    COMPLEX         reduce using rule 14 (statement -> for_stmt .)
    STR             reduce using rule 14 (statement -> for_stmt .)
    SYMBOL          reduce using rule 14 (statement -> for_stmt .)
    REGEXP          reduce using rule 14 (statement -> for_stmt .)
    MINUS           reduce using rule 14 (statement -> for_stmt .)
    CLASS           reduce using rule 14 (statement -> for_stmt .)
    INSTANCE_VAR    reduce using rule 14 (statement -> for_stmt .)
    CLASS_VAR       reduce using rule 14 (statement -> for_stmt .)
    GLOBAL_VAR      reduce using rule 14 (statement -> for_stmt .)
    LOCAL_VAR       reduce using rule 14 (statement -> for_stmt .)
    CONSTANT        reduce using rule 14 (statement -> for_stmt .)
    LBRACKET        reduce using rule 14 (statement -> for_stmt .)
    $end            reduce using rule 14 (statement -> for_stmt .)
    RBRACE          reduce using rule 14 (statement -> for_stmt .)
    END_S           reduce using rule 14 (statement -> for_stmt .)


state 11

    (15) statement -> hash_literal .
    (80) expression -> hash_literal .

  ! reduce/reduce conflict for MINUS resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for BREAK resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for NEXT resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for ELSIF resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for ELSE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for RETURN resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for PRINT resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for PUTS resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for WHILE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for FOR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for LBRACE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for DEF resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for IF resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for THEN resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for NOT resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for NIL resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for TRUE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for FALSE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for LPAREN resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for INTEGER resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for FLOAT resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for STR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for REGEXP resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for CLASS resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for $end resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for RBRACE resolved using rule 15 (statement -> hash_literal .)
  ! reduce/reduce conflict for END_S resolved using rule 15 (statement -> hash_literal .)
    BREAK           reduce using rule 15 (statement -> hash_literal .)
    NEXT            reduce using rule 15 (statement -> hash_literal .)
    ELSIF           reduce using rule 15 (statement -> hash_literal .)
    ELSE            reduce using rule 15 (statement -> hash_literal .)
    RETURN          reduce using rule 15 (statement -> hash_literal .)
    PRINT           reduce using rule 15 (statement -> hash_literal .)
    PUTS            reduce using rule 15 (statement -> hash_literal .)
    WHILE           reduce using rule 15 (statement -> hash_literal .)
    FOR             reduce using rule 15 (statement -> hash_literal .)
    LBRACE          reduce using rule 15 (statement -> hash_literal .)
    DEF             reduce using rule 15 (statement -> hash_literal .)
    IF              reduce using rule 15 (statement -> hash_literal .)
    THEN            reduce using rule 15 (statement -> hash_literal .)
    NOT             reduce using rule 15 (statement -> hash_literal .)
    NIL             reduce using rule 15 (statement -> hash_literal .)
    TRUE            reduce using rule 15 (statement -> hash_literal .)
    FALSE           reduce using rule 15 (statement -> hash_literal .)
    LPAREN          reduce using rule 15 (statement -> hash_literal .)
    INTEGER         reduce using rule 15 (statement -> hash_literal .)
    FLOAT           reduce using rule 15 (statement -> hash_literal .)
    RATIONAL        reduce using rule 15 (statement -> hash_literal .)
    COMPLEX         reduce using rule 15 (statement -> hash_literal .)
    STR             reduce using rule 15 (statement -> hash_literal .)
    SYMBOL          reduce using rule 15 (statement -> hash_literal .)
    REGEXP          reduce using rule 15 (statement -> hash_literal .)
    MINUS           reduce using rule 15 (statement -> hash_literal .)
    CLASS           reduce using rule 15 (statement -> hash_literal .)
    INSTANCE_VAR    reduce using rule 15 (statement -> hash_literal .)
    CLASS_VAR       reduce using rule 15 (statement -> hash_literal .)
    GLOBAL_VAR      reduce using rule 15 (statement -> hash_literal .)
    LOCAL_VAR       reduce using rule 15 (statement -> hash_literal .)
    CONSTANT        reduce using rule 15 (statement -> hash_literal .)
    LBRACKET        reduce using rule 15 (statement -> hash_literal .)
    $end            reduce using rule 15 (statement -> hash_literal .)
    RBRACE          reduce using rule 15 (statement -> hash_literal .)
    END_S           reduce using rule 15 (statement -> hash_literal .)
    RANGE_INCL      reduce using rule 80 (expression -> hash_literal .)
    RANGE_EXCL      reduce using rule 80 (expression -> hash_literal .)
    PLUS            reduce using rule 80 (expression -> hash_literal .)
    MULT            reduce using rule 80 (expression -> hash_literal .)
    DIV             reduce using rule 80 (expression -> hash_literal .)
    MOD             reduce using rule 80 (expression -> hash_literal .)
    POWER           reduce using rule 80 (expression -> hash_literal .)
    ARROW           reduce using rule 80 (expression -> hash_literal .)

  ! MINUS           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! BREAK           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! NEXT            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! ELSIF           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! ELSE            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! RETURN          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! PRINT           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! PUTS            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! WHILE           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! FOR             [ reduce using rule 80 (expression -> hash_literal .) ]
  ! LBRACE          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! DEF             [ reduce using rule 80 (expression -> hash_literal .) ]
  ! IF              [ reduce using rule 80 (expression -> hash_literal .) ]
  ! THEN            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! NOT             [ reduce using rule 80 (expression -> hash_literal .) ]
  ! NIL             [ reduce using rule 80 (expression -> hash_literal .) ]
  ! TRUE            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! FALSE           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! LPAREN          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! INTEGER         [ reduce using rule 80 (expression -> hash_literal .) ]
  ! FLOAT           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! RATIONAL        [ reduce using rule 80 (expression -> hash_literal .) ]
  ! COMPLEX         [ reduce using rule 80 (expression -> hash_literal .) ]
  ! STR             [ reduce using rule 80 (expression -> hash_literal .) ]
  ! SYMBOL          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! REGEXP          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! CLASS           [ reduce using rule 80 (expression -> hash_literal .) ]
  ! INSTANCE_VAR    [ reduce using rule 80 (expression -> hash_literal .) ]
  ! CLASS_VAR       [ reduce using rule 80 (expression -> hash_literal .) ]
  ! GLOBAL_VAR      [ reduce using rule 80 (expression -> hash_literal .) ]
  ! LOCAL_VAR       [ reduce using rule 80 (expression -> hash_literal .) ]
  ! CONSTANT        [ reduce using rule 80 (expression -> hash_literal .) ]
  ! LBRACKET        [ reduce using rule 80 (expression -> hash_literal .) ]
  ! $end            [ reduce using rule 80 (expression -> hash_literal .) ]
  ! RBRACE          [ reduce using rule 80 (expression -> hash_literal .) ]
  ! END_S           [ reduce using rule 80 (expression -> hash_literal .) ]


state 12

    (16) statement -> function_def .
    (128) method_def -> function_def .

  ! reduce/reduce conflict for BREAK resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for NEXT resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for ELSIF resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for ELSE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for RETURN resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for PRINT resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for PUTS resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for WHILE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for FOR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for LBRACE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for DEF resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for IF resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for THEN resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for NOT resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for NIL resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for TRUE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for FALSE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for LPAREN resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for INTEGER resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for FLOAT resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for STR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for REGEXP resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for MINUS resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for CLASS resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for $end resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for RBRACE resolved using rule 16 (statement -> function_def .)
  ! reduce/reduce conflict for END_S resolved using rule 16 (statement -> function_def .)
    BREAK           reduce using rule 16 (statement -> function_def .)
    NEXT            reduce using rule 16 (statement -> function_def .)
    ELSIF           reduce using rule 16 (statement -> function_def .)
    ELSE            reduce using rule 16 (statement -> function_def .)
    RETURN          reduce using rule 16 (statement -> function_def .)
    PRINT           reduce using rule 16 (statement -> function_def .)
    PUTS            reduce using rule 16 (statement -> function_def .)
    WHILE           reduce using rule 16 (statement -> function_def .)
    FOR             reduce using rule 16 (statement -> function_def .)
    LBRACE          reduce using rule 16 (statement -> function_def .)
    DEF             reduce using rule 16 (statement -> function_def .)
    IF              reduce using rule 16 (statement -> function_def .)
    THEN            reduce using rule 16 (statement -> function_def .)
    NOT             reduce using rule 16 (statement -> function_def .)
    NIL             reduce using rule 16 (statement -> function_def .)
    TRUE            reduce using rule 16 (statement -> function_def .)
    FALSE           reduce using rule 16 (statement -> function_def .)
    LPAREN          reduce using rule 16 (statement -> function_def .)
    INTEGER         reduce using rule 16 (statement -> function_def .)
    FLOAT           reduce using rule 16 (statement -> function_def .)
    RATIONAL        reduce using rule 16 (statement -> function_def .)
    COMPLEX         reduce using rule 16 (statement -> function_def .)
    STR             reduce using rule 16 (statement -> function_def .)
    SYMBOL          reduce using rule 16 (statement -> function_def .)
    REGEXP          reduce using rule 16 (statement -> function_def .)
    MINUS           reduce using rule 16 (statement -> function_def .)
    CLASS           reduce using rule 16 (statement -> function_def .)
    INSTANCE_VAR    reduce using rule 16 (statement -> function_def .)
    CLASS_VAR       reduce using rule 16 (statement -> function_def .)
    GLOBAL_VAR      reduce using rule 16 (statement -> function_def .)
    LOCAL_VAR       reduce using rule 16 (statement -> function_def .)
    CONSTANT        reduce using rule 16 (statement -> function_def .)
    LBRACKET        reduce using rule 16 (statement -> function_def .)
    $end            reduce using rule 16 (statement -> function_def .)
    RBRACE          reduce using rule 16 (statement -> function_def .)
    END_S           reduce using rule 16 (statement -> function_def .)

  ! BREAK           [ reduce using rule 128 (method_def -> function_def .) ]
  ! NEXT            [ reduce using rule 128 (method_def -> function_def .) ]
  ! ELSIF           [ reduce using rule 128 (method_def -> function_def .) ]
  ! ELSE            [ reduce using rule 128 (method_def -> function_def .) ]
  ! RETURN          [ reduce using rule 128 (method_def -> function_def .) ]
  ! PRINT           [ reduce using rule 128 (method_def -> function_def .) ]
  ! PUTS            [ reduce using rule 128 (method_def -> function_def .) ]
  ! WHILE           [ reduce using rule 128 (method_def -> function_def .) ]
  ! FOR             [ reduce using rule 128 (method_def -> function_def .) ]
  ! LBRACE          [ reduce using rule 128 (method_def -> function_def .) ]
  ! DEF             [ reduce using rule 128 (method_def -> function_def .) ]
  ! IF              [ reduce using rule 128 (method_def -> function_def .) ]
  ! THEN            [ reduce using rule 128 (method_def -> function_def .) ]
  ! NOT             [ reduce using rule 128 (method_def -> function_def .) ]
  ! NIL             [ reduce using rule 128 (method_def -> function_def .) ]
  ! TRUE            [ reduce using rule 128 (method_def -> function_def .) ]
  ! FALSE           [ reduce using rule 128 (method_def -> function_def .) ]
  ! LPAREN          [ reduce using rule 128 (method_def -> function_def .) ]
  ! INTEGER         [ reduce using rule 128 (method_def -> function_def .) ]
  ! FLOAT           [ reduce using rule 128 (method_def -> function_def .) ]
  ! RATIONAL        [ reduce using rule 128 (method_def -> function_def .) ]
  ! COMPLEX         [ reduce using rule 128 (method_def -> function_def .) ]
  ! STR             [ reduce using rule 128 (method_def -> function_def .) ]
  ! SYMBOL          [ reduce using rule 128 (method_def -> function_def .) ]
  ! REGEXP          [ reduce using rule 128 (method_def -> function_def .) ]
  ! MINUS           [ reduce using rule 128 (method_def -> function_def .) ]
  ! CLASS           [ reduce using rule 128 (method_def -> function_def .) ]
  ! INSTANCE_VAR    [ reduce using rule 128 (method_def -> function_def .) ]
  ! CLASS_VAR       [ reduce using rule 128 (method_def -> function_def .) ]
  ! GLOBAL_VAR      [ reduce using rule 128 (method_def -> function_def .) ]
  ! LOCAL_VAR       [ reduce using rule 128 (method_def -> function_def .) ]
  ! CONSTANT        [ reduce using rule 128 (method_def -> function_def .) ]
  ! LBRACKET        [ reduce using rule 128 (method_def -> function_def .) ]
  ! $end            [ reduce using rule 128 (method_def -> function_def .) ]
  ! RBRACE          [ reduce using rule 128 (method_def -> function_def .) ]
  ! END_S           [ reduce using rule 128 (method_def -> function_def .) ]


state 13

    (17) statement -> if_stmt .

    BREAK           reduce using rule 17 (statement -> if_stmt .)
    NEXT            reduce using rule 17 (statement -> if_stmt .)
    ELSIF           reduce using rule 17 (statement -> if_stmt .)
    ELSE            reduce using rule 17 (statement -> if_stmt .)
    RETURN          reduce using rule 17 (statement -> if_stmt .)
    PRINT           reduce using rule 17 (statement -> if_stmt .)
    PUTS            reduce using rule 17 (statement -> if_stmt .)
    WHILE           reduce using rule 17 (statement -> if_stmt .)
    FOR             reduce using rule 17 (statement -> if_stmt .)
    LBRACE          reduce using rule 17 (statement -> if_stmt .)
    DEF             reduce using rule 17 (statement -> if_stmt .)
    IF              reduce using rule 17 (statement -> if_stmt .)
    THEN            reduce using rule 17 (statement -> if_stmt .)
    NOT             reduce using rule 17 (statement -> if_stmt .)
    NIL             reduce using rule 17 (statement -> if_stmt .)
    TRUE            reduce using rule 17 (statement -> if_stmt .)
    FALSE           reduce using rule 17 (statement -> if_stmt .)
    LPAREN          reduce using rule 17 (statement -> if_stmt .)
    INTEGER         reduce using rule 17 (statement -> if_stmt .)
    FLOAT           reduce using rule 17 (statement -> if_stmt .)
    RATIONAL        reduce using rule 17 (statement -> if_stmt .)
    COMPLEX         reduce using rule 17 (statement -> if_stmt .)
    STR             reduce using rule 17 (statement -> if_stmt .)
    SYMBOL          reduce using rule 17 (statement -> if_stmt .)
    REGEXP          reduce using rule 17 (statement -> if_stmt .)
    MINUS           reduce using rule 17 (statement -> if_stmt .)
    CLASS           reduce using rule 17 (statement -> if_stmt .)
    INSTANCE_VAR    reduce using rule 17 (statement -> if_stmt .)
    CLASS_VAR       reduce using rule 17 (statement -> if_stmt .)
    GLOBAL_VAR      reduce using rule 17 (statement -> if_stmt .)
    LOCAL_VAR       reduce using rule 17 (statement -> if_stmt .)
    CONSTANT        reduce using rule 17 (statement -> if_stmt .)
    LBRACKET        reduce using rule 17 (statement -> if_stmt .)
    $end            reduce using rule 17 (statement -> if_stmt .)
    RBRACE          reduce using rule 17 (statement -> if_stmt .)
    END_S           reduce using rule 17 (statement -> if_stmt .)


state 14

    (18) statement -> optional_then .

    BREAK           reduce using rule 18 (statement -> optional_then .)
    NEXT            reduce using rule 18 (statement -> optional_then .)
    ELSIF           reduce using rule 18 (statement -> optional_then .)
    ELSE            reduce using rule 18 (statement -> optional_then .)
    RETURN          reduce using rule 18 (statement -> optional_then .)
    PRINT           reduce using rule 18 (statement -> optional_then .)
    PUTS            reduce using rule 18 (statement -> optional_then .)
    WHILE           reduce using rule 18 (statement -> optional_then .)
    FOR             reduce using rule 18 (statement -> optional_then .)
    LBRACE          reduce using rule 18 (statement -> optional_then .)
    DEF             reduce using rule 18 (statement -> optional_then .)
    IF              reduce using rule 18 (statement -> optional_then .)
    THEN            reduce using rule 18 (statement -> optional_then .)
    NOT             reduce using rule 18 (statement -> optional_then .)
    NIL             reduce using rule 18 (statement -> optional_then .)
    TRUE            reduce using rule 18 (statement -> optional_then .)
    FALSE           reduce using rule 18 (statement -> optional_then .)
    LPAREN          reduce using rule 18 (statement -> optional_then .)
    INTEGER         reduce using rule 18 (statement -> optional_then .)
    FLOAT           reduce using rule 18 (statement -> optional_then .)
    RATIONAL        reduce using rule 18 (statement -> optional_then .)
    COMPLEX         reduce using rule 18 (statement -> optional_then .)
    STR             reduce using rule 18 (statement -> optional_then .)
    SYMBOL          reduce using rule 18 (statement -> optional_then .)
    REGEXP          reduce using rule 18 (statement -> optional_then .)
    MINUS           reduce using rule 18 (statement -> optional_then .)
    CLASS           reduce using rule 18 (statement -> optional_then .)
    INSTANCE_VAR    reduce using rule 18 (statement -> optional_then .)
    CLASS_VAR       reduce using rule 18 (statement -> optional_then .)
    GLOBAL_VAR      reduce using rule 18 (statement -> optional_then .)
    LOCAL_VAR       reduce using rule 18 (statement -> optional_then .)
    CONSTANT        reduce using rule 18 (statement -> optional_then .)
    LBRACKET        reduce using rule 18 (statement -> optional_then .)
    $end            reduce using rule 18 (statement -> optional_then .)
    RBRACE          reduce using rule 18 (statement -> optional_then .)
    END_S           reduce using rule 18 (statement -> optional_then .)


state 15

    (19) statement -> stmt_block .
    (7) stmt_block -> stmt_block . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 19 (statement -> stmt_block .)
    RBRACE          reduce using rule 19 (statement -> stmt_block .)
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 16

    (20) statement -> elsif_list .
    (50) elsif_list -> elsif_list . ELSIF expression_logic optional_then stmt_block

  ! shift/reduce conflict for ELSIF resolved as shift
    BREAK           reduce using rule 20 (statement -> elsif_list .)
    NEXT            reduce using rule 20 (statement -> elsif_list .)
    ELSE            reduce using rule 20 (statement -> elsif_list .)
    RETURN          reduce using rule 20 (statement -> elsif_list .)
    PRINT           reduce using rule 20 (statement -> elsif_list .)
    PUTS            reduce using rule 20 (statement -> elsif_list .)
    WHILE           reduce using rule 20 (statement -> elsif_list .)
    FOR             reduce using rule 20 (statement -> elsif_list .)
    LBRACE          reduce using rule 20 (statement -> elsif_list .)
    DEF             reduce using rule 20 (statement -> elsif_list .)
    IF              reduce using rule 20 (statement -> elsif_list .)
    THEN            reduce using rule 20 (statement -> elsif_list .)
    NOT             reduce using rule 20 (statement -> elsif_list .)
    NIL             reduce using rule 20 (statement -> elsif_list .)
    TRUE            reduce using rule 20 (statement -> elsif_list .)
    FALSE           reduce using rule 20 (statement -> elsif_list .)
    LPAREN          reduce using rule 20 (statement -> elsif_list .)
    INTEGER         reduce using rule 20 (statement -> elsif_list .)
    FLOAT           reduce using rule 20 (statement -> elsif_list .)
    RATIONAL        reduce using rule 20 (statement -> elsif_list .)
    COMPLEX         reduce using rule 20 (statement -> elsif_list .)
    STR             reduce using rule 20 (statement -> elsif_list .)
    SYMBOL          reduce using rule 20 (statement -> elsif_list .)
    REGEXP          reduce using rule 20 (statement -> elsif_list .)
    MINUS           reduce using rule 20 (statement -> elsif_list .)
    CLASS           reduce using rule 20 (statement -> elsif_list .)
    INSTANCE_VAR    reduce using rule 20 (statement -> elsif_list .)
    CLASS_VAR       reduce using rule 20 (statement -> elsif_list .)
    GLOBAL_VAR      reduce using rule 20 (statement -> elsif_list .)
    LOCAL_VAR       reduce using rule 20 (statement -> elsif_list .)
    CONSTANT        reduce using rule 20 (statement -> elsif_list .)
    LBRACKET        reduce using rule 20 (statement -> elsif_list .)
    $end            reduce using rule 20 (statement -> elsif_list .)
    RBRACE          reduce using rule 20 (statement -> elsif_list .)
    END_S           reduce using rule 20 (statement -> elsif_list .)
    ELSIF           shift and go to state 61

  ! ELSIF           [ reduce using rule 20 (statement -> elsif_list .) ]


state 17

    (21) statement -> else_part .

    BREAK           reduce using rule 21 (statement -> else_part .)
    NEXT            reduce using rule 21 (statement -> else_part .)
    ELSIF           reduce using rule 21 (statement -> else_part .)
    ELSE            reduce using rule 21 (statement -> else_part .)
    RETURN          reduce using rule 21 (statement -> else_part .)
    PRINT           reduce using rule 21 (statement -> else_part .)
    PUTS            reduce using rule 21 (statement -> else_part .)
    WHILE           reduce using rule 21 (statement -> else_part .)
    FOR             reduce using rule 21 (statement -> else_part .)
    LBRACE          reduce using rule 21 (statement -> else_part .)
    DEF             reduce using rule 21 (statement -> else_part .)
    IF              reduce using rule 21 (statement -> else_part .)
    THEN            reduce using rule 21 (statement -> else_part .)
    NOT             reduce using rule 21 (statement -> else_part .)
    NIL             reduce using rule 21 (statement -> else_part .)
    TRUE            reduce using rule 21 (statement -> else_part .)
    FALSE           reduce using rule 21 (statement -> else_part .)
    LPAREN          reduce using rule 21 (statement -> else_part .)
    INTEGER         reduce using rule 21 (statement -> else_part .)
    FLOAT           reduce using rule 21 (statement -> else_part .)
    RATIONAL        reduce using rule 21 (statement -> else_part .)
    COMPLEX         reduce using rule 21 (statement -> else_part .)
    STR             reduce using rule 21 (statement -> else_part .)
    SYMBOL          reduce using rule 21 (statement -> else_part .)
    REGEXP          reduce using rule 21 (statement -> else_part .)
    MINUS           reduce using rule 21 (statement -> else_part .)
    CLASS           reduce using rule 21 (statement -> else_part .)
    INSTANCE_VAR    reduce using rule 21 (statement -> else_part .)
    CLASS_VAR       reduce using rule 21 (statement -> else_part .)
    GLOBAL_VAR      reduce using rule 21 (statement -> else_part .)
    LOCAL_VAR       reduce using rule 21 (statement -> else_part .)
    CONSTANT        reduce using rule 21 (statement -> else_part .)
    LBRACKET        reduce using rule 21 (statement -> else_part .)
    $end            reduce using rule 21 (statement -> else_part .)
    RBRACE          reduce using rule 21 (statement -> else_part .)
    END_S           reduce using rule 21 (statement -> else_part .)


state 18

    (22) statement -> expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 22 (statement -> expression .)
    NEXT            reduce using rule 22 (statement -> expression .)
    ELSIF           reduce using rule 22 (statement -> expression .)
    ELSE            reduce using rule 22 (statement -> expression .)
    RETURN          reduce using rule 22 (statement -> expression .)
    PRINT           reduce using rule 22 (statement -> expression .)
    PUTS            reduce using rule 22 (statement -> expression .)
    WHILE           reduce using rule 22 (statement -> expression .)
    FOR             reduce using rule 22 (statement -> expression .)
    LBRACE          reduce using rule 22 (statement -> expression .)
    DEF             reduce using rule 22 (statement -> expression .)
    IF              reduce using rule 22 (statement -> expression .)
    THEN            reduce using rule 22 (statement -> expression .)
    NOT             reduce using rule 22 (statement -> expression .)
    NIL             reduce using rule 22 (statement -> expression .)
    TRUE            reduce using rule 22 (statement -> expression .)
    FALSE           reduce using rule 22 (statement -> expression .)
    LPAREN          reduce using rule 22 (statement -> expression .)
    INTEGER         reduce using rule 22 (statement -> expression .)
    FLOAT           reduce using rule 22 (statement -> expression .)
    RATIONAL        reduce using rule 22 (statement -> expression .)
    COMPLEX         reduce using rule 22 (statement -> expression .)
    STR             reduce using rule 22 (statement -> expression .)
    SYMBOL          reduce using rule 22 (statement -> expression .)
    REGEXP          reduce using rule 22 (statement -> expression .)
    CLASS           reduce using rule 22 (statement -> expression .)
    INSTANCE_VAR    reduce using rule 22 (statement -> expression .)
    CLASS_VAR       reduce using rule 22 (statement -> expression .)
    GLOBAL_VAR      reduce using rule 22 (statement -> expression .)
    LOCAL_VAR       reduce using rule 22 (statement -> expression .)
    CONSTANT        reduce using rule 22 (statement -> expression .)
    LBRACKET        reduce using rule 22 (statement -> expression .)
    $end            reduce using rule 22 (statement -> expression .)
    RBRACE          reduce using rule 22 (statement -> expression .)
    END_S           reduce using rule 22 (statement -> expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 22 (statement -> expression .) ]


state 19

    (53) statement -> ELSIF . expression_logic optional_then stmt_block
    (54) statement -> ELSIF . expression
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 70
    expression                     shift and go to state 71
    expression_compare             shift and go to state 72
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 20

    (55) statement -> ELSE . stmt_block
    (56) statement -> ELSE .
    (52) else_part -> ELSE . stmt_block
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 56 (statement -> ELSE .)
  ! reduce/reduce conflict for $end resolved using rule 56 (statement -> ELSE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 56 (statement -> ELSE .)
  ! reduce/reduce conflict for END_S resolved using rule 56 (statement -> ELSE .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 56 (statement -> ELSE .)
    RBRACE          reduce using rule 56 (statement -> ELSE .)
    END_S           reduce using rule 56 (statement -> ELSE .)
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 56 (statement -> ELSE .) ]
  ! NEXT            [ reduce using rule 56 (statement -> ELSE .) ]
  ! ELSIF           [ reduce using rule 56 (statement -> ELSE .) ]
  ! ELSE            [ reduce using rule 56 (statement -> ELSE .) ]
  ! RETURN          [ reduce using rule 56 (statement -> ELSE .) ]
  ! PRINT           [ reduce using rule 56 (statement -> ELSE .) ]
  ! PUTS            [ reduce using rule 56 (statement -> ELSE .) ]
  ! WHILE           [ reduce using rule 56 (statement -> ELSE .) ]
  ! FOR             [ reduce using rule 56 (statement -> ELSE .) ]
  ! LBRACE          [ reduce using rule 56 (statement -> ELSE .) ]
  ! DEF             [ reduce using rule 56 (statement -> ELSE .) ]
  ! IF              [ reduce using rule 56 (statement -> ELSE .) ]
  ! THEN            [ reduce using rule 56 (statement -> ELSE .) ]
  ! NOT             [ reduce using rule 56 (statement -> ELSE .) ]
  ! NIL             [ reduce using rule 56 (statement -> ELSE .) ]
  ! TRUE            [ reduce using rule 56 (statement -> ELSE .) ]
  ! FALSE           [ reduce using rule 56 (statement -> ELSE .) ]
  ! LPAREN          [ reduce using rule 56 (statement -> ELSE .) ]
  ! INTEGER         [ reduce using rule 56 (statement -> ELSE .) ]
  ! FLOAT           [ reduce using rule 56 (statement -> ELSE .) ]
  ! RATIONAL        [ reduce using rule 56 (statement -> ELSE .) ]
  ! COMPLEX         [ reduce using rule 56 (statement -> ELSE .) ]
  ! STR             [ reduce using rule 56 (statement -> ELSE .) ]
  ! SYMBOL          [ reduce using rule 56 (statement -> ELSE .) ]
  ! REGEXP          [ reduce using rule 56 (statement -> ELSE .) ]
  ! MINUS           [ reduce using rule 56 (statement -> ELSE .) ]
  ! CLASS           [ reduce using rule 56 (statement -> ELSE .) ]
  ! INSTANCE_VAR    [ reduce using rule 56 (statement -> ELSE .) ]
  ! CLASS_VAR       [ reduce using rule 56 (statement -> ELSE .) ]
  ! GLOBAL_VAR      [ reduce using rule 56 (statement -> ELSE .) ]
  ! LOCAL_VAR       [ reduce using rule 56 (statement -> ELSE .) ]
  ! CONSTANT        [ reduce using rule 56 (statement -> ELSE .) ]
  ! LBRACKET        [ reduce using rule 56 (statement -> ELSE .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 79
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 21

    (115) statement -> RETURN .
    (116) statement -> RETURN . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           reduce using rule 115 (statement -> RETURN .)
    NEXT            reduce using rule 115 (statement -> RETURN .)
    ELSIF           reduce using rule 115 (statement -> RETURN .)
    ELSE            reduce using rule 115 (statement -> RETURN .)
    RETURN          reduce using rule 115 (statement -> RETURN .)
    PRINT           reduce using rule 115 (statement -> RETURN .)
    PUTS            reduce using rule 115 (statement -> RETURN .)
    WHILE           reduce using rule 115 (statement -> RETURN .)
    FOR             reduce using rule 115 (statement -> RETURN .)
    DEF             reduce using rule 115 (statement -> RETURN .)
    IF              reduce using rule 115 (statement -> RETURN .)
    THEN            reduce using rule 115 (statement -> RETURN .)
    CLASS           reduce using rule 115 (statement -> RETURN .)
    $end            reduce using rule 115 (statement -> RETURN .)
    RBRACE          reduce using rule 115 (statement -> RETURN .)
    END_S           reduce using rule 115 (statement -> RETURN .)
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! LBRACE          [ reduce using rule 115 (statement -> RETURN .) ]
  ! NOT             [ reduce using rule 115 (statement -> RETURN .) ]
  ! NIL             [ reduce using rule 115 (statement -> RETURN .) ]
  ! TRUE            [ reduce using rule 115 (statement -> RETURN .) ]
  ! FALSE           [ reduce using rule 115 (statement -> RETURN .) ]
  ! LPAREN          [ reduce using rule 115 (statement -> RETURN .) ]
  ! INTEGER         [ reduce using rule 115 (statement -> RETURN .) ]
  ! FLOAT           [ reduce using rule 115 (statement -> RETURN .) ]
  ! RATIONAL        [ reduce using rule 115 (statement -> RETURN .) ]
  ! COMPLEX         [ reduce using rule 115 (statement -> RETURN .) ]
  ! STR             [ reduce using rule 115 (statement -> RETURN .) ]
  ! SYMBOL          [ reduce using rule 115 (statement -> RETURN .) ]
  ! REGEXP          [ reduce using rule 115 (statement -> RETURN .) ]
  ! MINUS           [ reduce using rule 115 (statement -> RETURN .) ]
  ! INSTANCE_VAR    [ reduce using rule 115 (statement -> RETURN .) ]
  ! CLASS_VAR       [ reduce using rule 115 (statement -> RETURN .) ]
  ! GLOBAL_VAR      [ reduce using rule 115 (statement -> RETURN .) ]
  ! LOCAL_VAR       [ reduce using rule 115 (statement -> RETURN .) ]
  ! CONSTANT        [ reduce using rule 115 (statement -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 115 (statement -> RETURN .) ]

    expression                     shift and go to state 82
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 22

    (124) statement -> class_def .

    BREAK           reduce using rule 124 (statement -> class_def .)
    NEXT            reduce using rule 124 (statement -> class_def .)
    ELSIF           reduce using rule 124 (statement -> class_def .)
    ELSE            reduce using rule 124 (statement -> class_def .)
    RETURN          reduce using rule 124 (statement -> class_def .)
    PRINT           reduce using rule 124 (statement -> class_def .)
    PUTS            reduce using rule 124 (statement -> class_def .)
    WHILE           reduce using rule 124 (statement -> class_def .)
    FOR             reduce using rule 124 (statement -> class_def .)
    LBRACE          reduce using rule 124 (statement -> class_def .)
    DEF             reduce using rule 124 (statement -> class_def .)
    IF              reduce using rule 124 (statement -> class_def .)
    THEN            reduce using rule 124 (statement -> class_def .)
    NOT             reduce using rule 124 (statement -> class_def .)
    NIL             reduce using rule 124 (statement -> class_def .)
    TRUE            reduce using rule 124 (statement -> class_def .)
    FALSE           reduce using rule 124 (statement -> class_def .)
    LPAREN          reduce using rule 124 (statement -> class_def .)
    INTEGER         reduce using rule 124 (statement -> class_def .)
    FLOAT           reduce using rule 124 (statement -> class_def .)
    RATIONAL        reduce using rule 124 (statement -> class_def .)
    COMPLEX         reduce using rule 124 (statement -> class_def .)
    STR             reduce using rule 124 (statement -> class_def .)
    SYMBOL          reduce using rule 124 (statement -> class_def .)
    REGEXP          reduce using rule 124 (statement -> class_def .)
    MINUS           reduce using rule 124 (statement -> class_def .)
    CLASS           reduce using rule 124 (statement -> class_def .)
    INSTANCE_VAR    reduce using rule 124 (statement -> class_def .)
    CLASS_VAR       reduce using rule 124 (statement -> class_def .)
    GLOBAL_VAR      reduce using rule 124 (statement -> class_def .)
    LOCAL_VAR       reduce using rule 124 (statement -> class_def .)
    CONSTANT        reduce using rule 124 (statement -> class_def .)
    LBRACKET        reduce using rule 124 (statement -> class_def .)
    $end            reduce using rule 124 (statement -> class_def .)
    RBRACE          reduce using rule 124 (statement -> class_def .)
    END_S           reduce using rule 124 (statement -> class_def .)


state 23

    (127) statement -> property_decl .

    BREAK           reduce using rule 127 (statement -> property_decl .)
    NEXT            reduce using rule 127 (statement -> property_decl .)
    ELSIF           reduce using rule 127 (statement -> property_decl .)
    ELSE            reduce using rule 127 (statement -> property_decl .)
    RETURN          reduce using rule 127 (statement -> property_decl .)
    PRINT           reduce using rule 127 (statement -> property_decl .)
    PUTS            reduce using rule 127 (statement -> property_decl .)
    WHILE           reduce using rule 127 (statement -> property_decl .)
    FOR             reduce using rule 127 (statement -> property_decl .)
    LBRACE          reduce using rule 127 (statement -> property_decl .)
    DEF             reduce using rule 127 (statement -> property_decl .)
    IF              reduce using rule 127 (statement -> property_decl .)
    THEN            reduce using rule 127 (statement -> property_decl .)
    NOT             reduce using rule 127 (statement -> property_decl .)
    NIL             reduce using rule 127 (statement -> property_decl .)
    TRUE            reduce using rule 127 (statement -> property_decl .)
    FALSE           reduce using rule 127 (statement -> property_decl .)
    LPAREN          reduce using rule 127 (statement -> property_decl .)
    INTEGER         reduce using rule 127 (statement -> property_decl .)
    FLOAT           reduce using rule 127 (statement -> property_decl .)
    RATIONAL        reduce using rule 127 (statement -> property_decl .)
    COMPLEX         reduce using rule 127 (statement -> property_decl .)
    STR             reduce using rule 127 (statement -> property_decl .)
    SYMBOL          reduce using rule 127 (statement -> property_decl .)
    REGEXP          reduce using rule 127 (statement -> property_decl .)
    MINUS           reduce using rule 127 (statement -> property_decl .)
    CLASS           reduce using rule 127 (statement -> property_decl .)
    INSTANCE_VAR    reduce using rule 127 (statement -> property_decl .)
    CLASS_VAR       reduce using rule 127 (statement -> property_decl .)
    GLOBAL_VAR      reduce using rule 127 (statement -> property_decl .)
    LOCAL_VAR       reduce using rule 127 (statement -> property_decl .)
    CONSTANT        reduce using rule 127 (statement -> property_decl .)
    LBRACKET        reduce using rule 127 (statement -> property_decl .)
    $end            reduce using rule 127 (statement -> property_decl .)
    RBRACE          reduce using rule 127 (statement -> property_decl .)
    END_S           reduce using rule 127 (statement -> property_decl .)


state 24

    (129) statement -> method_def .

    BREAK           reduce using rule 129 (statement -> method_def .)
    NEXT            reduce using rule 129 (statement -> method_def .)
    ELSIF           reduce using rule 129 (statement -> method_def .)
    ELSE            reduce using rule 129 (statement -> method_def .)
    RETURN          reduce using rule 129 (statement -> method_def .)
    PRINT           reduce using rule 129 (statement -> method_def .)
    PUTS            reduce using rule 129 (statement -> method_def .)
    WHILE           reduce using rule 129 (statement -> method_def .)
    FOR             reduce using rule 129 (statement -> method_def .)
    LBRACE          reduce using rule 129 (statement -> method_def .)
    DEF             reduce using rule 129 (statement -> method_def .)
    IF              reduce using rule 129 (statement -> method_def .)
    THEN            reduce using rule 129 (statement -> method_def .)
    NOT             reduce using rule 129 (statement -> method_def .)
    NIL             reduce using rule 129 (statement -> method_def .)
    TRUE            reduce using rule 129 (statement -> method_def .)
    FALSE           reduce using rule 129 (statement -> method_def .)
    LPAREN          reduce using rule 129 (statement -> method_def .)
    INTEGER         reduce using rule 129 (statement -> method_def .)
    FLOAT           reduce using rule 129 (statement -> method_def .)
    RATIONAL        reduce using rule 129 (statement -> method_def .)
    COMPLEX         reduce using rule 129 (statement -> method_def .)
    STR             reduce using rule 129 (statement -> method_def .)
    SYMBOL          reduce using rule 129 (statement -> method_def .)
    REGEXP          reduce using rule 129 (statement -> method_def .)
    MINUS           reduce using rule 129 (statement -> method_def .)
    CLASS           reduce using rule 129 (statement -> method_def .)
    INSTANCE_VAR    reduce using rule 129 (statement -> method_def .)
    CLASS_VAR       reduce using rule 129 (statement -> method_def .)
    GLOBAL_VAR      reduce using rule 129 (statement -> method_def .)
    LOCAL_VAR       reduce using rule 129 (statement -> method_def .)
    CONSTANT        reduce using rule 129 (statement -> method_def .)
    LBRACKET        reduce using rule 129 (statement -> method_def .)
    $end            reduce using rule 129 (statement -> method_def .)
    RBRACE          reduce using rule 129 (statement -> method_def .)
    END_S           reduce using rule 129 (statement -> method_def .)


state 25

    (23) print_stmt -> PRINT . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 83
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 26

    (24) print_stmt -> PUTS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 84
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 27

    (25) input_stmt -> variable . EQLS LOCAL_VAR
    (31) assignment -> variable . EQLS expression
    (32) assignment -> variable . PLUSEQLS expression
    (33) assignment -> variable . MINUSEQLS expression
    (34) assignment -> variable . MULTEQLS expression
    (35) assignment -> variable . DIVEQLS expression
    (36) assignment -> variable . MODEQLS expression
    (37) assignment -> variable . POWEREQLS expression
    (144) expression -> variable .
    (91) primary -> variable .

  ! shift/reduce conflict for EQLS resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PLUS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MINUS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MULT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for DIV resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MOD resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for POWER resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for BREAK resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NEXT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ELSIF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ELSE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RETURN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PRINT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PUTS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for WHILE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FOR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LBRACE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for DEF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for IF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for THEN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NOT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NIL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for TRUE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FALSE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LPAREN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for INTEGER resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FLOAT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for STR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for REGEXP resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CLASS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for $end resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RBRACE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for END_S resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ARROW resolved using rule 91 (primary -> variable .)
    EQLS            shift and go to state 85
    PLUSEQLS        shift and go to state 86
    MINUSEQLS       shift and go to state 87
    MULTEQLS        shift and go to state 88
    DIVEQLS         shift and go to state 89
    MODEQLS         shift and go to state 90
    POWEREQLS       shift and go to state 91
    LBRACKET        reduce using rule 91 (primary -> variable .)
    DOT             reduce using rule 91 (primary -> variable .)
    RANGE_INCL      reduce using rule 91 (primary -> variable .)
    RANGE_EXCL      reduce using rule 91 (primary -> variable .)
    PLUS            reduce using rule 91 (primary -> variable .)
    MINUS           reduce using rule 91 (primary -> variable .)
    MULT            reduce using rule 91 (primary -> variable .)
    DIV             reduce using rule 91 (primary -> variable .)
    MOD             reduce using rule 91 (primary -> variable .)
    POWER           reduce using rule 91 (primary -> variable .)
    BREAK           reduce using rule 91 (primary -> variable .)
    NEXT            reduce using rule 91 (primary -> variable .)
    ELSIF           reduce using rule 91 (primary -> variable .)
    ELSE            reduce using rule 91 (primary -> variable .)
    RETURN          reduce using rule 91 (primary -> variable .)
    PRINT           reduce using rule 91 (primary -> variable .)
    PUTS            reduce using rule 91 (primary -> variable .)
    WHILE           reduce using rule 91 (primary -> variable .)
    FOR             reduce using rule 91 (primary -> variable .)
    LBRACE          reduce using rule 91 (primary -> variable .)
    DEF             reduce using rule 91 (primary -> variable .)
    IF              reduce using rule 91 (primary -> variable .)
    THEN            reduce using rule 91 (primary -> variable .)
    NOT             reduce using rule 91 (primary -> variable .)
    NIL             reduce using rule 91 (primary -> variable .)
    TRUE            reduce using rule 91 (primary -> variable .)
    FALSE           reduce using rule 91 (primary -> variable .)
    LPAREN          reduce using rule 91 (primary -> variable .)
    INTEGER         reduce using rule 91 (primary -> variable .)
    FLOAT           reduce using rule 91 (primary -> variable .)
    RATIONAL        reduce using rule 91 (primary -> variable .)
    COMPLEX         reduce using rule 91 (primary -> variable .)
    STR             reduce using rule 91 (primary -> variable .)
    SYMBOL          reduce using rule 91 (primary -> variable .)
    REGEXP          reduce using rule 91 (primary -> variable .)
    CLASS           reduce using rule 91 (primary -> variable .)
    INSTANCE_VAR    reduce using rule 91 (primary -> variable .)
    CLASS_VAR       reduce using rule 91 (primary -> variable .)
    GLOBAL_VAR      reduce using rule 91 (primary -> variable .)
    LOCAL_VAR       reduce using rule 91 (primary -> variable .)
    CONSTANT        reduce using rule 91 (primary -> variable .)
    $end            reduce using rule 91 (primary -> variable .)
    RBRACE          reduce using rule 91 (primary -> variable .)
    END_S           reduce using rule 91 (primary -> variable .)
    ARROW           reduce using rule 91 (primary -> variable .)

  ! RANGE_INCL      [ reduce using rule 144 (expression -> variable .) ]
  ! RANGE_EXCL      [ reduce using rule 144 (expression -> variable .) ]
  ! PLUS            [ reduce using rule 144 (expression -> variable .) ]
  ! MINUS           [ reduce using rule 144 (expression -> variable .) ]
  ! MULT            [ reduce using rule 144 (expression -> variable .) ]
  ! DIV             [ reduce using rule 144 (expression -> variable .) ]
  ! MOD             [ reduce using rule 144 (expression -> variable .) ]
  ! POWER           [ reduce using rule 144 (expression -> variable .) ]
  ! BREAK           [ reduce using rule 144 (expression -> variable .) ]
  ! NEXT            [ reduce using rule 144 (expression -> variable .) ]
  ! ELSIF           [ reduce using rule 144 (expression -> variable .) ]
  ! ELSE            [ reduce using rule 144 (expression -> variable .) ]
  ! RETURN          [ reduce using rule 144 (expression -> variable .) ]
  ! PRINT           [ reduce using rule 144 (expression -> variable .) ]
  ! PUTS            [ reduce using rule 144 (expression -> variable .) ]
  ! WHILE           [ reduce using rule 144 (expression -> variable .) ]
  ! FOR             [ reduce using rule 144 (expression -> variable .) ]
  ! LBRACE          [ reduce using rule 144 (expression -> variable .) ]
  ! DEF             [ reduce using rule 144 (expression -> variable .) ]
  ! IF              [ reduce using rule 144 (expression -> variable .) ]
  ! THEN            [ reduce using rule 144 (expression -> variable .) ]
  ! NOT             [ reduce using rule 144 (expression -> variable .) ]
  ! NIL             [ reduce using rule 144 (expression -> variable .) ]
  ! TRUE            [ reduce using rule 144 (expression -> variable .) ]
  ! FALSE           [ reduce using rule 144 (expression -> variable .) ]
  ! LPAREN          [ reduce using rule 144 (expression -> variable .) ]
  ! INTEGER         [ reduce using rule 144 (expression -> variable .) ]
  ! FLOAT           [ reduce using rule 144 (expression -> variable .) ]
  ! RATIONAL        [ reduce using rule 144 (expression -> variable .) ]
  ! COMPLEX         [ reduce using rule 144 (expression -> variable .) ]
  ! STR             [ reduce using rule 144 (expression -> variable .) ]
  ! SYMBOL          [ reduce using rule 144 (expression -> variable .) ]
  ! REGEXP          [ reduce using rule 144 (expression -> variable .) ]
  ! CLASS           [ reduce using rule 144 (expression -> variable .) ]
  ! INSTANCE_VAR    [ reduce using rule 144 (expression -> variable .) ]
  ! CLASS_VAR       [ reduce using rule 144 (expression -> variable .) ]
  ! GLOBAL_VAR      [ reduce using rule 144 (expression -> variable .) ]
  ! LOCAL_VAR       [ reduce using rule 144 (expression -> variable .) ]
  ! CONSTANT        [ reduce using rule 144 (expression -> variable .) ]
  ! LBRACKET        [ reduce using rule 144 (expression -> variable .) ]
  ! $end            [ reduce using rule 144 (expression -> variable .) ]
  ! RBRACE          [ reduce using rule 144 (expression -> variable .) ]
  ! END_S           [ reduce using rule 144 (expression -> variable .) ]
  ! ARROW           [ reduce using rule 144 (expression -> variable .) ]
  ! EQLS            [ reduce using rule 91 (primary -> variable .) ]


state 28

    (27) variable -> LOCAL_VAR .
    (97) expr_postfix -> LOCAL_VAR . LPAREN RPAREN
    (98) expr_postfix -> LOCAL_VAR . LPAREN expr_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    EQLS            reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUSEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUSEQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    MULTEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    DIVEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    MODEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    POWEREQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_INCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_EXCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUS            reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUS           reduce using rule 27 (variable -> LOCAL_VAR .)
    MULT            reduce using rule 27 (variable -> LOCAL_VAR .)
    DIV             reduce using rule 27 (variable -> LOCAL_VAR .)
    MOD             reduce using rule 27 (variable -> LOCAL_VAR .)
    POWER           reduce using rule 27 (variable -> LOCAL_VAR .)
    BREAK           reduce using rule 27 (variable -> LOCAL_VAR .)
    NEXT            reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSIF           reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSE            reduce using rule 27 (variable -> LOCAL_VAR .)
    RETURN          reduce using rule 27 (variable -> LOCAL_VAR .)
    PRINT           reduce using rule 27 (variable -> LOCAL_VAR .)
    PUTS            reduce using rule 27 (variable -> LOCAL_VAR .)
    WHILE           reduce using rule 27 (variable -> LOCAL_VAR .)
    FOR             reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACE          reduce using rule 27 (variable -> LOCAL_VAR .)
    DEF             reduce using rule 27 (variable -> LOCAL_VAR .)
    IF              reduce using rule 27 (variable -> LOCAL_VAR .)
    THEN            reduce using rule 27 (variable -> LOCAL_VAR .)
    NOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    NIL             reduce using rule 27 (variable -> LOCAL_VAR .)
    TRUE            reduce using rule 27 (variable -> LOCAL_VAR .)
    FALSE           reduce using rule 27 (variable -> LOCAL_VAR .)
    INTEGER         reduce using rule 27 (variable -> LOCAL_VAR .)
    FLOAT           reduce using rule 27 (variable -> LOCAL_VAR .)
    RATIONAL        reduce using rule 27 (variable -> LOCAL_VAR .)
    COMPLEX         reduce using rule 27 (variable -> LOCAL_VAR .)
    STR             reduce using rule 27 (variable -> LOCAL_VAR .)
    SYMBOL          reduce using rule 27 (variable -> LOCAL_VAR .)
    REGEXP          reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS           reduce using rule 27 (variable -> LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 27 (variable -> LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    CONSTANT        reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACKET        reduce using rule 27 (variable -> LOCAL_VAR .)
    $end            reduce using rule 27 (variable -> LOCAL_VAR .)
    DOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    RBRACE          reduce using rule 27 (variable -> LOCAL_VAR .)
    END_S           reduce using rule 27 (variable -> LOCAL_VAR .)
    LT              reduce using rule 27 (variable -> LOCAL_VAR .)
    LE              reduce using rule 27 (variable -> LOCAL_VAR .)
    GT              reduce using rule 27 (variable -> LOCAL_VAR .)
    GE              reduce using rule 27 (variable -> LOCAL_VAR .)
    EQ              reduce using rule 27 (variable -> LOCAL_VAR .)
    NE              reduce using rule 27 (variable -> LOCAL_VAR .)
    EQQ             reduce using rule 27 (variable -> LOCAL_VAR .)
    MATCH           reduce using rule 27 (variable -> LOCAL_VAR .)
    NMATCH          reduce using rule 27 (variable -> LOCAL_VAR .)
    RPAREN          reduce using rule 27 (variable -> LOCAL_VAR .)
    ARROW           reduce using rule 27 (variable -> LOCAL_VAR .)
    COMMA           reduce using rule 27 (variable -> LOCAL_VAR .)
    RBRACKET        reduce using rule 27 (variable -> LOCAL_VAR .)
    ANDAND          reduce using rule 27 (variable -> LOCAL_VAR .)
    OROR            reduce using rule 27 (variable -> LOCAL_VAR .)
    AND             reduce using rule 27 (variable -> LOCAL_VAR .)
    OR              reduce using rule 27 (variable -> LOCAL_VAR .)
    DO              reduce using rule 27 (variable -> LOCAL_VAR .)
    COLON           reduce using rule 27 (variable -> LOCAL_VAR .)
    LPAREN          shift and go to state 92

  ! LPAREN          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]


state 29

    (102) assignment -> expr_postfix . EQLS expression
    (145) expression -> expr_postfix .
    (99) expr_postfix -> expr_postfix . LBRACKET expression RBRACKET
    (146) expr_postfix -> expr_postfix . DOT LOCAL_VAR
    (147) expr_postfix -> expr_postfix . DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> expr_postfix . DOT LOCAL_VAR LPAREN expr_list RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
    EQLS            shift and go to state 93
    RANGE_INCL      reduce using rule 145 (expression -> expr_postfix .)
    RANGE_EXCL      reduce using rule 145 (expression -> expr_postfix .)
    PLUS            reduce using rule 145 (expression -> expr_postfix .)
    MINUS           reduce using rule 145 (expression -> expr_postfix .)
    MULT            reduce using rule 145 (expression -> expr_postfix .)
    DIV             reduce using rule 145 (expression -> expr_postfix .)
    MOD             reduce using rule 145 (expression -> expr_postfix .)
    POWER           reduce using rule 145 (expression -> expr_postfix .)
    BREAK           reduce using rule 145 (expression -> expr_postfix .)
    NEXT            reduce using rule 145 (expression -> expr_postfix .)
    ELSIF           reduce using rule 145 (expression -> expr_postfix .)
    ELSE            reduce using rule 145 (expression -> expr_postfix .)
    RETURN          reduce using rule 145 (expression -> expr_postfix .)
    PRINT           reduce using rule 145 (expression -> expr_postfix .)
    PUTS            reduce using rule 145 (expression -> expr_postfix .)
    WHILE           reduce using rule 145 (expression -> expr_postfix .)
    FOR             reduce using rule 145 (expression -> expr_postfix .)
    LBRACE          reduce using rule 145 (expression -> expr_postfix .)
    DEF             reduce using rule 145 (expression -> expr_postfix .)
    IF              reduce using rule 145 (expression -> expr_postfix .)
    THEN            reduce using rule 145 (expression -> expr_postfix .)
    NOT             reduce using rule 145 (expression -> expr_postfix .)
    NIL             reduce using rule 145 (expression -> expr_postfix .)
    TRUE            reduce using rule 145 (expression -> expr_postfix .)
    FALSE           reduce using rule 145 (expression -> expr_postfix .)
    LPAREN          reduce using rule 145 (expression -> expr_postfix .)
    INTEGER         reduce using rule 145 (expression -> expr_postfix .)
    FLOAT           reduce using rule 145 (expression -> expr_postfix .)
    RATIONAL        reduce using rule 145 (expression -> expr_postfix .)
    COMPLEX         reduce using rule 145 (expression -> expr_postfix .)
    STR             reduce using rule 145 (expression -> expr_postfix .)
    SYMBOL          reduce using rule 145 (expression -> expr_postfix .)
    REGEXP          reduce using rule 145 (expression -> expr_postfix .)
    CLASS           reduce using rule 145 (expression -> expr_postfix .)
    INSTANCE_VAR    reduce using rule 145 (expression -> expr_postfix .)
    CLASS_VAR       reduce using rule 145 (expression -> expr_postfix .)
    GLOBAL_VAR      reduce using rule 145 (expression -> expr_postfix .)
    LOCAL_VAR       reduce using rule 145 (expression -> expr_postfix .)
    CONSTANT        reduce using rule 145 (expression -> expr_postfix .)
    $end            reduce using rule 145 (expression -> expr_postfix .)
    RBRACE          reduce using rule 145 (expression -> expr_postfix .)
    END_S           reduce using rule 145 (expression -> expr_postfix .)
    ARROW           reduce using rule 145 (expression -> expr_postfix .)
    LBRACKET        shift and go to state 94
    DOT             shift and go to state 95

  ! LBRACKET        [ reduce using rule 145 (expression -> expr_postfix .) ]


state 30

    (38) while_stmt -> WHILE . expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> WHILE . expression_logic while_enter statement_list END_S while_exit
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 96
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 31

    (42) for_stmt -> FOR . LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> FOR . LOCAL_VAR IN expression for_enter statement_list END_S for_exit

    LOCAL_VAR       shift and go to state 98


state 32

    (72) hash_literal -> LBRACE . hash_pairs_opt RBRACE
    (8) stmt_block -> LBRACE . statement_list RBRACE
    (73) hash_pairs_opt -> .
    (74) hash_pairs_opt -> . hash_pairs
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (75) hash_pairs -> . hash_pairs COMMA hash_pair
    (76) hash_pairs -> . hash_pair
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (77) hash_pair -> . expression ARROW expression
    (78) hash_pair -> . SYMBOL COLON expression
    (79) hash_pair -> . LOCAL_VAR COLON expression
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 73 (hash_pairs_opt -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 73 (hash_pairs_opt -> .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    SYMBOL          shift and go to state 104
    LOCAL_VAR       shift and go to state 105
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]

    hash_pairs_opt                 shift and go to state 99
    statement_list                 shift and go to state 100
    hash_pairs                     shift and go to state 101
    statement                      shift and go to state 3
    hash_pair                      shift and go to state 102
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 103
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 33

    (103) function_def -> DEF . LOCAL_VAR statement_list END_S
    (104) function_def -> DEF . LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> DEF . LOCAL_VAR optional_params optional_ret statement_list END_S

    LOCAL_VAR       shift and go to state 106


state 34

    (136) expression -> LPAREN . expression RPAREN
    (95) primary -> LPAREN . expression RPAREN
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 107
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 35

    (46) if_stmt -> IF . expression_logic optional_then stmt_block elsif_list else_part END_S
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 108
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 36

    (47) optional_then -> THEN .

    BREAK           reduce using rule 47 (optional_then -> THEN .)
    NEXT            reduce using rule 47 (optional_then -> THEN .)
    ELSIF           reduce using rule 47 (optional_then -> THEN .)
    ELSE            reduce using rule 47 (optional_then -> THEN .)
    RETURN          reduce using rule 47 (optional_then -> THEN .)
    PRINT           reduce using rule 47 (optional_then -> THEN .)
    PUTS            reduce using rule 47 (optional_then -> THEN .)
    WHILE           reduce using rule 47 (optional_then -> THEN .)
    FOR             reduce using rule 47 (optional_then -> THEN .)
    LBRACE          reduce using rule 47 (optional_then -> THEN .)
    DEF             reduce using rule 47 (optional_then -> THEN .)
    IF              reduce using rule 47 (optional_then -> THEN .)
    THEN            reduce using rule 47 (optional_then -> THEN .)
    NOT             reduce using rule 47 (optional_then -> THEN .)
    NIL             reduce using rule 47 (optional_then -> THEN .)
    TRUE            reduce using rule 47 (optional_then -> THEN .)
    FALSE           reduce using rule 47 (optional_then -> THEN .)
    LPAREN          reduce using rule 47 (optional_then -> THEN .)
    INTEGER         reduce using rule 47 (optional_then -> THEN .)
    FLOAT           reduce using rule 47 (optional_then -> THEN .)
    RATIONAL        reduce using rule 47 (optional_then -> THEN .)
    COMPLEX         reduce using rule 47 (optional_then -> THEN .)
    STR             reduce using rule 47 (optional_then -> THEN .)
    SYMBOL          reduce using rule 47 (optional_then -> THEN .)
    REGEXP          reduce using rule 47 (optional_then -> THEN .)
    MINUS           reduce using rule 47 (optional_then -> THEN .)
    CLASS           reduce using rule 47 (optional_then -> THEN .)
    INSTANCE_VAR    reduce using rule 47 (optional_then -> THEN .)
    CLASS_VAR       reduce using rule 47 (optional_then -> THEN .)
    GLOBAL_VAR      reduce using rule 47 (optional_then -> THEN .)
    LOCAL_VAR       reduce using rule 47 (optional_then -> THEN .)
    CONSTANT        reduce using rule 47 (optional_then -> THEN .)
    LBRACKET        reduce using rule 47 (optional_then -> THEN .)
    $end            reduce using rule 47 (optional_then -> THEN .)
    RBRACE          reduce using rule 47 (optional_then -> THEN .)
    END_S           reduce using rule 47 (optional_then -> THEN .)


state 37

    (48) optional_then -> empty .
    (49) elsif_list -> empty .
    (51) else_part -> empty .

  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
    BREAK           reduce using rule 48 (optional_then -> empty .)
    NEXT            reduce using rule 48 (optional_then -> empty .)
    ELSIF           reduce using rule 48 (optional_then -> empty .)
    ELSE            reduce using rule 48 (optional_then -> empty .)
    RETURN          reduce using rule 48 (optional_then -> empty .)
    PRINT           reduce using rule 48 (optional_then -> empty .)
    PUTS            reduce using rule 48 (optional_then -> empty .)
    WHILE           reduce using rule 48 (optional_then -> empty .)
    FOR             reduce using rule 48 (optional_then -> empty .)
    LBRACE          reduce using rule 48 (optional_then -> empty .)
    DEF             reduce using rule 48 (optional_then -> empty .)
    IF              reduce using rule 48 (optional_then -> empty .)
    THEN            reduce using rule 48 (optional_then -> empty .)
    NOT             reduce using rule 48 (optional_then -> empty .)
    NIL             reduce using rule 48 (optional_then -> empty .)
    TRUE            reduce using rule 48 (optional_then -> empty .)
    FALSE           reduce using rule 48 (optional_then -> empty .)
    LPAREN          reduce using rule 48 (optional_then -> empty .)
    INTEGER         reduce using rule 48 (optional_then -> empty .)
    FLOAT           reduce using rule 48 (optional_then -> empty .)
    RATIONAL        reduce using rule 48 (optional_then -> empty .)
    COMPLEX         reduce using rule 48 (optional_then -> empty .)
    STR             reduce using rule 48 (optional_then -> empty .)
    SYMBOL          reduce using rule 48 (optional_then -> empty .)
    REGEXP          reduce using rule 48 (optional_then -> empty .)
    MINUS           reduce using rule 48 (optional_then -> empty .)
    CLASS           reduce using rule 48 (optional_then -> empty .)
    INSTANCE_VAR    reduce using rule 48 (optional_then -> empty .)
    CLASS_VAR       reduce using rule 48 (optional_then -> empty .)
    GLOBAL_VAR      reduce using rule 48 (optional_then -> empty .)
    LOCAL_VAR       reduce using rule 48 (optional_then -> empty .)
    CONSTANT        reduce using rule 48 (optional_then -> empty .)
    LBRACKET        reduce using rule 48 (optional_then -> empty .)
    $end            reduce using rule 48 (optional_then -> empty .)
    RBRACE          reduce using rule 48 (optional_then -> empty .)
    END_S           reduce using rule 48 (optional_then -> empty .)

  ! ELSIF           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NEXT            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! ELSE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RETURN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PRINT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PUTS            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! WHILE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FOR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACE          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! DEF             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! IF              [ reduce using rule 49 (elsif_list -> empty .) ]
  ! THEN            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NOT             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NIL             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! TRUE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FALSE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LPAREN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INTEGER         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FLOAT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RATIONAL        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! COMPLEX         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! STR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! SYMBOL          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! REGEXP          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! MINUS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CONSTANT        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACKET        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! $end            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RBRACE          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 51 (else_part -> empty .) ]
  ! NEXT            [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSIF           [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSE            [ reduce using rule 51 (else_part -> empty .) ]
  ! RETURN          [ reduce using rule 51 (else_part -> empty .) ]
  ! PRINT           [ reduce using rule 51 (else_part -> empty .) ]
  ! PUTS            [ reduce using rule 51 (else_part -> empty .) ]
  ! WHILE           [ reduce using rule 51 (else_part -> empty .) ]
  ! FOR             [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACE          [ reduce using rule 51 (else_part -> empty .) ]
  ! DEF             [ reduce using rule 51 (else_part -> empty .) ]
  ! IF              [ reduce using rule 51 (else_part -> empty .) ]
  ! THEN            [ reduce using rule 51 (else_part -> empty .) ]
  ! NOT             [ reduce using rule 51 (else_part -> empty .) ]
  ! NIL             [ reduce using rule 51 (else_part -> empty .) ]
  ! TRUE            [ reduce using rule 51 (else_part -> empty .) ]
  ! FALSE           [ reduce using rule 51 (else_part -> empty .) ]
  ! LPAREN          [ reduce using rule 51 (else_part -> empty .) ]
  ! INTEGER         [ reduce using rule 51 (else_part -> empty .) ]
  ! FLOAT           [ reduce using rule 51 (else_part -> empty .) ]
  ! RATIONAL        [ reduce using rule 51 (else_part -> empty .) ]
  ! COMPLEX         [ reduce using rule 51 (else_part -> empty .) ]
  ! STR             [ reduce using rule 51 (else_part -> empty .) ]
  ! SYMBOL          [ reduce using rule 51 (else_part -> empty .) ]
  ! REGEXP          [ reduce using rule 51 (else_part -> empty .) ]
  ! MINUS           [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS           [ reduce using rule 51 (else_part -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 51 (else_part -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! CONSTANT        [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACKET        [ reduce using rule 51 (else_part -> empty .) ]
  ! $end            [ reduce using rule 51 (else_part -> empty .) ]
  ! RBRACE          [ reduce using rule 51 (else_part -> empty .) ]
  ! END_S           [ reduce using rule 51 (else_part -> empty .) ]


state 38

    (71) expression -> NOT . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 109
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 39

    (117) expression -> NIL .
    (94) primary -> NIL .

  ! reduce/reduce conflict for LBRACKET resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for PLUS resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for MINUS resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for MULT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for DIV resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for MOD resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for POWER resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for BREAK resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for NEXT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for ELSIF resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for ELSE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RETURN resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for PRINT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for PUTS resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for WHILE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for FOR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for LBRACE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for DEF resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for IF resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for THEN resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for NOT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for NIL resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for TRUE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for FALSE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for LPAREN resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for INTEGER resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for STR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for REGEXP resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for CLASS resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for $end resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RBRACE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for END_S resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for LT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for LE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for GT resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for GE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for EQ resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for NE resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for EQQ resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for MATCH resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for NMATCH resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for ARROW resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RPAREN resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for COMMA resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for ANDAND resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for OROR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for AND resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for OR resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for DO resolved using rule 94 (primary -> NIL .)
  ! reduce/reduce conflict for COLON resolved using rule 94 (primary -> NIL .)
    EQLS            reduce using rule 94 (primary -> NIL .)
    LBRACKET        reduce using rule 94 (primary -> NIL .)
    DOT             reduce using rule 94 (primary -> NIL .)
    RANGE_INCL      reduce using rule 94 (primary -> NIL .)
    RANGE_EXCL      reduce using rule 94 (primary -> NIL .)
    PLUS            reduce using rule 94 (primary -> NIL .)
    MINUS           reduce using rule 94 (primary -> NIL .)
    MULT            reduce using rule 94 (primary -> NIL .)
    DIV             reduce using rule 94 (primary -> NIL .)
    MOD             reduce using rule 94 (primary -> NIL .)
    POWER           reduce using rule 94 (primary -> NIL .)
    BREAK           reduce using rule 94 (primary -> NIL .)
    NEXT            reduce using rule 94 (primary -> NIL .)
    ELSIF           reduce using rule 94 (primary -> NIL .)
    ELSE            reduce using rule 94 (primary -> NIL .)
    RETURN          reduce using rule 94 (primary -> NIL .)
    PRINT           reduce using rule 94 (primary -> NIL .)
    PUTS            reduce using rule 94 (primary -> NIL .)
    WHILE           reduce using rule 94 (primary -> NIL .)
    FOR             reduce using rule 94 (primary -> NIL .)
    LBRACE          reduce using rule 94 (primary -> NIL .)
    DEF             reduce using rule 94 (primary -> NIL .)
    IF              reduce using rule 94 (primary -> NIL .)
    THEN            reduce using rule 94 (primary -> NIL .)
    NOT             reduce using rule 94 (primary -> NIL .)
    NIL             reduce using rule 94 (primary -> NIL .)
    TRUE            reduce using rule 94 (primary -> NIL .)
    FALSE           reduce using rule 94 (primary -> NIL .)
    LPAREN          reduce using rule 94 (primary -> NIL .)
    INTEGER         reduce using rule 94 (primary -> NIL .)
    FLOAT           reduce using rule 94 (primary -> NIL .)
    RATIONAL        reduce using rule 94 (primary -> NIL .)
    COMPLEX         reduce using rule 94 (primary -> NIL .)
    STR             reduce using rule 94 (primary -> NIL .)
    SYMBOL          reduce using rule 94 (primary -> NIL .)
    REGEXP          reduce using rule 94 (primary -> NIL .)
    CLASS           reduce using rule 94 (primary -> NIL .)
    INSTANCE_VAR    reduce using rule 94 (primary -> NIL .)
    CLASS_VAR       reduce using rule 94 (primary -> NIL .)
    GLOBAL_VAR      reduce using rule 94 (primary -> NIL .)
    LOCAL_VAR       reduce using rule 94 (primary -> NIL .)
    CONSTANT        reduce using rule 94 (primary -> NIL .)
    $end            reduce using rule 94 (primary -> NIL .)
    RBRACE          reduce using rule 94 (primary -> NIL .)
    END_S           reduce using rule 94 (primary -> NIL .)
    LT              reduce using rule 94 (primary -> NIL .)
    LE              reduce using rule 94 (primary -> NIL .)
    GT              reduce using rule 94 (primary -> NIL .)
    GE              reduce using rule 94 (primary -> NIL .)
    EQ              reduce using rule 94 (primary -> NIL .)
    NE              reduce using rule 94 (primary -> NIL .)
    EQQ             reduce using rule 94 (primary -> NIL .)
    MATCH           reduce using rule 94 (primary -> NIL .)
    NMATCH          reduce using rule 94 (primary -> NIL .)
    ARROW           reduce using rule 94 (primary -> NIL .)
    RPAREN          reduce using rule 94 (primary -> NIL .)
    COMMA           reduce using rule 94 (primary -> NIL .)
    RBRACKET        reduce using rule 94 (primary -> NIL .)
    ANDAND          reduce using rule 94 (primary -> NIL .)
    OROR            reduce using rule 94 (primary -> NIL .)
    AND             reduce using rule 94 (primary -> NIL .)
    OR              reduce using rule 94 (primary -> NIL .)
    DO              reduce using rule 94 (primary -> NIL .)
    COLON           reduce using rule 94 (primary -> NIL .)

  ! RANGE_INCL      [ reduce using rule 117 (expression -> NIL .) ]
  ! RANGE_EXCL      [ reduce using rule 117 (expression -> NIL .) ]
  ! PLUS            [ reduce using rule 117 (expression -> NIL .) ]
  ! MINUS           [ reduce using rule 117 (expression -> NIL .) ]
  ! MULT            [ reduce using rule 117 (expression -> NIL .) ]
  ! DIV             [ reduce using rule 117 (expression -> NIL .) ]
  ! MOD             [ reduce using rule 117 (expression -> NIL .) ]
  ! POWER           [ reduce using rule 117 (expression -> NIL .) ]
  ! BREAK           [ reduce using rule 117 (expression -> NIL .) ]
  ! NEXT            [ reduce using rule 117 (expression -> NIL .) ]
  ! ELSIF           [ reduce using rule 117 (expression -> NIL .) ]
  ! ELSE            [ reduce using rule 117 (expression -> NIL .) ]
  ! RETURN          [ reduce using rule 117 (expression -> NIL .) ]
  ! PRINT           [ reduce using rule 117 (expression -> NIL .) ]
  ! PUTS            [ reduce using rule 117 (expression -> NIL .) ]
  ! WHILE           [ reduce using rule 117 (expression -> NIL .) ]
  ! FOR             [ reduce using rule 117 (expression -> NIL .) ]
  ! LBRACE          [ reduce using rule 117 (expression -> NIL .) ]
  ! DEF             [ reduce using rule 117 (expression -> NIL .) ]
  ! IF              [ reduce using rule 117 (expression -> NIL .) ]
  ! THEN            [ reduce using rule 117 (expression -> NIL .) ]
  ! NOT             [ reduce using rule 117 (expression -> NIL .) ]
  ! NIL             [ reduce using rule 117 (expression -> NIL .) ]
  ! TRUE            [ reduce using rule 117 (expression -> NIL .) ]
  ! FALSE           [ reduce using rule 117 (expression -> NIL .) ]
  ! LPAREN          [ reduce using rule 117 (expression -> NIL .) ]
  ! INTEGER         [ reduce using rule 117 (expression -> NIL .) ]
  ! FLOAT           [ reduce using rule 117 (expression -> NIL .) ]
  ! RATIONAL        [ reduce using rule 117 (expression -> NIL .) ]
  ! COMPLEX         [ reduce using rule 117 (expression -> NIL .) ]
  ! STR             [ reduce using rule 117 (expression -> NIL .) ]
  ! SYMBOL          [ reduce using rule 117 (expression -> NIL .) ]
  ! REGEXP          [ reduce using rule 117 (expression -> NIL .) ]
  ! CLASS           [ reduce using rule 117 (expression -> NIL .) ]
  ! INSTANCE_VAR    [ reduce using rule 117 (expression -> NIL .) ]
  ! CLASS_VAR       [ reduce using rule 117 (expression -> NIL .) ]
  ! GLOBAL_VAR      [ reduce using rule 117 (expression -> NIL .) ]
  ! LOCAL_VAR       [ reduce using rule 117 (expression -> NIL .) ]
  ! CONSTANT        [ reduce using rule 117 (expression -> NIL .) ]
  ! LBRACKET        [ reduce using rule 117 (expression -> NIL .) ]
  ! $end            [ reduce using rule 117 (expression -> NIL .) ]
  ! RBRACE          [ reduce using rule 117 (expression -> NIL .) ]
  ! END_S           [ reduce using rule 117 (expression -> NIL .) ]
  ! LT              [ reduce using rule 117 (expression -> NIL .) ]
  ! LE              [ reduce using rule 117 (expression -> NIL .) ]
  ! GT              [ reduce using rule 117 (expression -> NIL .) ]
  ! GE              [ reduce using rule 117 (expression -> NIL .) ]
  ! EQ              [ reduce using rule 117 (expression -> NIL .) ]
  ! NE              [ reduce using rule 117 (expression -> NIL .) ]
  ! EQQ             [ reduce using rule 117 (expression -> NIL .) ]
  ! MATCH           [ reduce using rule 117 (expression -> NIL .) ]
  ! NMATCH          [ reduce using rule 117 (expression -> NIL .) ]
  ! ARROW           [ reduce using rule 117 (expression -> NIL .) ]
  ! RPAREN          [ reduce using rule 117 (expression -> NIL .) ]
  ! COMMA           [ reduce using rule 117 (expression -> NIL .) ]
  ! RBRACKET        [ reduce using rule 117 (expression -> NIL .) ]
  ! ANDAND          [ reduce using rule 117 (expression -> NIL .) ]
  ! OROR            [ reduce using rule 117 (expression -> NIL .) ]
  ! AND             [ reduce using rule 117 (expression -> NIL .) ]
  ! OR              [ reduce using rule 117 (expression -> NIL .) ]
  ! DO              [ reduce using rule 117 (expression -> NIL .) ]
  ! COLON           [ reduce using rule 117 (expression -> NIL .) ]


state 40

    (118) expression -> TRUE .
    (92) primary -> TRUE .

  ! reduce/reduce conflict for LBRACKET resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for PLUS resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for MINUS resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for MULT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for DIV resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for MOD resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for POWER resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for BREAK resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for NEXT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for ELSIF resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for ELSE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RETURN resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for PRINT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for PUTS resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for WHILE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for FOR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for DEF resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for IF resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for THEN resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for NOT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for NIL resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for TRUE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for FALSE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for INTEGER resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for FLOAT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for STR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for REGEXP resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for CLASS resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for $end resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for END_S resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for LT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for LE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for GT resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for GE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for EQ resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for NE resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for EQQ resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for MATCH resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for NMATCH resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for ARROW resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for COMMA resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for ANDAND resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for OROR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for AND resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for OR resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for DO resolved using rule 92 (primary -> TRUE .)
  ! reduce/reduce conflict for COLON resolved using rule 92 (primary -> TRUE .)
    EQLS            reduce using rule 92 (primary -> TRUE .)
    LBRACKET        reduce using rule 92 (primary -> TRUE .)
    DOT             reduce using rule 92 (primary -> TRUE .)
    RANGE_INCL      reduce using rule 92 (primary -> TRUE .)
    RANGE_EXCL      reduce using rule 92 (primary -> TRUE .)
    PLUS            reduce using rule 92 (primary -> TRUE .)
    MINUS           reduce using rule 92 (primary -> TRUE .)
    MULT            reduce using rule 92 (primary -> TRUE .)
    DIV             reduce using rule 92 (primary -> TRUE .)
    MOD             reduce using rule 92 (primary -> TRUE .)
    POWER           reduce using rule 92 (primary -> TRUE .)
    BREAK           reduce using rule 92 (primary -> TRUE .)
    NEXT            reduce using rule 92 (primary -> TRUE .)
    ELSIF           reduce using rule 92 (primary -> TRUE .)
    ELSE            reduce using rule 92 (primary -> TRUE .)
    RETURN          reduce using rule 92 (primary -> TRUE .)
    PRINT           reduce using rule 92 (primary -> TRUE .)
    PUTS            reduce using rule 92 (primary -> TRUE .)
    WHILE           reduce using rule 92 (primary -> TRUE .)
    FOR             reduce using rule 92 (primary -> TRUE .)
    LBRACE          reduce using rule 92 (primary -> TRUE .)
    DEF             reduce using rule 92 (primary -> TRUE .)
    IF              reduce using rule 92 (primary -> TRUE .)
    THEN            reduce using rule 92 (primary -> TRUE .)
    NOT             reduce using rule 92 (primary -> TRUE .)
    NIL             reduce using rule 92 (primary -> TRUE .)
    TRUE            reduce using rule 92 (primary -> TRUE .)
    FALSE           reduce using rule 92 (primary -> TRUE .)
    LPAREN          reduce using rule 92 (primary -> TRUE .)
    INTEGER         reduce using rule 92 (primary -> TRUE .)
    FLOAT           reduce using rule 92 (primary -> TRUE .)
    RATIONAL        reduce using rule 92 (primary -> TRUE .)
    COMPLEX         reduce using rule 92 (primary -> TRUE .)
    STR             reduce using rule 92 (primary -> TRUE .)
    SYMBOL          reduce using rule 92 (primary -> TRUE .)
    REGEXP          reduce using rule 92 (primary -> TRUE .)
    CLASS           reduce using rule 92 (primary -> TRUE .)
    INSTANCE_VAR    reduce using rule 92 (primary -> TRUE .)
    CLASS_VAR       reduce using rule 92 (primary -> TRUE .)
    GLOBAL_VAR      reduce using rule 92 (primary -> TRUE .)
    LOCAL_VAR       reduce using rule 92 (primary -> TRUE .)
    CONSTANT        reduce using rule 92 (primary -> TRUE .)
    $end            reduce using rule 92 (primary -> TRUE .)
    RBRACE          reduce using rule 92 (primary -> TRUE .)
    END_S           reduce using rule 92 (primary -> TRUE .)
    LT              reduce using rule 92 (primary -> TRUE .)
    LE              reduce using rule 92 (primary -> TRUE .)
    GT              reduce using rule 92 (primary -> TRUE .)
    GE              reduce using rule 92 (primary -> TRUE .)
    EQ              reduce using rule 92 (primary -> TRUE .)
    NE              reduce using rule 92 (primary -> TRUE .)
    EQQ             reduce using rule 92 (primary -> TRUE .)
    MATCH           reduce using rule 92 (primary -> TRUE .)
    NMATCH          reduce using rule 92 (primary -> TRUE .)
    ARROW           reduce using rule 92 (primary -> TRUE .)
    RPAREN          reduce using rule 92 (primary -> TRUE .)
    COMMA           reduce using rule 92 (primary -> TRUE .)
    RBRACKET        reduce using rule 92 (primary -> TRUE .)
    ANDAND          reduce using rule 92 (primary -> TRUE .)
    OROR            reduce using rule 92 (primary -> TRUE .)
    AND             reduce using rule 92 (primary -> TRUE .)
    OR              reduce using rule 92 (primary -> TRUE .)
    DO              reduce using rule 92 (primary -> TRUE .)
    COLON           reduce using rule 92 (primary -> TRUE .)

  ! RANGE_INCL      [ reduce using rule 118 (expression -> TRUE .) ]
  ! RANGE_EXCL      [ reduce using rule 118 (expression -> TRUE .) ]
  ! PLUS            [ reduce using rule 118 (expression -> TRUE .) ]
  ! MINUS           [ reduce using rule 118 (expression -> TRUE .) ]
  ! MULT            [ reduce using rule 118 (expression -> TRUE .) ]
  ! DIV             [ reduce using rule 118 (expression -> TRUE .) ]
  ! MOD             [ reduce using rule 118 (expression -> TRUE .) ]
  ! POWER           [ reduce using rule 118 (expression -> TRUE .) ]
  ! BREAK           [ reduce using rule 118 (expression -> TRUE .) ]
  ! NEXT            [ reduce using rule 118 (expression -> TRUE .) ]
  ! ELSIF           [ reduce using rule 118 (expression -> TRUE .) ]
  ! ELSE            [ reduce using rule 118 (expression -> TRUE .) ]
  ! RETURN          [ reduce using rule 118 (expression -> TRUE .) ]
  ! PRINT           [ reduce using rule 118 (expression -> TRUE .) ]
  ! PUTS            [ reduce using rule 118 (expression -> TRUE .) ]
  ! WHILE           [ reduce using rule 118 (expression -> TRUE .) ]
  ! FOR             [ reduce using rule 118 (expression -> TRUE .) ]
  ! LBRACE          [ reduce using rule 118 (expression -> TRUE .) ]
  ! DEF             [ reduce using rule 118 (expression -> TRUE .) ]
  ! IF              [ reduce using rule 118 (expression -> TRUE .) ]
  ! THEN            [ reduce using rule 118 (expression -> TRUE .) ]
  ! NOT             [ reduce using rule 118 (expression -> TRUE .) ]
  ! NIL             [ reduce using rule 118 (expression -> TRUE .) ]
  ! TRUE            [ reduce using rule 118 (expression -> TRUE .) ]
  ! FALSE           [ reduce using rule 118 (expression -> TRUE .) ]
  ! LPAREN          [ reduce using rule 118 (expression -> TRUE .) ]
  ! INTEGER         [ reduce using rule 118 (expression -> TRUE .) ]
  ! FLOAT           [ reduce using rule 118 (expression -> TRUE .) ]
  ! RATIONAL        [ reduce using rule 118 (expression -> TRUE .) ]
  ! COMPLEX         [ reduce using rule 118 (expression -> TRUE .) ]
  ! STR             [ reduce using rule 118 (expression -> TRUE .) ]
  ! SYMBOL          [ reduce using rule 118 (expression -> TRUE .) ]
  ! REGEXP          [ reduce using rule 118 (expression -> TRUE .) ]
  ! CLASS           [ reduce using rule 118 (expression -> TRUE .) ]
  ! INSTANCE_VAR    [ reduce using rule 118 (expression -> TRUE .) ]
  ! CLASS_VAR       [ reduce using rule 118 (expression -> TRUE .) ]
  ! GLOBAL_VAR      [ reduce using rule 118 (expression -> TRUE .) ]
  ! LOCAL_VAR       [ reduce using rule 118 (expression -> TRUE .) ]
  ! CONSTANT        [ reduce using rule 118 (expression -> TRUE .) ]
  ! LBRACKET        [ reduce using rule 118 (expression -> TRUE .) ]
  ! $end            [ reduce using rule 118 (expression -> TRUE .) ]
  ! RBRACE          [ reduce using rule 118 (expression -> TRUE .) ]
  ! END_S           [ reduce using rule 118 (expression -> TRUE .) ]
  ! LT              [ reduce using rule 118 (expression -> TRUE .) ]
  ! LE              [ reduce using rule 118 (expression -> TRUE .) ]
  ! GT              [ reduce using rule 118 (expression -> TRUE .) ]
  ! GE              [ reduce using rule 118 (expression -> TRUE .) ]
  ! EQ              [ reduce using rule 118 (expression -> TRUE .) ]
  ! NE              [ reduce using rule 118 (expression -> TRUE .) ]
  ! EQQ             [ reduce using rule 118 (expression -> TRUE .) ]
  ! MATCH           [ reduce using rule 118 (expression -> TRUE .) ]
  ! NMATCH          [ reduce using rule 118 (expression -> TRUE .) ]
  ! ARROW           [ reduce using rule 118 (expression -> TRUE .) ]
  ! RPAREN          [ reduce using rule 118 (expression -> TRUE .) ]
  ! COMMA           [ reduce using rule 118 (expression -> TRUE .) ]
  ! RBRACKET        [ reduce using rule 118 (expression -> TRUE .) ]
  ! ANDAND          [ reduce using rule 118 (expression -> TRUE .) ]
  ! OROR            [ reduce using rule 118 (expression -> TRUE .) ]
  ! AND             [ reduce using rule 118 (expression -> TRUE .) ]
  ! OR              [ reduce using rule 118 (expression -> TRUE .) ]
  ! DO              [ reduce using rule 118 (expression -> TRUE .) ]
  ! COLON           [ reduce using rule 118 (expression -> TRUE .) ]


state 41

    (119) expression -> FALSE .
    (93) primary -> FALSE .

  ! reduce/reduce conflict for LBRACKET resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for PLUS resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for MINUS resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for MULT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for DIV resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for MOD resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for POWER resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for BREAK resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for NEXT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for ELSIF resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for ELSE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RETURN resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for PRINT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for PUTS resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for WHILE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for FOR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for DEF resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for IF resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for THEN resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for NOT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for NIL resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for TRUE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for FALSE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for LPAREN resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for INTEGER resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for FLOAT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for STR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for REGEXP resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for CLASS resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for $end resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for END_S resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for LT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for LE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for GT resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for GE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for EQ resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for NE resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for EQQ resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for MATCH resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for NMATCH resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for ARROW resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for COMMA resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for ANDAND resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for OROR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for AND resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for OR resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for DO resolved using rule 93 (primary -> FALSE .)
  ! reduce/reduce conflict for COLON resolved using rule 93 (primary -> FALSE .)
    EQLS            reduce using rule 93 (primary -> FALSE .)
    LBRACKET        reduce using rule 93 (primary -> FALSE .)
    DOT             reduce using rule 93 (primary -> FALSE .)
    RANGE_INCL      reduce using rule 93 (primary -> FALSE .)
    RANGE_EXCL      reduce using rule 93 (primary -> FALSE .)
    PLUS            reduce using rule 93 (primary -> FALSE .)
    MINUS           reduce using rule 93 (primary -> FALSE .)
    MULT            reduce using rule 93 (primary -> FALSE .)
    DIV             reduce using rule 93 (primary -> FALSE .)
    MOD             reduce using rule 93 (primary -> FALSE .)
    POWER           reduce using rule 93 (primary -> FALSE .)
    BREAK           reduce using rule 93 (primary -> FALSE .)
    NEXT            reduce using rule 93 (primary -> FALSE .)
    ELSIF           reduce using rule 93 (primary -> FALSE .)
    ELSE            reduce using rule 93 (primary -> FALSE .)
    RETURN          reduce using rule 93 (primary -> FALSE .)
    PRINT           reduce using rule 93 (primary -> FALSE .)
    PUTS            reduce using rule 93 (primary -> FALSE .)
    WHILE           reduce using rule 93 (primary -> FALSE .)
    FOR             reduce using rule 93 (primary -> FALSE .)
    LBRACE          reduce using rule 93 (primary -> FALSE .)
    DEF             reduce using rule 93 (primary -> FALSE .)
    IF              reduce using rule 93 (primary -> FALSE .)
    THEN            reduce using rule 93 (primary -> FALSE .)
    NOT             reduce using rule 93 (primary -> FALSE .)
    NIL             reduce using rule 93 (primary -> FALSE .)
    TRUE            reduce using rule 93 (primary -> FALSE .)
    FALSE           reduce using rule 93 (primary -> FALSE .)
    LPAREN          reduce using rule 93 (primary -> FALSE .)
    INTEGER         reduce using rule 93 (primary -> FALSE .)
    FLOAT           reduce using rule 93 (primary -> FALSE .)
    RATIONAL        reduce using rule 93 (primary -> FALSE .)
    COMPLEX         reduce using rule 93 (primary -> FALSE .)
    STR             reduce using rule 93 (primary -> FALSE .)
    SYMBOL          reduce using rule 93 (primary -> FALSE .)
    REGEXP          reduce using rule 93 (primary -> FALSE .)
    CLASS           reduce using rule 93 (primary -> FALSE .)
    INSTANCE_VAR    reduce using rule 93 (primary -> FALSE .)
    CLASS_VAR       reduce using rule 93 (primary -> FALSE .)
    GLOBAL_VAR      reduce using rule 93 (primary -> FALSE .)
    LOCAL_VAR       reduce using rule 93 (primary -> FALSE .)
    CONSTANT        reduce using rule 93 (primary -> FALSE .)
    $end            reduce using rule 93 (primary -> FALSE .)
    RBRACE          reduce using rule 93 (primary -> FALSE .)
    END_S           reduce using rule 93 (primary -> FALSE .)
    LT              reduce using rule 93 (primary -> FALSE .)
    LE              reduce using rule 93 (primary -> FALSE .)
    GT              reduce using rule 93 (primary -> FALSE .)
    GE              reduce using rule 93 (primary -> FALSE .)
    EQ              reduce using rule 93 (primary -> FALSE .)
    NE              reduce using rule 93 (primary -> FALSE .)
    EQQ             reduce using rule 93 (primary -> FALSE .)
    MATCH           reduce using rule 93 (primary -> FALSE .)
    NMATCH          reduce using rule 93 (primary -> FALSE .)
    ARROW           reduce using rule 93 (primary -> FALSE .)
    RPAREN          reduce using rule 93 (primary -> FALSE .)
    COMMA           reduce using rule 93 (primary -> FALSE .)
    RBRACKET        reduce using rule 93 (primary -> FALSE .)
    ANDAND          reduce using rule 93 (primary -> FALSE .)
    OROR            reduce using rule 93 (primary -> FALSE .)
    AND             reduce using rule 93 (primary -> FALSE .)
    OR              reduce using rule 93 (primary -> FALSE .)
    DO              reduce using rule 93 (primary -> FALSE .)
    COLON           reduce using rule 93 (primary -> FALSE .)

  ! RANGE_INCL      [ reduce using rule 119 (expression -> FALSE .) ]
  ! RANGE_EXCL      [ reduce using rule 119 (expression -> FALSE .) ]
  ! PLUS            [ reduce using rule 119 (expression -> FALSE .) ]
  ! MINUS           [ reduce using rule 119 (expression -> FALSE .) ]
  ! MULT            [ reduce using rule 119 (expression -> FALSE .) ]
  ! DIV             [ reduce using rule 119 (expression -> FALSE .) ]
  ! MOD             [ reduce using rule 119 (expression -> FALSE .) ]
  ! POWER           [ reduce using rule 119 (expression -> FALSE .) ]
  ! BREAK           [ reduce using rule 119 (expression -> FALSE .) ]
  ! NEXT            [ reduce using rule 119 (expression -> FALSE .) ]
  ! ELSIF           [ reduce using rule 119 (expression -> FALSE .) ]
  ! ELSE            [ reduce using rule 119 (expression -> FALSE .) ]
  ! RETURN          [ reduce using rule 119 (expression -> FALSE .) ]
  ! PRINT           [ reduce using rule 119 (expression -> FALSE .) ]
  ! PUTS            [ reduce using rule 119 (expression -> FALSE .) ]
  ! WHILE           [ reduce using rule 119 (expression -> FALSE .) ]
  ! FOR             [ reduce using rule 119 (expression -> FALSE .) ]
  ! LBRACE          [ reduce using rule 119 (expression -> FALSE .) ]
  ! DEF             [ reduce using rule 119 (expression -> FALSE .) ]
  ! IF              [ reduce using rule 119 (expression -> FALSE .) ]
  ! THEN            [ reduce using rule 119 (expression -> FALSE .) ]
  ! NOT             [ reduce using rule 119 (expression -> FALSE .) ]
  ! NIL             [ reduce using rule 119 (expression -> FALSE .) ]
  ! TRUE            [ reduce using rule 119 (expression -> FALSE .) ]
  ! FALSE           [ reduce using rule 119 (expression -> FALSE .) ]
  ! LPAREN          [ reduce using rule 119 (expression -> FALSE .) ]
  ! INTEGER         [ reduce using rule 119 (expression -> FALSE .) ]
  ! FLOAT           [ reduce using rule 119 (expression -> FALSE .) ]
  ! RATIONAL        [ reduce using rule 119 (expression -> FALSE .) ]
  ! COMPLEX         [ reduce using rule 119 (expression -> FALSE .) ]
  ! STR             [ reduce using rule 119 (expression -> FALSE .) ]
  ! SYMBOL          [ reduce using rule 119 (expression -> FALSE .) ]
  ! REGEXP          [ reduce using rule 119 (expression -> FALSE .) ]
  ! CLASS           [ reduce using rule 119 (expression -> FALSE .) ]
  ! INSTANCE_VAR    [ reduce using rule 119 (expression -> FALSE .) ]
  ! CLASS_VAR       [ reduce using rule 119 (expression -> FALSE .) ]
  ! GLOBAL_VAR      [ reduce using rule 119 (expression -> FALSE .) ]
  ! LOCAL_VAR       [ reduce using rule 119 (expression -> FALSE .) ]
  ! CONSTANT        [ reduce using rule 119 (expression -> FALSE .) ]
  ! LBRACKET        [ reduce using rule 119 (expression -> FALSE .) ]
  ! $end            [ reduce using rule 119 (expression -> FALSE .) ]
  ! RBRACE          [ reduce using rule 119 (expression -> FALSE .) ]
  ! END_S           [ reduce using rule 119 (expression -> FALSE .) ]
  ! LT              [ reduce using rule 119 (expression -> FALSE .) ]
  ! LE              [ reduce using rule 119 (expression -> FALSE .) ]
  ! GT              [ reduce using rule 119 (expression -> FALSE .) ]
  ! GE              [ reduce using rule 119 (expression -> FALSE .) ]
  ! EQ              [ reduce using rule 119 (expression -> FALSE .) ]
  ! NE              [ reduce using rule 119 (expression -> FALSE .) ]
  ! EQQ             [ reduce using rule 119 (expression -> FALSE .) ]
  ! MATCH           [ reduce using rule 119 (expression -> FALSE .) ]
  ! NMATCH          [ reduce using rule 119 (expression -> FALSE .) ]
  ! ARROW           [ reduce using rule 119 (expression -> FALSE .) ]
  ! RPAREN          [ reduce using rule 119 (expression -> FALSE .) ]
  ! COMMA           [ reduce using rule 119 (expression -> FALSE .) ]
  ! RBRACKET        [ reduce using rule 119 (expression -> FALSE .) ]
  ! ANDAND          [ reduce using rule 119 (expression -> FALSE .) ]
  ! OROR            [ reduce using rule 119 (expression -> FALSE .) ]
  ! AND             [ reduce using rule 119 (expression -> FALSE .) ]
  ! OR              [ reduce using rule 119 (expression -> FALSE .) ]
  ! DO              [ reduce using rule 119 (expression -> FALSE .) ]
  ! COLON           [ reduce using rule 119 (expression -> FALSE .) ]


state 42

    (149) expression -> MINUS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 110
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 43

    (137) expression -> INTEGER .
    (87) primary -> INTEGER .

  ! reduce/reduce conflict for LBRACKET resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for PLUS resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for MINUS resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for MULT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for DIV resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for MOD resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for POWER resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for BREAK resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for NEXT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for ELSIF resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for PUTS resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for WHILE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for DEF resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for THEN resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for NIL resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for TRUE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for FALSE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for STR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for REGEXP resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for CLASS resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for END_S resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for LT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for LE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for GT resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for GE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for EQ resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for NE resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for EQQ resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for MATCH resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for NMATCH resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for ARROW resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for COMMA resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for ANDAND resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for OROR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for AND resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for OR resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for DO resolved using rule 87 (primary -> INTEGER .)
  ! reduce/reduce conflict for COLON resolved using rule 87 (primary -> INTEGER .)
    EQLS            reduce using rule 87 (primary -> INTEGER .)
    LBRACKET        reduce using rule 87 (primary -> INTEGER .)
    DOT             reduce using rule 87 (primary -> INTEGER .)
    RANGE_INCL      reduce using rule 87 (primary -> INTEGER .)
    RANGE_EXCL      reduce using rule 87 (primary -> INTEGER .)
    PLUS            reduce using rule 87 (primary -> INTEGER .)
    MINUS           reduce using rule 87 (primary -> INTEGER .)
    MULT            reduce using rule 87 (primary -> INTEGER .)
    DIV             reduce using rule 87 (primary -> INTEGER .)
    MOD             reduce using rule 87 (primary -> INTEGER .)
    POWER           reduce using rule 87 (primary -> INTEGER .)
    BREAK           reduce using rule 87 (primary -> INTEGER .)
    NEXT            reduce using rule 87 (primary -> INTEGER .)
    ELSIF           reduce using rule 87 (primary -> INTEGER .)
    ELSE            reduce using rule 87 (primary -> INTEGER .)
    RETURN          reduce using rule 87 (primary -> INTEGER .)
    PRINT           reduce using rule 87 (primary -> INTEGER .)
    PUTS            reduce using rule 87 (primary -> INTEGER .)
    WHILE           reduce using rule 87 (primary -> INTEGER .)
    FOR             reduce using rule 87 (primary -> INTEGER .)
    LBRACE          reduce using rule 87 (primary -> INTEGER .)
    DEF             reduce using rule 87 (primary -> INTEGER .)
    IF              reduce using rule 87 (primary -> INTEGER .)
    THEN            reduce using rule 87 (primary -> INTEGER .)
    NOT             reduce using rule 87 (primary -> INTEGER .)
    NIL             reduce using rule 87 (primary -> INTEGER .)
    TRUE            reduce using rule 87 (primary -> INTEGER .)
    FALSE           reduce using rule 87 (primary -> INTEGER .)
    LPAREN          reduce using rule 87 (primary -> INTEGER .)
    INTEGER         reduce using rule 87 (primary -> INTEGER .)
    FLOAT           reduce using rule 87 (primary -> INTEGER .)
    RATIONAL        reduce using rule 87 (primary -> INTEGER .)
    COMPLEX         reduce using rule 87 (primary -> INTEGER .)
    STR             reduce using rule 87 (primary -> INTEGER .)
    SYMBOL          reduce using rule 87 (primary -> INTEGER .)
    REGEXP          reduce using rule 87 (primary -> INTEGER .)
    CLASS           reduce using rule 87 (primary -> INTEGER .)
    INSTANCE_VAR    reduce using rule 87 (primary -> INTEGER .)
    CLASS_VAR       reduce using rule 87 (primary -> INTEGER .)
    GLOBAL_VAR      reduce using rule 87 (primary -> INTEGER .)
    LOCAL_VAR       reduce using rule 87 (primary -> INTEGER .)
    CONSTANT        reduce using rule 87 (primary -> INTEGER .)
    $end            reduce using rule 87 (primary -> INTEGER .)
    RBRACE          reduce using rule 87 (primary -> INTEGER .)
    END_S           reduce using rule 87 (primary -> INTEGER .)
    LT              reduce using rule 87 (primary -> INTEGER .)
    LE              reduce using rule 87 (primary -> INTEGER .)
    GT              reduce using rule 87 (primary -> INTEGER .)
    GE              reduce using rule 87 (primary -> INTEGER .)
    EQ              reduce using rule 87 (primary -> INTEGER .)
    NE              reduce using rule 87 (primary -> INTEGER .)
    EQQ             reduce using rule 87 (primary -> INTEGER .)
    MATCH           reduce using rule 87 (primary -> INTEGER .)
    NMATCH          reduce using rule 87 (primary -> INTEGER .)
    ARROW           reduce using rule 87 (primary -> INTEGER .)
    RPAREN          reduce using rule 87 (primary -> INTEGER .)
    COMMA           reduce using rule 87 (primary -> INTEGER .)
    RBRACKET        reduce using rule 87 (primary -> INTEGER .)
    ANDAND          reduce using rule 87 (primary -> INTEGER .)
    OROR            reduce using rule 87 (primary -> INTEGER .)
    AND             reduce using rule 87 (primary -> INTEGER .)
    OR              reduce using rule 87 (primary -> INTEGER .)
    DO              reduce using rule 87 (primary -> INTEGER .)
    COLON           reduce using rule 87 (primary -> INTEGER .)

  ! RANGE_INCL      [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RANGE_EXCL      [ reduce using rule 137 (expression -> INTEGER .) ]
  ! PLUS            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! MINUS           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! MULT            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! DIV             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! MOD             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! POWER           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! BREAK           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! NEXT            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! ELSIF           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! ELSE            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RETURN          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! PRINT           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! PUTS            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! WHILE           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! FOR             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LBRACE          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! DEF             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! IF              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! THEN            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! NOT             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! NIL             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! TRUE            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! FALSE           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LPAREN          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 137 (expression -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RATIONAL        [ reduce using rule 137 (expression -> INTEGER .) ]
  ! COMPLEX         [ reduce using rule 137 (expression -> INTEGER .) ]
  ! STR             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! SYMBOL          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! REGEXP          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! CLASS           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! INSTANCE_VAR    [ reduce using rule 137 (expression -> INTEGER .) ]
  ! CLASS_VAR       [ reduce using rule 137 (expression -> INTEGER .) ]
  ! GLOBAL_VAR      [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LOCAL_VAR       [ reduce using rule 137 (expression -> INTEGER .) ]
  ! CONSTANT        [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LBRACKET        [ reduce using rule 137 (expression -> INTEGER .) ]
  ! $end            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RBRACE          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! END_S           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LT              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! LE              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! GT              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! GE              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! EQ              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! NE              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! EQQ             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! MATCH           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! NMATCH          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! ARROW           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! COMMA           [ reduce using rule 137 (expression -> INTEGER .) ]
  ! RBRACKET        [ reduce using rule 137 (expression -> INTEGER .) ]
  ! ANDAND          [ reduce using rule 137 (expression -> INTEGER .) ]
  ! OROR            [ reduce using rule 137 (expression -> INTEGER .) ]
  ! AND             [ reduce using rule 137 (expression -> INTEGER .) ]
  ! OR              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! DO              [ reduce using rule 137 (expression -> INTEGER .) ]
  ! COLON           [ reduce using rule 137 (expression -> INTEGER .) ]


state 44

    (138) expression -> FLOAT .
    (88) primary -> FLOAT .

  ! reduce/reduce conflict for LBRACKET resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for PLUS resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for MINUS resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for MULT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for DIV resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for MOD resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for POWER resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for BREAK resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for NEXT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for ELSIF resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for PUTS resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for WHILE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for LBRACE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for DEF resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for THEN resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for NIL resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for TRUE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for FALSE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for LPAREN resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for STR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for REGEXP resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for CLASS resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RBRACE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for END_S resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for LT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for LE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for GT resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for GE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for EQ resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for NE resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for EQQ resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for MATCH resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for NMATCH resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for ARROW resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for ANDAND resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for OROR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for AND resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for OR resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for DO resolved using rule 88 (primary -> FLOAT .)
  ! reduce/reduce conflict for COLON resolved using rule 88 (primary -> FLOAT .)
    EQLS            reduce using rule 88 (primary -> FLOAT .)
    LBRACKET        reduce using rule 88 (primary -> FLOAT .)
    DOT             reduce using rule 88 (primary -> FLOAT .)
    RANGE_INCL      reduce using rule 88 (primary -> FLOAT .)
    RANGE_EXCL      reduce using rule 88 (primary -> FLOAT .)
    PLUS            reduce using rule 88 (primary -> FLOAT .)
    MINUS           reduce using rule 88 (primary -> FLOAT .)
    MULT            reduce using rule 88 (primary -> FLOAT .)
    DIV             reduce using rule 88 (primary -> FLOAT .)
    MOD             reduce using rule 88 (primary -> FLOAT .)
    POWER           reduce using rule 88 (primary -> FLOAT .)
    BREAK           reduce using rule 88 (primary -> FLOAT .)
    NEXT            reduce using rule 88 (primary -> FLOAT .)
    ELSIF           reduce using rule 88 (primary -> FLOAT .)
    ELSE            reduce using rule 88 (primary -> FLOAT .)
    RETURN          reduce using rule 88 (primary -> FLOAT .)
    PRINT           reduce using rule 88 (primary -> FLOAT .)
    PUTS            reduce using rule 88 (primary -> FLOAT .)
    WHILE           reduce using rule 88 (primary -> FLOAT .)
    FOR             reduce using rule 88 (primary -> FLOAT .)
    LBRACE          reduce using rule 88 (primary -> FLOAT .)
    DEF             reduce using rule 88 (primary -> FLOAT .)
    IF              reduce using rule 88 (primary -> FLOAT .)
    THEN            reduce using rule 88 (primary -> FLOAT .)
    NOT             reduce using rule 88 (primary -> FLOAT .)
    NIL             reduce using rule 88 (primary -> FLOAT .)
    TRUE            reduce using rule 88 (primary -> FLOAT .)
    FALSE           reduce using rule 88 (primary -> FLOAT .)
    LPAREN          reduce using rule 88 (primary -> FLOAT .)
    INTEGER         reduce using rule 88 (primary -> FLOAT .)
    FLOAT           reduce using rule 88 (primary -> FLOAT .)
    RATIONAL        reduce using rule 88 (primary -> FLOAT .)
    COMPLEX         reduce using rule 88 (primary -> FLOAT .)
    STR             reduce using rule 88 (primary -> FLOAT .)
    SYMBOL          reduce using rule 88 (primary -> FLOAT .)
    REGEXP          reduce using rule 88 (primary -> FLOAT .)
    CLASS           reduce using rule 88 (primary -> FLOAT .)
    INSTANCE_VAR    reduce using rule 88 (primary -> FLOAT .)
    CLASS_VAR       reduce using rule 88 (primary -> FLOAT .)
    GLOBAL_VAR      reduce using rule 88 (primary -> FLOAT .)
    LOCAL_VAR       reduce using rule 88 (primary -> FLOAT .)
    CONSTANT        reduce using rule 88 (primary -> FLOAT .)
    $end            reduce using rule 88 (primary -> FLOAT .)
    RBRACE          reduce using rule 88 (primary -> FLOAT .)
    END_S           reduce using rule 88 (primary -> FLOAT .)
    LT              reduce using rule 88 (primary -> FLOAT .)
    LE              reduce using rule 88 (primary -> FLOAT .)
    GT              reduce using rule 88 (primary -> FLOAT .)
    GE              reduce using rule 88 (primary -> FLOAT .)
    EQ              reduce using rule 88 (primary -> FLOAT .)
    NE              reduce using rule 88 (primary -> FLOAT .)
    EQQ             reduce using rule 88 (primary -> FLOAT .)
    MATCH           reduce using rule 88 (primary -> FLOAT .)
    NMATCH          reduce using rule 88 (primary -> FLOAT .)
    ARROW           reduce using rule 88 (primary -> FLOAT .)
    RPAREN          reduce using rule 88 (primary -> FLOAT .)
    COMMA           reduce using rule 88 (primary -> FLOAT .)
    RBRACKET        reduce using rule 88 (primary -> FLOAT .)
    ANDAND          reduce using rule 88 (primary -> FLOAT .)
    OROR            reduce using rule 88 (primary -> FLOAT .)
    AND             reduce using rule 88 (primary -> FLOAT .)
    OR              reduce using rule 88 (primary -> FLOAT .)
    DO              reduce using rule 88 (primary -> FLOAT .)
    COLON           reduce using rule 88 (primary -> FLOAT .)

  ! RANGE_INCL      [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RANGE_EXCL      [ reduce using rule 138 (expression -> FLOAT .) ]
  ! PLUS            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! MINUS           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! MULT            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! DIV             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! MOD             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! POWER           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! BREAK           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! NEXT            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! ELSIF           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! ELSE            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RETURN          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! PRINT           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! PUTS            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! WHILE           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! FOR             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LBRACE          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! DEF             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! IF              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! THEN            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! NOT             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! NIL             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! TRUE            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! FALSE           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LPAREN          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 138 (expression -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RATIONAL        [ reduce using rule 138 (expression -> FLOAT .) ]
  ! COMPLEX         [ reduce using rule 138 (expression -> FLOAT .) ]
  ! STR             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! SYMBOL          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! REGEXP          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! CLASS           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! INSTANCE_VAR    [ reduce using rule 138 (expression -> FLOAT .) ]
  ! CLASS_VAR       [ reduce using rule 138 (expression -> FLOAT .) ]
  ! GLOBAL_VAR      [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LOCAL_VAR       [ reduce using rule 138 (expression -> FLOAT .) ]
  ! CONSTANT        [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LBRACKET        [ reduce using rule 138 (expression -> FLOAT .) ]
  ! $end            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RBRACE          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! END_S           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LT              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! LE              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! GT              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! GE              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! EQ              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! NE              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! EQQ             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! MATCH           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! NMATCH          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! ARROW           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! COMMA           [ reduce using rule 138 (expression -> FLOAT .) ]
  ! RBRACKET        [ reduce using rule 138 (expression -> FLOAT .) ]
  ! ANDAND          [ reduce using rule 138 (expression -> FLOAT .) ]
  ! OROR            [ reduce using rule 138 (expression -> FLOAT .) ]
  ! AND             [ reduce using rule 138 (expression -> FLOAT .) ]
  ! OR              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! DO              [ reduce using rule 138 (expression -> FLOAT .) ]
  ! COLON           [ reduce using rule 138 (expression -> FLOAT .) ]


state 45

    (139) expression -> RATIONAL .

    RANGE_INCL      reduce using rule 139 (expression -> RATIONAL .)
    RANGE_EXCL      reduce using rule 139 (expression -> RATIONAL .)
    PLUS            reduce using rule 139 (expression -> RATIONAL .)
    MINUS           reduce using rule 139 (expression -> RATIONAL .)
    MULT            reduce using rule 139 (expression -> RATIONAL .)
    DIV             reduce using rule 139 (expression -> RATIONAL .)
    MOD             reduce using rule 139 (expression -> RATIONAL .)
    POWER           reduce using rule 139 (expression -> RATIONAL .)
    BREAK           reduce using rule 139 (expression -> RATIONAL .)
    NEXT            reduce using rule 139 (expression -> RATIONAL .)
    ELSIF           reduce using rule 139 (expression -> RATIONAL .)
    ELSE            reduce using rule 139 (expression -> RATIONAL .)
    RETURN          reduce using rule 139 (expression -> RATIONAL .)
    PRINT           reduce using rule 139 (expression -> RATIONAL .)
    PUTS            reduce using rule 139 (expression -> RATIONAL .)
    WHILE           reduce using rule 139 (expression -> RATIONAL .)
    FOR             reduce using rule 139 (expression -> RATIONAL .)
    LBRACE          reduce using rule 139 (expression -> RATIONAL .)
    DEF             reduce using rule 139 (expression -> RATIONAL .)
    IF              reduce using rule 139 (expression -> RATIONAL .)
    THEN            reduce using rule 139 (expression -> RATIONAL .)
    NOT             reduce using rule 139 (expression -> RATIONAL .)
    NIL             reduce using rule 139 (expression -> RATIONAL .)
    TRUE            reduce using rule 139 (expression -> RATIONAL .)
    FALSE           reduce using rule 139 (expression -> RATIONAL .)
    LPAREN          reduce using rule 139 (expression -> RATIONAL .)
    INTEGER         reduce using rule 139 (expression -> RATIONAL .)
    FLOAT           reduce using rule 139 (expression -> RATIONAL .)
    RATIONAL        reduce using rule 139 (expression -> RATIONAL .)
    COMPLEX         reduce using rule 139 (expression -> RATIONAL .)
    STR             reduce using rule 139 (expression -> RATIONAL .)
    SYMBOL          reduce using rule 139 (expression -> RATIONAL .)
    REGEXP          reduce using rule 139 (expression -> RATIONAL .)
    CLASS           reduce using rule 139 (expression -> RATIONAL .)
    INSTANCE_VAR    reduce using rule 139 (expression -> RATIONAL .)
    CLASS_VAR       reduce using rule 139 (expression -> RATIONAL .)
    GLOBAL_VAR      reduce using rule 139 (expression -> RATIONAL .)
    LOCAL_VAR       reduce using rule 139 (expression -> RATIONAL .)
    CONSTANT        reduce using rule 139 (expression -> RATIONAL .)
    LBRACKET        reduce using rule 139 (expression -> RATIONAL .)
    $end            reduce using rule 139 (expression -> RATIONAL .)
    RBRACE          reduce using rule 139 (expression -> RATIONAL .)
    END_S           reduce using rule 139 (expression -> RATIONAL .)
    LT              reduce using rule 139 (expression -> RATIONAL .)
    LE              reduce using rule 139 (expression -> RATIONAL .)
    GT              reduce using rule 139 (expression -> RATIONAL .)
    GE              reduce using rule 139 (expression -> RATIONAL .)
    EQ              reduce using rule 139 (expression -> RATIONAL .)
    NE              reduce using rule 139 (expression -> RATIONAL .)
    EQQ             reduce using rule 139 (expression -> RATIONAL .)
    MATCH           reduce using rule 139 (expression -> RATIONAL .)
    NMATCH          reduce using rule 139 (expression -> RATIONAL .)
    ARROW           reduce using rule 139 (expression -> RATIONAL .)
    RPAREN          reduce using rule 139 (expression -> RATIONAL .)
    COMMA           reduce using rule 139 (expression -> RATIONAL .)
    RBRACKET        reduce using rule 139 (expression -> RATIONAL .)
    ANDAND          reduce using rule 139 (expression -> RATIONAL .)
    OROR            reduce using rule 139 (expression -> RATIONAL .)
    AND             reduce using rule 139 (expression -> RATIONAL .)
    OR              reduce using rule 139 (expression -> RATIONAL .)
    DO              reduce using rule 139 (expression -> RATIONAL .)
    COLON           reduce using rule 139 (expression -> RATIONAL .)


state 46

    (140) expression -> COMPLEX .

    RANGE_INCL      reduce using rule 140 (expression -> COMPLEX .)
    RANGE_EXCL      reduce using rule 140 (expression -> COMPLEX .)
    PLUS            reduce using rule 140 (expression -> COMPLEX .)
    MINUS           reduce using rule 140 (expression -> COMPLEX .)
    MULT            reduce using rule 140 (expression -> COMPLEX .)
    DIV             reduce using rule 140 (expression -> COMPLEX .)
    MOD             reduce using rule 140 (expression -> COMPLEX .)
    POWER           reduce using rule 140 (expression -> COMPLEX .)
    BREAK           reduce using rule 140 (expression -> COMPLEX .)
    NEXT            reduce using rule 140 (expression -> COMPLEX .)
    ELSIF           reduce using rule 140 (expression -> COMPLEX .)
    ELSE            reduce using rule 140 (expression -> COMPLEX .)
    RETURN          reduce using rule 140 (expression -> COMPLEX .)
    PRINT           reduce using rule 140 (expression -> COMPLEX .)
    PUTS            reduce using rule 140 (expression -> COMPLEX .)
    WHILE           reduce using rule 140 (expression -> COMPLEX .)
    FOR             reduce using rule 140 (expression -> COMPLEX .)
    LBRACE          reduce using rule 140 (expression -> COMPLEX .)
    DEF             reduce using rule 140 (expression -> COMPLEX .)
    IF              reduce using rule 140 (expression -> COMPLEX .)
    THEN            reduce using rule 140 (expression -> COMPLEX .)
    NOT             reduce using rule 140 (expression -> COMPLEX .)
    NIL             reduce using rule 140 (expression -> COMPLEX .)
    TRUE            reduce using rule 140 (expression -> COMPLEX .)
    FALSE           reduce using rule 140 (expression -> COMPLEX .)
    LPAREN          reduce using rule 140 (expression -> COMPLEX .)
    INTEGER         reduce using rule 140 (expression -> COMPLEX .)
    FLOAT           reduce using rule 140 (expression -> COMPLEX .)
    RATIONAL        reduce using rule 140 (expression -> COMPLEX .)
    COMPLEX         reduce using rule 140 (expression -> COMPLEX .)
    STR             reduce using rule 140 (expression -> COMPLEX .)
    SYMBOL          reduce using rule 140 (expression -> COMPLEX .)
    REGEXP          reduce using rule 140 (expression -> COMPLEX .)
    CLASS           reduce using rule 140 (expression -> COMPLEX .)
    INSTANCE_VAR    reduce using rule 140 (expression -> COMPLEX .)
    CLASS_VAR       reduce using rule 140 (expression -> COMPLEX .)
    GLOBAL_VAR      reduce using rule 140 (expression -> COMPLEX .)
    LOCAL_VAR       reduce using rule 140 (expression -> COMPLEX .)
    CONSTANT        reduce using rule 140 (expression -> COMPLEX .)
    LBRACKET        reduce using rule 140 (expression -> COMPLEX .)
    $end            reduce using rule 140 (expression -> COMPLEX .)
    RBRACE          reduce using rule 140 (expression -> COMPLEX .)
    END_S           reduce using rule 140 (expression -> COMPLEX .)
    LT              reduce using rule 140 (expression -> COMPLEX .)
    LE              reduce using rule 140 (expression -> COMPLEX .)
    GT              reduce using rule 140 (expression -> COMPLEX .)
    GE              reduce using rule 140 (expression -> COMPLEX .)
    EQ              reduce using rule 140 (expression -> COMPLEX .)
    NE              reduce using rule 140 (expression -> COMPLEX .)
    EQQ             reduce using rule 140 (expression -> COMPLEX .)
    MATCH           reduce using rule 140 (expression -> COMPLEX .)
    NMATCH          reduce using rule 140 (expression -> COMPLEX .)
    ARROW           reduce using rule 140 (expression -> COMPLEX .)
    RPAREN          reduce using rule 140 (expression -> COMPLEX .)
    COMMA           reduce using rule 140 (expression -> COMPLEX .)
    RBRACKET        reduce using rule 140 (expression -> COMPLEX .)
    ANDAND          reduce using rule 140 (expression -> COMPLEX .)
    OROR            reduce using rule 140 (expression -> COMPLEX .)
    AND             reduce using rule 140 (expression -> COMPLEX .)
    OR              reduce using rule 140 (expression -> COMPLEX .)
    DO              reduce using rule 140 (expression -> COMPLEX .)
    COLON           reduce using rule 140 (expression -> COMPLEX .)


state 47

    (141) expression -> STR .
    (89) primary -> STR .

  ! reduce/reduce conflict for LBRACKET resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for PLUS resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for MINUS resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for MULT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for DIV resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for MOD resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for POWER resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for BREAK resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for NEXT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for ELSIF resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for ELSE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RETURN resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for PRINT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for PUTS resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for WHILE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for FOR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for LBRACE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for DEF resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for IF resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for THEN resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for NOT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for NIL resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for TRUE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for FALSE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for INTEGER resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for STR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for REGEXP resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for CLASS resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for $end resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RBRACE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for END_S resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for LT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for LE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for GT resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for GE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for EQ resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for NE resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for EQQ resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for MATCH resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for NMATCH resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for ARROW resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RPAREN resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for COMMA resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for ANDAND resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for OROR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for AND resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for OR resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for DO resolved using rule 89 (primary -> STR .)
  ! reduce/reduce conflict for COLON resolved using rule 89 (primary -> STR .)
    EQLS            reduce using rule 89 (primary -> STR .)
    LBRACKET        reduce using rule 89 (primary -> STR .)
    DOT             reduce using rule 89 (primary -> STR .)
    RANGE_INCL      reduce using rule 89 (primary -> STR .)
    RANGE_EXCL      reduce using rule 89 (primary -> STR .)
    PLUS            reduce using rule 89 (primary -> STR .)
    MINUS           reduce using rule 89 (primary -> STR .)
    MULT            reduce using rule 89 (primary -> STR .)
    DIV             reduce using rule 89 (primary -> STR .)
    MOD             reduce using rule 89 (primary -> STR .)
    POWER           reduce using rule 89 (primary -> STR .)
    BREAK           reduce using rule 89 (primary -> STR .)
    NEXT            reduce using rule 89 (primary -> STR .)
    ELSIF           reduce using rule 89 (primary -> STR .)
    ELSE            reduce using rule 89 (primary -> STR .)
    RETURN          reduce using rule 89 (primary -> STR .)
    PRINT           reduce using rule 89 (primary -> STR .)
    PUTS            reduce using rule 89 (primary -> STR .)
    WHILE           reduce using rule 89 (primary -> STR .)
    FOR             reduce using rule 89 (primary -> STR .)
    LBRACE          reduce using rule 89 (primary -> STR .)
    DEF             reduce using rule 89 (primary -> STR .)
    IF              reduce using rule 89 (primary -> STR .)
    THEN            reduce using rule 89 (primary -> STR .)
    NOT             reduce using rule 89 (primary -> STR .)
    NIL             reduce using rule 89 (primary -> STR .)
    TRUE            reduce using rule 89 (primary -> STR .)
    FALSE           reduce using rule 89 (primary -> STR .)
    LPAREN          reduce using rule 89 (primary -> STR .)
    INTEGER         reduce using rule 89 (primary -> STR .)
    FLOAT           reduce using rule 89 (primary -> STR .)
    RATIONAL        reduce using rule 89 (primary -> STR .)
    COMPLEX         reduce using rule 89 (primary -> STR .)
    STR             reduce using rule 89 (primary -> STR .)
    SYMBOL          reduce using rule 89 (primary -> STR .)
    REGEXP          reduce using rule 89 (primary -> STR .)
    CLASS           reduce using rule 89 (primary -> STR .)
    INSTANCE_VAR    reduce using rule 89 (primary -> STR .)
    CLASS_VAR       reduce using rule 89 (primary -> STR .)
    GLOBAL_VAR      reduce using rule 89 (primary -> STR .)
    LOCAL_VAR       reduce using rule 89 (primary -> STR .)
    CONSTANT        reduce using rule 89 (primary -> STR .)
    $end            reduce using rule 89 (primary -> STR .)
    RBRACE          reduce using rule 89 (primary -> STR .)
    END_S           reduce using rule 89 (primary -> STR .)
    LT              reduce using rule 89 (primary -> STR .)
    LE              reduce using rule 89 (primary -> STR .)
    GT              reduce using rule 89 (primary -> STR .)
    GE              reduce using rule 89 (primary -> STR .)
    EQ              reduce using rule 89 (primary -> STR .)
    NE              reduce using rule 89 (primary -> STR .)
    EQQ             reduce using rule 89 (primary -> STR .)
    MATCH           reduce using rule 89 (primary -> STR .)
    NMATCH          reduce using rule 89 (primary -> STR .)
    ARROW           reduce using rule 89 (primary -> STR .)
    RPAREN          reduce using rule 89 (primary -> STR .)
    COMMA           reduce using rule 89 (primary -> STR .)
    RBRACKET        reduce using rule 89 (primary -> STR .)
    ANDAND          reduce using rule 89 (primary -> STR .)
    OROR            reduce using rule 89 (primary -> STR .)
    AND             reduce using rule 89 (primary -> STR .)
    OR              reduce using rule 89 (primary -> STR .)
    DO              reduce using rule 89 (primary -> STR .)
    COLON           reduce using rule 89 (primary -> STR .)

  ! RANGE_INCL      [ reduce using rule 141 (expression -> STR .) ]
  ! RANGE_EXCL      [ reduce using rule 141 (expression -> STR .) ]
  ! PLUS            [ reduce using rule 141 (expression -> STR .) ]
  ! MINUS           [ reduce using rule 141 (expression -> STR .) ]
  ! MULT            [ reduce using rule 141 (expression -> STR .) ]
  ! DIV             [ reduce using rule 141 (expression -> STR .) ]
  ! MOD             [ reduce using rule 141 (expression -> STR .) ]
  ! POWER           [ reduce using rule 141 (expression -> STR .) ]
  ! BREAK           [ reduce using rule 141 (expression -> STR .) ]
  ! NEXT            [ reduce using rule 141 (expression -> STR .) ]
  ! ELSIF           [ reduce using rule 141 (expression -> STR .) ]
  ! ELSE            [ reduce using rule 141 (expression -> STR .) ]
  ! RETURN          [ reduce using rule 141 (expression -> STR .) ]
  ! PRINT           [ reduce using rule 141 (expression -> STR .) ]
  ! PUTS            [ reduce using rule 141 (expression -> STR .) ]
  ! WHILE           [ reduce using rule 141 (expression -> STR .) ]
  ! FOR             [ reduce using rule 141 (expression -> STR .) ]
  ! LBRACE          [ reduce using rule 141 (expression -> STR .) ]
  ! DEF             [ reduce using rule 141 (expression -> STR .) ]
  ! IF              [ reduce using rule 141 (expression -> STR .) ]
  ! THEN            [ reduce using rule 141 (expression -> STR .) ]
  ! NOT             [ reduce using rule 141 (expression -> STR .) ]
  ! NIL             [ reduce using rule 141 (expression -> STR .) ]
  ! TRUE            [ reduce using rule 141 (expression -> STR .) ]
  ! FALSE           [ reduce using rule 141 (expression -> STR .) ]
  ! LPAREN          [ reduce using rule 141 (expression -> STR .) ]
  ! INTEGER         [ reduce using rule 141 (expression -> STR .) ]
  ! FLOAT           [ reduce using rule 141 (expression -> STR .) ]
  ! RATIONAL        [ reduce using rule 141 (expression -> STR .) ]
  ! COMPLEX         [ reduce using rule 141 (expression -> STR .) ]
  ! STR             [ reduce using rule 141 (expression -> STR .) ]
  ! SYMBOL          [ reduce using rule 141 (expression -> STR .) ]
  ! REGEXP          [ reduce using rule 141 (expression -> STR .) ]
  ! CLASS           [ reduce using rule 141 (expression -> STR .) ]
  ! INSTANCE_VAR    [ reduce using rule 141 (expression -> STR .) ]
  ! CLASS_VAR       [ reduce using rule 141 (expression -> STR .) ]
  ! GLOBAL_VAR      [ reduce using rule 141 (expression -> STR .) ]
  ! LOCAL_VAR       [ reduce using rule 141 (expression -> STR .) ]
  ! CONSTANT        [ reduce using rule 141 (expression -> STR .) ]
  ! LBRACKET        [ reduce using rule 141 (expression -> STR .) ]
  ! $end            [ reduce using rule 141 (expression -> STR .) ]
  ! RBRACE          [ reduce using rule 141 (expression -> STR .) ]
  ! END_S           [ reduce using rule 141 (expression -> STR .) ]
  ! LT              [ reduce using rule 141 (expression -> STR .) ]
  ! LE              [ reduce using rule 141 (expression -> STR .) ]
  ! GT              [ reduce using rule 141 (expression -> STR .) ]
  ! GE              [ reduce using rule 141 (expression -> STR .) ]
  ! EQ              [ reduce using rule 141 (expression -> STR .) ]
  ! NE              [ reduce using rule 141 (expression -> STR .) ]
  ! EQQ             [ reduce using rule 141 (expression -> STR .) ]
  ! MATCH           [ reduce using rule 141 (expression -> STR .) ]
  ! NMATCH          [ reduce using rule 141 (expression -> STR .) ]
  ! ARROW           [ reduce using rule 141 (expression -> STR .) ]
  ! RPAREN          [ reduce using rule 141 (expression -> STR .) ]
  ! COMMA           [ reduce using rule 141 (expression -> STR .) ]
  ! RBRACKET        [ reduce using rule 141 (expression -> STR .) ]
  ! ANDAND          [ reduce using rule 141 (expression -> STR .) ]
  ! OROR            [ reduce using rule 141 (expression -> STR .) ]
  ! AND             [ reduce using rule 141 (expression -> STR .) ]
  ! OR              [ reduce using rule 141 (expression -> STR .) ]
  ! DO              [ reduce using rule 141 (expression -> STR .) ]
  ! COLON           [ reduce using rule 141 (expression -> STR .) ]


state 48

    (142) expression -> SYMBOL .
    (90) primary -> SYMBOL .

  ! reduce/reduce conflict for LBRACKET resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PLUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MINUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MULT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DIV resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MOD resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for POWER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for BREAK resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NEXT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSIF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RETURN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PRINT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PUTS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for WHILE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FOR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LBRACE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DEF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for IF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for THEN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NOT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NIL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for TRUE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FALSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LPAREN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INTEGER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for STR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for REGEXP resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for $end resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RBRACE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for END_S resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for GT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for GE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for EQ resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for EQQ resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MATCH resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NMATCH resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RPAREN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ARROW resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for COMMA resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ANDAND resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for OROR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for AND resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for OR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DO resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for COLON resolved using rule 90 (primary -> SYMBOL .)
    EQLS            reduce using rule 90 (primary -> SYMBOL .)
    LBRACKET        reduce using rule 90 (primary -> SYMBOL .)
    DOT             reduce using rule 90 (primary -> SYMBOL .)
    RANGE_INCL      reduce using rule 90 (primary -> SYMBOL .)
    RANGE_EXCL      reduce using rule 90 (primary -> SYMBOL .)
    PLUS            reduce using rule 90 (primary -> SYMBOL .)
    MINUS           reduce using rule 90 (primary -> SYMBOL .)
    MULT            reduce using rule 90 (primary -> SYMBOL .)
    DIV             reduce using rule 90 (primary -> SYMBOL .)
    MOD             reduce using rule 90 (primary -> SYMBOL .)
    POWER           reduce using rule 90 (primary -> SYMBOL .)
    BREAK           reduce using rule 90 (primary -> SYMBOL .)
    NEXT            reduce using rule 90 (primary -> SYMBOL .)
    ELSIF           reduce using rule 90 (primary -> SYMBOL .)
    ELSE            reduce using rule 90 (primary -> SYMBOL .)
    RETURN          reduce using rule 90 (primary -> SYMBOL .)
    PRINT           reduce using rule 90 (primary -> SYMBOL .)
    PUTS            reduce using rule 90 (primary -> SYMBOL .)
    WHILE           reduce using rule 90 (primary -> SYMBOL .)
    FOR             reduce using rule 90 (primary -> SYMBOL .)
    LBRACE          reduce using rule 90 (primary -> SYMBOL .)
    DEF             reduce using rule 90 (primary -> SYMBOL .)
    IF              reduce using rule 90 (primary -> SYMBOL .)
    THEN            reduce using rule 90 (primary -> SYMBOL .)
    NOT             reduce using rule 90 (primary -> SYMBOL .)
    NIL             reduce using rule 90 (primary -> SYMBOL .)
    TRUE            reduce using rule 90 (primary -> SYMBOL .)
    FALSE           reduce using rule 90 (primary -> SYMBOL .)
    LPAREN          reduce using rule 90 (primary -> SYMBOL .)
    INTEGER         reduce using rule 90 (primary -> SYMBOL .)
    FLOAT           reduce using rule 90 (primary -> SYMBOL .)
    RATIONAL        reduce using rule 90 (primary -> SYMBOL .)
    COMPLEX         reduce using rule 90 (primary -> SYMBOL .)
    STR             reduce using rule 90 (primary -> SYMBOL .)
    SYMBOL          reduce using rule 90 (primary -> SYMBOL .)
    REGEXP          reduce using rule 90 (primary -> SYMBOL .)
    CLASS           reduce using rule 90 (primary -> SYMBOL .)
    INSTANCE_VAR    reduce using rule 90 (primary -> SYMBOL .)
    CLASS_VAR       reduce using rule 90 (primary -> SYMBOL .)
    GLOBAL_VAR      reduce using rule 90 (primary -> SYMBOL .)
    LOCAL_VAR       reduce using rule 90 (primary -> SYMBOL .)
    CONSTANT        reduce using rule 90 (primary -> SYMBOL .)
    $end            reduce using rule 90 (primary -> SYMBOL .)
    RBRACE          reduce using rule 90 (primary -> SYMBOL .)
    END_S           reduce using rule 90 (primary -> SYMBOL .)
    LT              reduce using rule 90 (primary -> SYMBOL .)
    LE              reduce using rule 90 (primary -> SYMBOL .)
    GT              reduce using rule 90 (primary -> SYMBOL .)
    GE              reduce using rule 90 (primary -> SYMBOL .)
    EQ              reduce using rule 90 (primary -> SYMBOL .)
    NE              reduce using rule 90 (primary -> SYMBOL .)
    EQQ             reduce using rule 90 (primary -> SYMBOL .)
    MATCH           reduce using rule 90 (primary -> SYMBOL .)
    NMATCH          reduce using rule 90 (primary -> SYMBOL .)
    RPAREN          reduce using rule 90 (primary -> SYMBOL .)
    ARROW           reduce using rule 90 (primary -> SYMBOL .)
    COMMA           reduce using rule 90 (primary -> SYMBOL .)
    RBRACKET        reduce using rule 90 (primary -> SYMBOL .)
    ANDAND          reduce using rule 90 (primary -> SYMBOL .)
    OROR            reduce using rule 90 (primary -> SYMBOL .)
    AND             reduce using rule 90 (primary -> SYMBOL .)
    OR              reduce using rule 90 (primary -> SYMBOL .)
    DO              reduce using rule 90 (primary -> SYMBOL .)
    COLON           reduce using rule 90 (primary -> SYMBOL .)

  ! RANGE_INCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RANGE_EXCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PLUS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MINUS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MULT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DIV             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MOD             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! POWER           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! BREAK           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NEXT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSIF           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RETURN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PRINT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PUTS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! WHILE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FOR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DEF             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! IF              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! THEN            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NOT             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NIL             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! TRUE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FALSE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LPAREN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INTEGER         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FLOAT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RATIONAL        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! COMPLEX         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! STR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! SYMBOL          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! REGEXP          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INSTANCE_VAR    [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! GLOBAL_VAR      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LOCAL_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CONSTANT        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACKET        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! $end            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! END_S           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LT              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LE              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! GT              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! GE              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! EQ              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NE              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! EQQ             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MATCH           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NMATCH          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RPAREN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ARROW           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! COMMA           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RBRACKET        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ANDAND          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! OROR            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! AND             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! OR              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DO              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! COLON           [ reduce using rule 142 (expression -> SYMBOL .) ]


state 49

    (143) expression -> REGEXP .

    RANGE_INCL      reduce using rule 143 (expression -> REGEXP .)
    RANGE_EXCL      reduce using rule 143 (expression -> REGEXP .)
    PLUS            reduce using rule 143 (expression -> REGEXP .)
    MINUS           reduce using rule 143 (expression -> REGEXP .)
    MULT            reduce using rule 143 (expression -> REGEXP .)
    DIV             reduce using rule 143 (expression -> REGEXP .)
    MOD             reduce using rule 143 (expression -> REGEXP .)
    POWER           reduce using rule 143 (expression -> REGEXP .)
    BREAK           reduce using rule 143 (expression -> REGEXP .)
    NEXT            reduce using rule 143 (expression -> REGEXP .)
    ELSIF           reduce using rule 143 (expression -> REGEXP .)
    ELSE            reduce using rule 143 (expression -> REGEXP .)
    RETURN          reduce using rule 143 (expression -> REGEXP .)
    PRINT           reduce using rule 143 (expression -> REGEXP .)
    PUTS            reduce using rule 143 (expression -> REGEXP .)
    WHILE           reduce using rule 143 (expression -> REGEXP .)
    FOR             reduce using rule 143 (expression -> REGEXP .)
    LBRACE          reduce using rule 143 (expression -> REGEXP .)
    DEF             reduce using rule 143 (expression -> REGEXP .)
    IF              reduce using rule 143 (expression -> REGEXP .)
    THEN            reduce using rule 143 (expression -> REGEXP .)
    NOT             reduce using rule 143 (expression -> REGEXP .)
    NIL             reduce using rule 143 (expression -> REGEXP .)
    TRUE            reduce using rule 143 (expression -> REGEXP .)
    FALSE           reduce using rule 143 (expression -> REGEXP .)
    LPAREN          reduce using rule 143 (expression -> REGEXP .)
    INTEGER         reduce using rule 143 (expression -> REGEXP .)
    FLOAT           reduce using rule 143 (expression -> REGEXP .)
    RATIONAL        reduce using rule 143 (expression -> REGEXP .)
    COMPLEX         reduce using rule 143 (expression -> REGEXP .)
    STR             reduce using rule 143 (expression -> REGEXP .)
    SYMBOL          reduce using rule 143 (expression -> REGEXP .)
    REGEXP          reduce using rule 143 (expression -> REGEXP .)
    CLASS           reduce using rule 143 (expression -> REGEXP .)
    INSTANCE_VAR    reduce using rule 143 (expression -> REGEXP .)
    CLASS_VAR       reduce using rule 143 (expression -> REGEXP .)
    GLOBAL_VAR      reduce using rule 143 (expression -> REGEXP .)
    LOCAL_VAR       reduce using rule 143 (expression -> REGEXP .)
    CONSTANT        reduce using rule 143 (expression -> REGEXP .)
    LBRACKET        reduce using rule 143 (expression -> REGEXP .)
    $end            reduce using rule 143 (expression -> REGEXP .)
    RBRACE          reduce using rule 143 (expression -> REGEXP .)
    END_S           reduce using rule 143 (expression -> REGEXP .)
    LT              reduce using rule 143 (expression -> REGEXP .)
    LE              reduce using rule 143 (expression -> REGEXP .)
    GT              reduce using rule 143 (expression -> REGEXP .)
    GE              reduce using rule 143 (expression -> REGEXP .)
    EQ              reduce using rule 143 (expression -> REGEXP .)
    NE              reduce using rule 143 (expression -> REGEXP .)
    EQQ             reduce using rule 143 (expression -> REGEXP .)
    MATCH           reduce using rule 143 (expression -> REGEXP .)
    NMATCH          reduce using rule 143 (expression -> REGEXP .)
    ARROW           reduce using rule 143 (expression -> REGEXP .)
    RPAREN          reduce using rule 143 (expression -> REGEXP .)
    COMMA           reduce using rule 143 (expression -> REGEXP .)
    RBRACKET        reduce using rule 143 (expression -> REGEXP .)
    ANDAND          reduce using rule 143 (expression -> REGEXP .)
    OROR            reduce using rule 143 (expression -> REGEXP .)
    AND             reduce using rule 143 (expression -> REGEXP .)
    OR              reduce using rule 143 (expression -> REGEXP .)
    DO              reduce using rule 143 (expression -> REGEXP .)
    COLON           reduce using rule 143 (expression -> REGEXP .)


state 50

    (120) class_def -> CLASS . CONSTANT stmt_block END_S
    (121) class_def -> CLASS . CONSTANT opt_inherit stmt_block END_S

    CONSTANT        shift and go to state 111


state 51

    (30) variable -> CONSTANT .

    EQLS            reduce using rule 30 (variable -> CONSTANT .)
    PLUSEQLS        reduce using rule 30 (variable -> CONSTANT .)
    MINUSEQLS       reduce using rule 30 (variable -> CONSTANT .)
    MULTEQLS        reduce using rule 30 (variable -> CONSTANT .)
    DIVEQLS         reduce using rule 30 (variable -> CONSTANT .)
    MODEQLS         reduce using rule 30 (variable -> CONSTANT .)
    POWEREQLS       reduce using rule 30 (variable -> CONSTANT .)
    RANGE_INCL      reduce using rule 30 (variable -> CONSTANT .)
    RANGE_EXCL      reduce using rule 30 (variable -> CONSTANT .)
    PLUS            reduce using rule 30 (variable -> CONSTANT .)
    MINUS           reduce using rule 30 (variable -> CONSTANT .)
    MULT            reduce using rule 30 (variable -> CONSTANT .)
    DIV             reduce using rule 30 (variable -> CONSTANT .)
    MOD             reduce using rule 30 (variable -> CONSTANT .)
    POWER           reduce using rule 30 (variable -> CONSTANT .)
    BREAK           reduce using rule 30 (variable -> CONSTANT .)
    NEXT            reduce using rule 30 (variable -> CONSTANT .)
    ELSIF           reduce using rule 30 (variable -> CONSTANT .)
    ELSE            reduce using rule 30 (variable -> CONSTANT .)
    RETURN          reduce using rule 30 (variable -> CONSTANT .)
    PRINT           reduce using rule 30 (variable -> CONSTANT .)
    PUTS            reduce using rule 30 (variable -> CONSTANT .)
    WHILE           reduce using rule 30 (variable -> CONSTANT .)
    FOR             reduce using rule 30 (variable -> CONSTANT .)
    LBRACE          reduce using rule 30 (variable -> CONSTANT .)
    DEF             reduce using rule 30 (variable -> CONSTANT .)
    IF              reduce using rule 30 (variable -> CONSTANT .)
    THEN            reduce using rule 30 (variable -> CONSTANT .)
    NOT             reduce using rule 30 (variable -> CONSTANT .)
    NIL             reduce using rule 30 (variable -> CONSTANT .)
    TRUE            reduce using rule 30 (variable -> CONSTANT .)
    FALSE           reduce using rule 30 (variable -> CONSTANT .)
    LPAREN          reduce using rule 30 (variable -> CONSTANT .)
    INTEGER         reduce using rule 30 (variable -> CONSTANT .)
    FLOAT           reduce using rule 30 (variable -> CONSTANT .)
    RATIONAL        reduce using rule 30 (variable -> CONSTANT .)
    COMPLEX         reduce using rule 30 (variable -> CONSTANT .)
    STR             reduce using rule 30 (variable -> CONSTANT .)
    SYMBOL          reduce using rule 30 (variable -> CONSTANT .)
    REGEXP          reduce using rule 30 (variable -> CONSTANT .)
    CLASS           reduce using rule 30 (variable -> CONSTANT .)
    INSTANCE_VAR    reduce using rule 30 (variable -> CONSTANT .)
    CLASS_VAR       reduce using rule 30 (variable -> CONSTANT .)
    GLOBAL_VAR      reduce using rule 30 (variable -> CONSTANT .)
    LOCAL_VAR       reduce using rule 30 (variable -> CONSTANT .)
    CONSTANT        reduce using rule 30 (variable -> CONSTANT .)
    LBRACKET        reduce using rule 30 (variable -> CONSTANT .)
    $end            reduce using rule 30 (variable -> CONSTANT .)
    DOT             reduce using rule 30 (variable -> CONSTANT .)
    RBRACE          reduce using rule 30 (variable -> CONSTANT .)
    END_S           reduce using rule 30 (variable -> CONSTANT .)
    LT              reduce using rule 30 (variable -> CONSTANT .)
    LE              reduce using rule 30 (variable -> CONSTANT .)
    GT              reduce using rule 30 (variable -> CONSTANT .)
    GE              reduce using rule 30 (variable -> CONSTANT .)
    EQ              reduce using rule 30 (variable -> CONSTANT .)
    NE              reduce using rule 30 (variable -> CONSTANT .)
    EQQ             reduce using rule 30 (variable -> CONSTANT .)
    MATCH           reduce using rule 30 (variable -> CONSTANT .)
    NMATCH          reduce using rule 30 (variable -> CONSTANT .)
    ARROW           reduce using rule 30 (variable -> CONSTANT .)
    RPAREN          reduce using rule 30 (variable -> CONSTANT .)
    COMMA           reduce using rule 30 (variable -> CONSTANT .)
    RBRACKET        reduce using rule 30 (variable -> CONSTANT .)
    ANDAND          reduce using rule 30 (variable -> CONSTANT .)
    OROR            reduce using rule 30 (variable -> CONSTANT .)
    AND             reduce using rule 30 (variable -> CONSTANT .)
    OR              reduce using rule 30 (variable -> CONSTANT .)
    DO              reduce using rule 30 (variable -> CONSTANT .)
    COLON           reduce using rule 30 (variable -> CONSTANT .)


state 52

    (125) property_decl -> INSTANCE_VAR .
    (28) variable -> INSTANCE_VAR .

  ! reduce/reduce conflict for MINUS resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for BREAK resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for NEXT resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for ELSIF resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for ELSE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for PRINT resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for PUTS resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for WHILE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for FOR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for LBRACE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for DEF resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for IF resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for THEN resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for NOT resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for NIL resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for TRUE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for FALSE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for INTEGER resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for STR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for REGEXP resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for CLASS resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for $end resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for RBRACE resolved using rule 28 (variable -> INSTANCE_VAR .)
  ! reduce/reduce conflict for END_S resolved using rule 28 (variable -> INSTANCE_VAR .)
    EQLS            reduce using rule 28 (variable -> INSTANCE_VAR .)
    PLUSEQLS        reduce using rule 28 (variable -> INSTANCE_VAR .)
    MINUSEQLS       reduce using rule 28 (variable -> INSTANCE_VAR .)
    MULTEQLS        reduce using rule 28 (variable -> INSTANCE_VAR .)
    DIVEQLS         reduce using rule 28 (variable -> INSTANCE_VAR .)
    MODEQLS         reduce using rule 28 (variable -> INSTANCE_VAR .)
    POWEREQLS       reduce using rule 28 (variable -> INSTANCE_VAR .)
    RANGE_INCL      reduce using rule 28 (variable -> INSTANCE_VAR .)
    RANGE_EXCL      reduce using rule 28 (variable -> INSTANCE_VAR .)
    PLUS            reduce using rule 28 (variable -> INSTANCE_VAR .)
    MINUS           reduce using rule 28 (variable -> INSTANCE_VAR .)
    MULT            reduce using rule 28 (variable -> INSTANCE_VAR .)
    DIV             reduce using rule 28 (variable -> INSTANCE_VAR .)
    MOD             reduce using rule 28 (variable -> INSTANCE_VAR .)
    POWER           reduce using rule 28 (variable -> INSTANCE_VAR .)
    BREAK           reduce using rule 28 (variable -> INSTANCE_VAR .)
    NEXT            reduce using rule 28 (variable -> INSTANCE_VAR .)
    ELSIF           reduce using rule 28 (variable -> INSTANCE_VAR .)
    ELSE            reduce using rule 28 (variable -> INSTANCE_VAR .)
    RETURN          reduce using rule 28 (variable -> INSTANCE_VAR .)
    PRINT           reduce using rule 28 (variable -> INSTANCE_VAR .)
    PUTS            reduce using rule 28 (variable -> INSTANCE_VAR .)
    WHILE           reduce using rule 28 (variable -> INSTANCE_VAR .)
    FOR             reduce using rule 28 (variable -> INSTANCE_VAR .)
    LBRACE          reduce using rule 28 (variable -> INSTANCE_VAR .)
    DEF             reduce using rule 28 (variable -> INSTANCE_VAR .)
    IF              reduce using rule 28 (variable -> INSTANCE_VAR .)
    THEN            reduce using rule 28 (variable -> INSTANCE_VAR .)
    NOT             reduce using rule 28 (variable -> INSTANCE_VAR .)
    NIL             reduce using rule 28 (variable -> INSTANCE_VAR .)
    TRUE            reduce using rule 28 (variable -> INSTANCE_VAR .)
    FALSE           reduce using rule 28 (variable -> INSTANCE_VAR .)
    LPAREN          reduce using rule 28 (variable -> INSTANCE_VAR .)
    INTEGER         reduce using rule 28 (variable -> INSTANCE_VAR .)
    FLOAT           reduce using rule 28 (variable -> INSTANCE_VAR .)
    RATIONAL        reduce using rule 28 (variable -> INSTANCE_VAR .)
    COMPLEX         reduce using rule 28 (variable -> INSTANCE_VAR .)
    STR             reduce using rule 28 (variable -> INSTANCE_VAR .)
    SYMBOL          reduce using rule 28 (variable -> INSTANCE_VAR .)
    REGEXP          reduce using rule 28 (variable -> INSTANCE_VAR .)
    CLASS           reduce using rule 28 (variable -> INSTANCE_VAR .)
    INSTANCE_VAR    reduce using rule 28 (variable -> INSTANCE_VAR .)
    CLASS_VAR       reduce using rule 28 (variable -> INSTANCE_VAR .)
    GLOBAL_VAR      reduce using rule 28 (variable -> INSTANCE_VAR .)
    LOCAL_VAR       reduce using rule 28 (variable -> INSTANCE_VAR .)
    CONSTANT        reduce using rule 28 (variable -> INSTANCE_VAR .)
    LBRACKET        reduce using rule 28 (variable -> INSTANCE_VAR .)
    $end            reduce using rule 28 (variable -> INSTANCE_VAR .)
    DOT             reduce using rule 28 (variable -> INSTANCE_VAR .)
    RBRACE          reduce using rule 28 (variable -> INSTANCE_VAR .)
    END_S           reduce using rule 28 (variable -> INSTANCE_VAR .)
    ARROW           reduce using rule 28 (variable -> INSTANCE_VAR .)

  ! BREAK           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! NEXT            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! ELSIF           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! ELSE            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! RETURN          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! PRINT           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! PUTS            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! WHILE           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! FOR             [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! LBRACE          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! DEF             [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! IF              [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! THEN            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! NOT             [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! NIL             [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! TRUE            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! FALSE           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! LPAREN          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! INTEGER         [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! FLOAT           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! RATIONAL        [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! COMPLEX         [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! STR             [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! SYMBOL          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! REGEXP          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! MINUS           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! CLASS           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! INSTANCE_VAR    [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! CLASS_VAR       [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! GLOBAL_VAR      [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! LOCAL_VAR       [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! CONSTANT        [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! LBRACKET        [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! $end            [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! RBRACE          [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]
  ! END_S           [ reduce using rule 125 (property_decl -> INSTANCE_VAR .) ]


state 53

    (126) property_decl -> CLASS_VAR .
    (29) variable -> CLASS_VAR .

  ! reduce/reduce conflict for MINUS resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for BREAK resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for NEXT resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for ELSIF resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for ELSE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for RETURN resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for PRINT resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for PUTS resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for WHILE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for FOR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for LBRACE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for DEF resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for IF resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for THEN resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for NOT resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for NIL resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for TRUE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for FALSE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for INTEGER resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for STR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for REGEXP resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for CLASS resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for $end resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for RBRACE resolved using rule 29 (variable -> CLASS_VAR .)
  ! reduce/reduce conflict for END_S resolved using rule 29 (variable -> CLASS_VAR .)
    EQLS            reduce using rule 29 (variable -> CLASS_VAR .)
    PLUSEQLS        reduce using rule 29 (variable -> CLASS_VAR .)
    MINUSEQLS       reduce using rule 29 (variable -> CLASS_VAR .)
    MULTEQLS        reduce using rule 29 (variable -> CLASS_VAR .)
    DIVEQLS         reduce using rule 29 (variable -> CLASS_VAR .)
    MODEQLS         reduce using rule 29 (variable -> CLASS_VAR .)
    POWEREQLS       reduce using rule 29 (variable -> CLASS_VAR .)
    RANGE_INCL      reduce using rule 29 (variable -> CLASS_VAR .)
    RANGE_EXCL      reduce using rule 29 (variable -> CLASS_VAR .)
    PLUS            reduce using rule 29 (variable -> CLASS_VAR .)
    MINUS           reduce using rule 29 (variable -> CLASS_VAR .)
    MULT            reduce using rule 29 (variable -> CLASS_VAR .)
    DIV             reduce using rule 29 (variable -> CLASS_VAR .)
    MOD             reduce using rule 29 (variable -> CLASS_VAR .)
    POWER           reduce using rule 29 (variable -> CLASS_VAR .)
    BREAK           reduce using rule 29 (variable -> CLASS_VAR .)
    NEXT            reduce using rule 29 (variable -> CLASS_VAR .)
    ELSIF           reduce using rule 29 (variable -> CLASS_VAR .)
    ELSE            reduce using rule 29 (variable -> CLASS_VAR .)
    RETURN          reduce using rule 29 (variable -> CLASS_VAR .)
    PRINT           reduce using rule 29 (variable -> CLASS_VAR .)
    PUTS            reduce using rule 29 (variable -> CLASS_VAR .)
    WHILE           reduce using rule 29 (variable -> CLASS_VAR .)
    FOR             reduce using rule 29 (variable -> CLASS_VAR .)
    LBRACE          reduce using rule 29 (variable -> CLASS_VAR .)
    DEF             reduce using rule 29 (variable -> CLASS_VAR .)
    IF              reduce using rule 29 (variable -> CLASS_VAR .)
    THEN            reduce using rule 29 (variable -> CLASS_VAR .)
    NOT             reduce using rule 29 (variable -> CLASS_VAR .)
    NIL             reduce using rule 29 (variable -> CLASS_VAR .)
    TRUE            reduce using rule 29 (variable -> CLASS_VAR .)
    FALSE           reduce using rule 29 (variable -> CLASS_VAR .)
    LPAREN          reduce using rule 29 (variable -> CLASS_VAR .)
    INTEGER         reduce using rule 29 (variable -> CLASS_VAR .)
    FLOAT           reduce using rule 29 (variable -> CLASS_VAR .)
    RATIONAL        reduce using rule 29 (variable -> CLASS_VAR .)
    COMPLEX         reduce using rule 29 (variable -> CLASS_VAR .)
    STR             reduce using rule 29 (variable -> CLASS_VAR .)
    SYMBOL          reduce using rule 29 (variable -> CLASS_VAR .)
    REGEXP          reduce using rule 29 (variable -> CLASS_VAR .)
    CLASS           reduce using rule 29 (variable -> CLASS_VAR .)
    INSTANCE_VAR    reduce using rule 29 (variable -> CLASS_VAR .)
    CLASS_VAR       reduce using rule 29 (variable -> CLASS_VAR .)
    GLOBAL_VAR      reduce using rule 29 (variable -> CLASS_VAR .)
    LOCAL_VAR       reduce using rule 29 (variable -> CLASS_VAR .)
    CONSTANT        reduce using rule 29 (variable -> CLASS_VAR .)
    LBRACKET        reduce using rule 29 (variable -> CLASS_VAR .)
    $end            reduce using rule 29 (variable -> CLASS_VAR .)
    DOT             reduce using rule 29 (variable -> CLASS_VAR .)
    RBRACE          reduce using rule 29 (variable -> CLASS_VAR .)
    END_S           reduce using rule 29 (variable -> CLASS_VAR .)
    ARROW           reduce using rule 29 (variable -> CLASS_VAR .)

  ! BREAK           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! NEXT            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! ELSIF           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! ELSE            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! RETURN          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! PRINT           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! PUTS            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! WHILE           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! FOR             [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! LBRACE          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! DEF             [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! IF              [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! THEN            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! NOT             [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! NIL             [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! TRUE            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! FALSE           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! LPAREN          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! INTEGER         [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! FLOAT           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! RATIONAL        [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! COMPLEX         [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! STR             [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! SYMBOL          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! REGEXP          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! MINUS           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! CLASS           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! INSTANCE_VAR    [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! CLASS_VAR       [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! GLOBAL_VAR      [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! LOCAL_VAR       [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! CONSTANT        [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! LBRACKET        [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! $end            [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! RBRACE          [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]
  ! END_S           [ reduce using rule 126 (property_decl -> CLASS_VAR .) ]


state 54

    (26) variable -> GLOBAL_VAR .

    EQLS            reduce using rule 26 (variable -> GLOBAL_VAR .)
    PLUSEQLS        reduce using rule 26 (variable -> GLOBAL_VAR .)
    MINUSEQLS       reduce using rule 26 (variable -> GLOBAL_VAR .)
    MULTEQLS        reduce using rule 26 (variable -> GLOBAL_VAR .)
    DIVEQLS         reduce using rule 26 (variable -> GLOBAL_VAR .)
    MODEQLS         reduce using rule 26 (variable -> GLOBAL_VAR .)
    POWEREQLS       reduce using rule 26 (variable -> GLOBAL_VAR .)
    RANGE_INCL      reduce using rule 26 (variable -> GLOBAL_VAR .)
    RANGE_EXCL      reduce using rule 26 (variable -> GLOBAL_VAR .)
    PLUS            reduce using rule 26 (variable -> GLOBAL_VAR .)
    MINUS           reduce using rule 26 (variable -> GLOBAL_VAR .)
    MULT            reduce using rule 26 (variable -> GLOBAL_VAR .)
    DIV             reduce using rule 26 (variable -> GLOBAL_VAR .)
    MOD             reduce using rule 26 (variable -> GLOBAL_VAR .)
    POWER           reduce using rule 26 (variable -> GLOBAL_VAR .)
    BREAK           reduce using rule 26 (variable -> GLOBAL_VAR .)
    NEXT            reduce using rule 26 (variable -> GLOBAL_VAR .)
    ELSIF           reduce using rule 26 (variable -> GLOBAL_VAR .)
    ELSE            reduce using rule 26 (variable -> GLOBAL_VAR .)
    RETURN          reduce using rule 26 (variable -> GLOBAL_VAR .)
    PRINT           reduce using rule 26 (variable -> GLOBAL_VAR .)
    PUTS            reduce using rule 26 (variable -> GLOBAL_VAR .)
    WHILE           reduce using rule 26 (variable -> GLOBAL_VAR .)
    FOR             reduce using rule 26 (variable -> GLOBAL_VAR .)
    LBRACE          reduce using rule 26 (variable -> GLOBAL_VAR .)
    DEF             reduce using rule 26 (variable -> GLOBAL_VAR .)
    IF              reduce using rule 26 (variable -> GLOBAL_VAR .)
    THEN            reduce using rule 26 (variable -> GLOBAL_VAR .)
    NOT             reduce using rule 26 (variable -> GLOBAL_VAR .)
    NIL             reduce using rule 26 (variable -> GLOBAL_VAR .)
    TRUE            reduce using rule 26 (variable -> GLOBAL_VAR .)
    FALSE           reduce using rule 26 (variable -> GLOBAL_VAR .)
    LPAREN          reduce using rule 26 (variable -> GLOBAL_VAR .)
    INTEGER         reduce using rule 26 (variable -> GLOBAL_VAR .)
    FLOAT           reduce using rule 26 (variable -> GLOBAL_VAR .)
    RATIONAL        reduce using rule 26 (variable -> GLOBAL_VAR .)
    COMPLEX         reduce using rule 26 (variable -> GLOBAL_VAR .)
    STR             reduce using rule 26 (variable -> GLOBAL_VAR .)
    SYMBOL          reduce using rule 26 (variable -> GLOBAL_VAR .)
    REGEXP          reduce using rule 26 (variable -> GLOBAL_VAR .)
    CLASS           reduce using rule 26 (variable -> GLOBAL_VAR .)
    INSTANCE_VAR    reduce using rule 26 (variable -> GLOBAL_VAR .)
    CLASS_VAR       reduce using rule 26 (variable -> GLOBAL_VAR .)
    GLOBAL_VAR      reduce using rule 26 (variable -> GLOBAL_VAR .)
    LOCAL_VAR       reduce using rule 26 (variable -> GLOBAL_VAR .)
    CONSTANT        reduce using rule 26 (variable -> GLOBAL_VAR .)
    LBRACKET        reduce using rule 26 (variable -> GLOBAL_VAR .)
    $end            reduce using rule 26 (variable -> GLOBAL_VAR .)
    DOT             reduce using rule 26 (variable -> GLOBAL_VAR .)
    RBRACE          reduce using rule 26 (variable -> GLOBAL_VAR .)
    END_S           reduce using rule 26 (variable -> GLOBAL_VAR .)
    LT              reduce using rule 26 (variable -> GLOBAL_VAR .)
    LE              reduce using rule 26 (variable -> GLOBAL_VAR .)
    GT              reduce using rule 26 (variable -> GLOBAL_VAR .)
    GE              reduce using rule 26 (variable -> GLOBAL_VAR .)
    EQ              reduce using rule 26 (variable -> GLOBAL_VAR .)
    NE              reduce using rule 26 (variable -> GLOBAL_VAR .)
    EQQ             reduce using rule 26 (variable -> GLOBAL_VAR .)
    MATCH           reduce using rule 26 (variable -> GLOBAL_VAR .)
    NMATCH          reduce using rule 26 (variable -> GLOBAL_VAR .)
    ARROW           reduce using rule 26 (variable -> GLOBAL_VAR .)
    RPAREN          reduce using rule 26 (variable -> GLOBAL_VAR .)
    COMMA           reduce using rule 26 (variable -> GLOBAL_VAR .)
    RBRACKET        reduce using rule 26 (variable -> GLOBAL_VAR .)
    ANDAND          reduce using rule 26 (variable -> GLOBAL_VAR .)
    OROR            reduce using rule 26 (variable -> GLOBAL_VAR .)
    AND             reduce using rule 26 (variable -> GLOBAL_VAR .)
    OR              reduce using rule 26 (variable -> GLOBAL_VAR .)
    DO              reduce using rule 26 (variable -> GLOBAL_VAR .)
    COLON           reduce using rule 26 (variable -> GLOBAL_VAR .)


state 55

    (85) array_literal -> LBRACKET . RBRACKET
    (86) array_literal -> LBRACKET . expr_list RBRACKET
    (83) expr_list -> . expression
    (84) expr_list -> . expression COMMA expr_list
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    RBRACKET        shift and go to state 112
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expr_list                      shift and go to state 113
    expression                     shift and go to state 114
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 56

    (100) expr_postfix -> primary .

    EQLS            reduce using rule 100 (expr_postfix -> primary .)
    LBRACKET        reduce using rule 100 (expr_postfix -> primary .)
    DOT             reduce using rule 100 (expr_postfix -> primary .)
    RANGE_INCL      reduce using rule 100 (expr_postfix -> primary .)
    RANGE_EXCL      reduce using rule 100 (expr_postfix -> primary .)
    PLUS            reduce using rule 100 (expr_postfix -> primary .)
    MINUS           reduce using rule 100 (expr_postfix -> primary .)
    MULT            reduce using rule 100 (expr_postfix -> primary .)
    DIV             reduce using rule 100 (expr_postfix -> primary .)
    MOD             reduce using rule 100 (expr_postfix -> primary .)
    POWER           reduce using rule 100 (expr_postfix -> primary .)
    BREAK           reduce using rule 100 (expr_postfix -> primary .)
    NEXT            reduce using rule 100 (expr_postfix -> primary .)
    ELSIF           reduce using rule 100 (expr_postfix -> primary .)
    ELSE            reduce using rule 100 (expr_postfix -> primary .)
    RETURN          reduce using rule 100 (expr_postfix -> primary .)
    PRINT           reduce using rule 100 (expr_postfix -> primary .)
    PUTS            reduce using rule 100 (expr_postfix -> primary .)
    WHILE           reduce using rule 100 (expr_postfix -> primary .)
    FOR             reduce using rule 100 (expr_postfix -> primary .)
    LBRACE          reduce using rule 100 (expr_postfix -> primary .)
    DEF             reduce using rule 100 (expr_postfix -> primary .)
    IF              reduce using rule 100 (expr_postfix -> primary .)
    THEN            reduce using rule 100 (expr_postfix -> primary .)
    NOT             reduce using rule 100 (expr_postfix -> primary .)
    NIL             reduce using rule 100 (expr_postfix -> primary .)
    TRUE            reduce using rule 100 (expr_postfix -> primary .)
    FALSE           reduce using rule 100 (expr_postfix -> primary .)
    LPAREN          reduce using rule 100 (expr_postfix -> primary .)
    INTEGER         reduce using rule 100 (expr_postfix -> primary .)
    FLOAT           reduce using rule 100 (expr_postfix -> primary .)
    RATIONAL        reduce using rule 100 (expr_postfix -> primary .)
    COMPLEX         reduce using rule 100 (expr_postfix -> primary .)
    STR             reduce using rule 100 (expr_postfix -> primary .)
    SYMBOL          reduce using rule 100 (expr_postfix -> primary .)
    REGEXP          reduce using rule 100 (expr_postfix -> primary .)
    CLASS           reduce using rule 100 (expr_postfix -> primary .)
    INSTANCE_VAR    reduce using rule 100 (expr_postfix -> primary .)
    CLASS_VAR       reduce using rule 100 (expr_postfix -> primary .)
    GLOBAL_VAR      reduce using rule 100 (expr_postfix -> primary .)
    LOCAL_VAR       reduce using rule 100 (expr_postfix -> primary .)
    CONSTANT        reduce using rule 100 (expr_postfix -> primary .)
    $end            reduce using rule 100 (expr_postfix -> primary .)
    RBRACE          reduce using rule 100 (expr_postfix -> primary .)
    END_S           reduce using rule 100 (expr_postfix -> primary .)
    LT              reduce using rule 100 (expr_postfix -> primary .)
    LE              reduce using rule 100 (expr_postfix -> primary .)
    GT              reduce using rule 100 (expr_postfix -> primary .)
    GE              reduce using rule 100 (expr_postfix -> primary .)
    EQ              reduce using rule 100 (expr_postfix -> primary .)
    NE              reduce using rule 100 (expr_postfix -> primary .)
    EQQ             reduce using rule 100 (expr_postfix -> primary .)
    MATCH           reduce using rule 100 (expr_postfix -> primary .)
    NMATCH          reduce using rule 100 (expr_postfix -> primary .)
    ARROW           reduce using rule 100 (expr_postfix -> primary .)
    RPAREN          reduce using rule 100 (expr_postfix -> primary .)
    COMMA           reduce using rule 100 (expr_postfix -> primary .)
    RBRACKET        reduce using rule 100 (expr_postfix -> primary .)
    ANDAND          reduce using rule 100 (expr_postfix -> primary .)
    OROR            reduce using rule 100 (expr_postfix -> primary .)
    AND             reduce using rule 100 (expr_postfix -> primary .)
    OR              reduce using rule 100 (expr_postfix -> primary .)
    DO              reduce using rule 100 (expr_postfix -> primary .)
    COLON           reduce using rule 100 (expr_postfix -> primary .)


state 57

    (96) primary -> array_literal .

    EQLS            reduce using rule 96 (primary -> array_literal .)
    LBRACKET        reduce using rule 96 (primary -> array_literal .)
    DOT             reduce using rule 96 (primary -> array_literal .)
    RANGE_INCL      reduce using rule 96 (primary -> array_literal .)
    RANGE_EXCL      reduce using rule 96 (primary -> array_literal .)
    PLUS            reduce using rule 96 (primary -> array_literal .)
    MINUS           reduce using rule 96 (primary -> array_literal .)
    MULT            reduce using rule 96 (primary -> array_literal .)
    DIV             reduce using rule 96 (primary -> array_literal .)
    MOD             reduce using rule 96 (primary -> array_literal .)
    POWER           reduce using rule 96 (primary -> array_literal .)
    BREAK           reduce using rule 96 (primary -> array_literal .)
    NEXT            reduce using rule 96 (primary -> array_literal .)
    ELSIF           reduce using rule 96 (primary -> array_literal .)
    ELSE            reduce using rule 96 (primary -> array_literal .)
    RETURN          reduce using rule 96 (primary -> array_literal .)
    PRINT           reduce using rule 96 (primary -> array_literal .)
    PUTS            reduce using rule 96 (primary -> array_literal .)
    WHILE           reduce using rule 96 (primary -> array_literal .)
    FOR             reduce using rule 96 (primary -> array_literal .)
    LBRACE          reduce using rule 96 (primary -> array_literal .)
    DEF             reduce using rule 96 (primary -> array_literal .)
    IF              reduce using rule 96 (primary -> array_literal .)
    THEN            reduce using rule 96 (primary -> array_literal .)
    NOT             reduce using rule 96 (primary -> array_literal .)
    NIL             reduce using rule 96 (primary -> array_literal .)
    TRUE            reduce using rule 96 (primary -> array_literal .)
    FALSE           reduce using rule 96 (primary -> array_literal .)
    LPAREN          reduce using rule 96 (primary -> array_literal .)
    INTEGER         reduce using rule 96 (primary -> array_literal .)
    FLOAT           reduce using rule 96 (primary -> array_literal .)
    RATIONAL        reduce using rule 96 (primary -> array_literal .)
    COMPLEX         reduce using rule 96 (primary -> array_literal .)
    STR             reduce using rule 96 (primary -> array_literal .)
    SYMBOL          reduce using rule 96 (primary -> array_literal .)
    REGEXP          reduce using rule 96 (primary -> array_literal .)
    CLASS           reduce using rule 96 (primary -> array_literal .)
    INSTANCE_VAR    reduce using rule 96 (primary -> array_literal .)
    CLASS_VAR       reduce using rule 96 (primary -> array_literal .)
    GLOBAL_VAR      reduce using rule 96 (primary -> array_literal .)
    LOCAL_VAR       reduce using rule 96 (primary -> array_literal .)
    CONSTANT        reduce using rule 96 (primary -> array_literal .)
    $end            reduce using rule 96 (primary -> array_literal .)
    RBRACE          reduce using rule 96 (primary -> array_literal .)
    END_S           reduce using rule 96 (primary -> array_literal .)
    LT              reduce using rule 96 (primary -> array_literal .)
    LE              reduce using rule 96 (primary -> array_literal .)
    GT              reduce using rule 96 (primary -> array_literal .)
    GE              reduce using rule 96 (primary -> array_literal .)
    EQ              reduce using rule 96 (primary -> array_literal .)
    NE              reduce using rule 96 (primary -> array_literal .)
    EQQ             reduce using rule 96 (primary -> array_literal .)
    MATCH           reduce using rule 96 (primary -> array_literal .)
    NMATCH          reduce using rule 96 (primary -> array_literal .)
    ARROW           reduce using rule 96 (primary -> array_literal .)
    RPAREN          reduce using rule 96 (primary -> array_literal .)
    COMMA           reduce using rule 96 (primary -> array_literal .)
    RBRACKET        reduce using rule 96 (primary -> array_literal .)
    ANDAND          reduce using rule 96 (primary -> array_literal .)
    OROR            reduce using rule 96 (primary -> array_literal .)
    AND             reduce using rule 96 (primary -> array_literal .)
    OR              reduce using rule 96 (primary -> array_literal .)
    DO              reduce using rule 96 (primary -> array_literal .)
    COLON           reduce using rule 96 (primary -> array_literal .)


state 58

    (9) stmt_block -> statement_list .
    (2) statement_list -> statement_list . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! reduce/reduce conflict for $end resolved using rule 9 (stmt_block -> statement_list .)
  ! reduce/reduce conflict for RBRACE resolved using rule 9 (stmt_block -> statement_list .)
  ! reduce/reduce conflict for END_S resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 9 (stmt_block -> statement_list .)
    RBRACE          reduce using rule 9 (stmt_block -> statement_list .)
    END_S           reduce using rule 9 (stmt_block -> statement_list .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 59

    (2) statement_list -> statement_list statement .
    (6) stmt_block -> statement .
    (3) statement_list -> statement .

  ! reduce/reduce conflict for BREAK resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FOR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for DEF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for IF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for THEN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NOT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NIL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for STR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for $end resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for END_S resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for BREAK resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FOR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for DEF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for IF resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for THEN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NOT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for NIL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for STR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for $end resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 2 (statement_list -> statement_list statement .)
  ! reduce/reduce conflict for END_S resolved using rule 2 (statement_list -> statement_list statement .)
    BREAK           reduce using rule 2 (statement_list -> statement_list statement .)
    NEXT            reduce using rule 2 (statement_list -> statement_list statement .)
    ELSIF           reduce using rule 2 (statement_list -> statement_list statement .)
    ELSE            reduce using rule 2 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 2 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 2 (statement_list -> statement_list statement .)
    PUTS            reduce using rule 2 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 2 (statement_list -> statement_list statement .)
    FOR             reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    DEF             reduce using rule 2 (statement_list -> statement_list statement .)
    IF              reduce using rule 2 (statement_list -> statement_list statement .)
    THEN            reduce using rule 2 (statement_list -> statement_list statement .)
    NOT             reduce using rule 2 (statement_list -> statement_list statement .)
    NIL             reduce using rule 2 (statement_list -> statement_list statement .)
    TRUE            reduce using rule 2 (statement_list -> statement_list statement .)
    FALSE           reduce using rule 2 (statement_list -> statement_list statement .)
    LPAREN          reduce using rule 2 (statement_list -> statement_list statement .)
    INTEGER         reduce using rule 2 (statement_list -> statement_list statement .)
    FLOAT           reduce using rule 2 (statement_list -> statement_list statement .)
    RATIONAL        reduce using rule 2 (statement_list -> statement_list statement .)
    COMPLEX         reduce using rule 2 (statement_list -> statement_list statement .)
    STR             reduce using rule 2 (statement_list -> statement_list statement .)
    SYMBOL          reduce using rule 2 (statement_list -> statement_list statement .)
    REGEXP          reduce using rule 2 (statement_list -> statement_list statement .)
    MINUS           reduce using rule 2 (statement_list -> statement_list statement .)
    CLASS           reduce using rule 2 (statement_list -> statement_list statement .)
    INSTANCE_VAR    reduce using rule 2 (statement_list -> statement_list statement .)
    CLASS_VAR       reduce using rule 2 (statement_list -> statement_list statement .)
    GLOBAL_VAR      reduce using rule 2 (statement_list -> statement_list statement .)
    LOCAL_VAR       reduce using rule 2 (statement_list -> statement_list statement .)
    CONSTANT        reduce using rule 2 (statement_list -> statement_list statement .)
    LBRACKET        reduce using rule 2 (statement_list -> statement_list statement .)
    $end            reduce using rule 2 (statement_list -> statement_list statement .)
    RBRACE          reduce using rule 2 (statement_list -> statement_list statement .)
    END_S           reduce using rule 2 (statement_list -> statement_list statement .)

  ! BREAK           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NEXT            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSIF           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RETURN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PRINT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PUTS            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! WHILE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FOR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! DEF             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! IF              [ reduce using rule 6 (stmt_block -> statement .) ]
  ! THEN            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NOT             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NIL             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! TRUE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FALSE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LPAREN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INTEGER         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FLOAT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RATIONAL        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! COMPLEX         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! STR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! SYMBOL          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! REGEXP          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! MINUS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LOCAL_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CONSTANT        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACKET        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! $end            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! END_S           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! BREAK           [ reduce using rule 3 (statement_list -> statement .) ]
  ! NEXT            [ reduce using rule 3 (statement_list -> statement .) ]
  ! ELSIF           [ reduce using rule 3 (statement_list -> statement .) ]
  ! ELSE            [ reduce using rule 3 (statement_list -> statement .) ]
  ! RETURN          [ reduce using rule 3 (statement_list -> statement .) ]
  ! PRINT           [ reduce using rule 3 (statement_list -> statement .) ]
  ! PUTS            [ reduce using rule 3 (statement_list -> statement .) ]
  ! WHILE           [ reduce using rule 3 (statement_list -> statement .) ]
  ! FOR             [ reduce using rule 3 (statement_list -> statement .) ]
  ! LBRACE          [ reduce using rule 3 (statement_list -> statement .) ]
  ! DEF             [ reduce using rule 3 (statement_list -> statement .) ]
  ! IF              [ reduce using rule 3 (statement_list -> statement .) ]
  ! THEN            [ reduce using rule 3 (statement_list -> statement .) ]
  ! NOT             [ reduce using rule 3 (statement_list -> statement .) ]
  ! NIL             [ reduce using rule 3 (statement_list -> statement .) ]
  ! TRUE            [ reduce using rule 3 (statement_list -> statement .) ]
  ! FALSE           [ reduce using rule 3 (statement_list -> statement .) ]
  ! LPAREN          [ reduce using rule 3 (statement_list -> statement .) ]
  ! INTEGER         [ reduce using rule 3 (statement_list -> statement .) ]
  ! FLOAT           [ reduce using rule 3 (statement_list -> statement .) ]
  ! RATIONAL        [ reduce using rule 3 (statement_list -> statement .) ]
  ! COMPLEX         [ reduce using rule 3 (statement_list -> statement .) ]
  ! STR             [ reduce using rule 3 (statement_list -> statement .) ]
  ! SYMBOL          [ reduce using rule 3 (statement_list -> statement .) ]
  ! REGEXP          [ reduce using rule 3 (statement_list -> statement .) ]
  ! MINUS           [ reduce using rule 3 (statement_list -> statement .) ]
  ! CLASS           [ reduce using rule 3 (statement_list -> statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 3 (statement_list -> statement .) ]
  ! CLASS_VAR       [ reduce using rule 3 (statement_list -> statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 3 (statement_list -> statement .) ]
  ! LOCAL_VAR       [ reduce using rule 3 (statement_list -> statement .) ]
  ! CONSTANT        [ reduce using rule 3 (statement_list -> statement .) ]
  ! LBRACKET        [ reduce using rule 3 (statement_list -> statement .) ]
  ! $end            [ reduce using rule 3 (statement_list -> statement .) ]
  ! RBRACE          [ reduce using rule 3 (statement_list -> statement .) ]
  ! END_S           [ reduce using rule 3 (statement_list -> statement .) ]


state 60

    (7) stmt_block -> stmt_block statement .
    (6) stmt_block -> statement .
    (3) statement_list -> statement .

  ! reduce/reduce conflict for BREAK resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for FOR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for DEF resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for IF resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for THEN resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for NOT resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for NIL resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for STR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for $end resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for END_S resolved using rule 6 (stmt_block -> statement .)
  ! reduce/reduce conflict for BREAK resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for DEF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for IF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for THEN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NOT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NIL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for STR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for $end resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for END_S resolved using rule 3 (statement_list -> statement .)
    BREAK           reduce using rule 3 (statement_list -> statement .)
    NEXT            reduce using rule 3 (statement_list -> statement .)
    ELSIF           reduce using rule 3 (statement_list -> statement .)
    ELSE            reduce using rule 3 (statement_list -> statement .)
    RETURN          reduce using rule 3 (statement_list -> statement .)
    PRINT           reduce using rule 3 (statement_list -> statement .)
    PUTS            reduce using rule 3 (statement_list -> statement .)
    WHILE           reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    DEF             reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    THEN            reduce using rule 3 (statement_list -> statement .)
    NOT             reduce using rule 3 (statement_list -> statement .)
    NIL             reduce using rule 3 (statement_list -> statement .)
    TRUE            reduce using rule 3 (statement_list -> statement .)
    FALSE           reduce using rule 3 (statement_list -> statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement .)
    INTEGER         reduce using rule 3 (statement_list -> statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement .)
    RATIONAL        reduce using rule 3 (statement_list -> statement .)
    COMPLEX         reduce using rule 3 (statement_list -> statement .)
    STR             reduce using rule 3 (statement_list -> statement .)
    SYMBOL          reduce using rule 3 (statement_list -> statement .)
    REGEXP          reduce using rule 3 (statement_list -> statement .)
    MINUS           reduce using rule 3 (statement_list -> statement .)
    CLASS           reduce using rule 3 (statement_list -> statement .)
    INSTANCE_VAR    reduce using rule 3 (statement_list -> statement .)
    CLASS_VAR       reduce using rule 3 (statement_list -> statement .)
    GLOBAL_VAR      reduce using rule 3 (statement_list -> statement .)
    LOCAL_VAR       reduce using rule 3 (statement_list -> statement .)
    CONSTANT        reduce using rule 3 (statement_list -> statement .)
    LBRACKET        reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)
    END_S           reduce using rule 3 (statement_list -> statement .)

  ! BREAK           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! NEXT            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! ELSIF           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! ELSE            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! RETURN          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! PRINT           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! PUTS            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! WHILE           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! FOR             [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! LBRACE          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! DEF             [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! IF              [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! THEN            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! NOT             [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! NIL             [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! TRUE            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! FALSE           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! LPAREN          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! INTEGER         [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! FLOAT           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! RATIONAL        [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! COMPLEX         [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! STR             [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! SYMBOL          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! REGEXP          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! MINUS           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! CLASS           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! CLASS_VAR       [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! LOCAL_VAR       [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! CONSTANT        [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! LBRACKET        [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! $end            [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! RBRACE          [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! END_S           [ reduce using rule 7 (stmt_block -> stmt_block statement .) ]
  ! BREAK           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NEXT            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSIF           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RETURN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PRINT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PUTS            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! WHILE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FOR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! DEF             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! IF              [ reduce using rule 6 (stmt_block -> statement .) ]
  ! THEN            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NOT             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NIL             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! TRUE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FALSE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LPAREN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INTEGER         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FLOAT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RATIONAL        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! COMPLEX         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! STR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! SYMBOL          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! REGEXP          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! MINUS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LOCAL_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CONSTANT        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACKET        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! $end            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! END_S           [ reduce using rule 6 (stmt_block -> statement .) ]


state 61

    (50) elsif_list -> elsif_list ELSIF . expression_logic optional_then stmt_block
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 115
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 62

    (81) expression -> expression RANGE_INCL . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 116
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 63

    (82) expression -> expression RANGE_EXCL . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 117
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 64

    (130) expression -> expression PLUS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 118
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 65

    (131) expression -> expression MINUS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 119
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 66

    (132) expression -> expression MULT . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 120
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 67

    (133) expression -> expression DIV . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 121
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 68

    (134) expression -> expression MOD . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 122
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 69

    (135) expression -> expression POWER . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 123
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 70

    (53) statement -> ELSIF expression_logic . optional_then stmt_block
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (111) empty -> .

  ! shift/reduce conflict for THEN resolved as shift
    ANDAND          shift and go to state 125
    OROR            shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128
    THEN            shift and go to state 36
    LBRACE          reduce using rule 111 (empty -> .)
    BREAK           reduce using rule 111 (empty -> .)
    NEXT            reduce using rule 111 (empty -> .)
    ELSIF           reduce using rule 111 (empty -> .)
    ELSE            reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    PUTS            reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    DEF             reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    NOT             reduce using rule 111 (empty -> .)
    NIL             reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)
    INTEGER         reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    RATIONAL        reduce using rule 111 (empty -> .)
    COMPLEX         reduce using rule 111 (empty -> .)
    STR             reduce using rule 111 (empty -> .)
    SYMBOL          reduce using rule 111 (empty -> .)
    REGEXP          reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    CLASS           reduce using rule 111 (empty -> .)
    INSTANCE_VAR    reduce using rule 111 (empty -> .)
    CLASS_VAR       reduce using rule 111 (empty -> .)
    GLOBAL_VAR      reduce using rule 111 (empty -> .)
    LOCAL_VAR       reduce using rule 111 (empty -> .)
    CONSTANT        reduce using rule 111 (empty -> .)
    LBRACKET        reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)
    RBRACE          reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)

  ! THEN            [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 124
    empty                          shift and go to state 129

state 71

    (54) statement -> ELSIF expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression
    (62) expression_compare -> expression . LT expression
    (63) expression_compare -> expression . LE expression
    (64) expression_compare -> expression . GT expression
    (65) expression_compare -> expression . GE expression
    (66) expression_compare -> expression . EQ expression
    (67) expression_compare -> expression . NE expression
    (68) expression_compare -> expression . EQQ expression
    (69) expression_compare -> expression . MATCH expression
    (70) expression_compare -> expression . NMATCH expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 54 (statement -> ELSIF expression .)
    NEXT            reduce using rule 54 (statement -> ELSIF expression .)
    ELSIF           reduce using rule 54 (statement -> ELSIF expression .)
    ELSE            reduce using rule 54 (statement -> ELSIF expression .)
    RETURN          reduce using rule 54 (statement -> ELSIF expression .)
    PRINT           reduce using rule 54 (statement -> ELSIF expression .)
    PUTS            reduce using rule 54 (statement -> ELSIF expression .)
    WHILE           reduce using rule 54 (statement -> ELSIF expression .)
    FOR             reduce using rule 54 (statement -> ELSIF expression .)
    LBRACE          reduce using rule 54 (statement -> ELSIF expression .)
    DEF             reduce using rule 54 (statement -> ELSIF expression .)
    IF              reduce using rule 54 (statement -> ELSIF expression .)
    THEN            reduce using rule 54 (statement -> ELSIF expression .)
    NOT             reduce using rule 54 (statement -> ELSIF expression .)
    NIL             reduce using rule 54 (statement -> ELSIF expression .)
    TRUE            reduce using rule 54 (statement -> ELSIF expression .)
    FALSE           reduce using rule 54 (statement -> ELSIF expression .)
    LPAREN          reduce using rule 54 (statement -> ELSIF expression .)
    INTEGER         reduce using rule 54 (statement -> ELSIF expression .)
    FLOAT           reduce using rule 54 (statement -> ELSIF expression .)
    RATIONAL        reduce using rule 54 (statement -> ELSIF expression .)
    COMPLEX         reduce using rule 54 (statement -> ELSIF expression .)
    STR             reduce using rule 54 (statement -> ELSIF expression .)
    SYMBOL          reduce using rule 54 (statement -> ELSIF expression .)
    REGEXP          reduce using rule 54 (statement -> ELSIF expression .)
    CLASS           reduce using rule 54 (statement -> ELSIF expression .)
    INSTANCE_VAR    reduce using rule 54 (statement -> ELSIF expression .)
    CLASS_VAR       reduce using rule 54 (statement -> ELSIF expression .)
    GLOBAL_VAR      reduce using rule 54 (statement -> ELSIF expression .)
    LOCAL_VAR       reduce using rule 54 (statement -> ELSIF expression .)
    CONSTANT        reduce using rule 54 (statement -> ELSIF expression .)
    LBRACKET        reduce using rule 54 (statement -> ELSIF expression .)
    $end            reduce using rule 54 (statement -> ELSIF expression .)
    RBRACE          reduce using rule 54 (statement -> ELSIF expression .)
    END_S           reduce using rule 54 (statement -> ELSIF expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    LT              shift and go to state 130
    LE              shift and go to state 131
    GT              shift and go to state 132
    GE              shift and go to state 133
    EQ              shift and go to state 134
    NE              shift and go to state 135
    EQQ             shift and go to state 136
    MATCH           shift and go to state 137
    NMATCH          shift and go to state 138

  ! MINUS           [ reduce using rule 54 (statement -> ELSIF expression .) ]


state 72

    (61) expression_logic -> expression_compare .

    ANDAND          reduce using rule 61 (expression_logic -> expression_compare .)
    OROR            reduce using rule 61 (expression_logic -> expression_compare .)
    AND             reduce using rule 61 (expression_logic -> expression_compare .)
    OR              reduce using rule 61 (expression_logic -> expression_compare .)
    THEN            reduce using rule 61 (expression_logic -> expression_compare .)
    LBRACE          reduce using rule 61 (expression_logic -> expression_compare .)
    BREAK           reduce using rule 61 (expression_logic -> expression_compare .)
    NEXT            reduce using rule 61 (expression_logic -> expression_compare .)
    ELSIF           reduce using rule 61 (expression_logic -> expression_compare .)
    ELSE            reduce using rule 61 (expression_logic -> expression_compare .)
    RETURN          reduce using rule 61 (expression_logic -> expression_compare .)
    PRINT           reduce using rule 61 (expression_logic -> expression_compare .)
    PUTS            reduce using rule 61 (expression_logic -> expression_compare .)
    WHILE           reduce using rule 61 (expression_logic -> expression_compare .)
    FOR             reduce using rule 61 (expression_logic -> expression_compare .)
    DEF             reduce using rule 61 (expression_logic -> expression_compare .)
    IF              reduce using rule 61 (expression_logic -> expression_compare .)
    NOT             reduce using rule 61 (expression_logic -> expression_compare .)
    NIL             reduce using rule 61 (expression_logic -> expression_compare .)
    TRUE            reduce using rule 61 (expression_logic -> expression_compare .)
    FALSE           reduce using rule 61 (expression_logic -> expression_compare .)
    LPAREN          reduce using rule 61 (expression_logic -> expression_compare .)
    INTEGER         reduce using rule 61 (expression_logic -> expression_compare .)
    FLOAT           reduce using rule 61 (expression_logic -> expression_compare .)
    RATIONAL        reduce using rule 61 (expression_logic -> expression_compare .)
    COMPLEX         reduce using rule 61 (expression_logic -> expression_compare .)
    STR             reduce using rule 61 (expression_logic -> expression_compare .)
    SYMBOL          reduce using rule 61 (expression_logic -> expression_compare .)
    REGEXP          reduce using rule 61 (expression_logic -> expression_compare .)
    MINUS           reduce using rule 61 (expression_logic -> expression_compare .)
    CLASS           reduce using rule 61 (expression_logic -> expression_compare .)
    INSTANCE_VAR    reduce using rule 61 (expression_logic -> expression_compare .)
    CLASS_VAR       reduce using rule 61 (expression_logic -> expression_compare .)
    GLOBAL_VAR      reduce using rule 61 (expression_logic -> expression_compare .)
    LOCAL_VAR       reduce using rule 61 (expression_logic -> expression_compare .)
    CONSTANT        reduce using rule 61 (expression_logic -> expression_compare .)
    LBRACKET        reduce using rule 61 (expression_logic -> expression_compare .)
    $end            reduce using rule 61 (expression_logic -> expression_compare .)
    RBRACE          reduce using rule 61 (expression_logic -> expression_compare .)
    END_S           reduce using rule 61 (expression_logic -> expression_compare .)
    DO              reduce using rule 61 (expression_logic -> expression_compare .)


state 73

    (80) expression -> hash_literal .

    RANGE_INCL      reduce using rule 80 (expression -> hash_literal .)
    RANGE_EXCL      reduce using rule 80 (expression -> hash_literal .)
    PLUS            reduce using rule 80 (expression -> hash_literal .)
    MINUS           reduce using rule 80 (expression -> hash_literal .)
    MULT            reduce using rule 80 (expression -> hash_literal .)
    DIV             reduce using rule 80 (expression -> hash_literal .)
    MOD             reduce using rule 80 (expression -> hash_literal .)
    POWER           reduce using rule 80 (expression -> hash_literal .)
    LT              reduce using rule 80 (expression -> hash_literal .)
    LE              reduce using rule 80 (expression -> hash_literal .)
    GT              reduce using rule 80 (expression -> hash_literal .)
    GE              reduce using rule 80 (expression -> hash_literal .)
    EQ              reduce using rule 80 (expression -> hash_literal .)
    NE              reduce using rule 80 (expression -> hash_literal .)
    EQQ             reduce using rule 80 (expression -> hash_literal .)
    MATCH           reduce using rule 80 (expression -> hash_literal .)
    NMATCH          reduce using rule 80 (expression -> hash_literal .)
    BREAK           reduce using rule 80 (expression -> hash_literal .)
    NEXT            reduce using rule 80 (expression -> hash_literal .)
    ELSIF           reduce using rule 80 (expression -> hash_literal .)
    ELSE            reduce using rule 80 (expression -> hash_literal .)
    RETURN          reduce using rule 80 (expression -> hash_literal .)
    PRINT           reduce using rule 80 (expression -> hash_literal .)
    PUTS            reduce using rule 80 (expression -> hash_literal .)
    WHILE           reduce using rule 80 (expression -> hash_literal .)
    FOR             reduce using rule 80 (expression -> hash_literal .)
    LBRACE          reduce using rule 80 (expression -> hash_literal .)
    DEF             reduce using rule 80 (expression -> hash_literal .)
    IF              reduce using rule 80 (expression -> hash_literal .)
    THEN            reduce using rule 80 (expression -> hash_literal .)
    NOT             reduce using rule 80 (expression -> hash_literal .)
    NIL             reduce using rule 80 (expression -> hash_literal .)
    TRUE            reduce using rule 80 (expression -> hash_literal .)
    FALSE           reduce using rule 80 (expression -> hash_literal .)
    LPAREN          reduce using rule 80 (expression -> hash_literal .)
    INTEGER         reduce using rule 80 (expression -> hash_literal .)
    FLOAT           reduce using rule 80 (expression -> hash_literal .)
    RATIONAL        reduce using rule 80 (expression -> hash_literal .)
    COMPLEX         reduce using rule 80 (expression -> hash_literal .)
    STR             reduce using rule 80 (expression -> hash_literal .)
    SYMBOL          reduce using rule 80 (expression -> hash_literal .)
    REGEXP          reduce using rule 80 (expression -> hash_literal .)
    CLASS           reduce using rule 80 (expression -> hash_literal .)
    INSTANCE_VAR    reduce using rule 80 (expression -> hash_literal .)
    CLASS_VAR       reduce using rule 80 (expression -> hash_literal .)
    GLOBAL_VAR      reduce using rule 80 (expression -> hash_literal .)
    LOCAL_VAR       reduce using rule 80 (expression -> hash_literal .)
    CONSTANT        reduce using rule 80 (expression -> hash_literal .)
    LBRACKET        reduce using rule 80 (expression -> hash_literal .)
    $end            reduce using rule 80 (expression -> hash_literal .)
    RBRACE          reduce using rule 80 (expression -> hash_literal .)
    END_S           reduce using rule 80 (expression -> hash_literal .)
    RPAREN          reduce using rule 80 (expression -> hash_literal .)
    ARROW           reduce using rule 80 (expression -> hash_literal .)
    COMMA           reduce using rule 80 (expression -> hash_literal .)
    RBRACKET        reduce using rule 80 (expression -> hash_literal .)
    ANDAND          reduce using rule 80 (expression -> hash_literal .)
    OROR            reduce using rule 80 (expression -> hash_literal .)
    AND             reduce using rule 80 (expression -> hash_literal .)
    OR              reduce using rule 80 (expression -> hash_literal .)
    DO              reduce using rule 80 (expression -> hash_literal .)
    COLON           reduce using rule 80 (expression -> hash_literal .)


state 74

    (144) expression -> variable .
    (91) primary -> variable .

  ! reduce/reduce conflict for LBRACKET resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PLUS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MINUS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MULT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for DIV resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MOD resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for POWER resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for GT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for GE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for EQ resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for EQQ resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for MATCH resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NMATCH resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for BREAK resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NEXT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ELSIF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ELSE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RETURN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PRINT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for PUTS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for WHILE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FOR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LBRACE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for DEF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for IF resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for THEN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NOT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for NIL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for TRUE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FALSE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LPAREN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for INTEGER resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for FLOAT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for STR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for REGEXP resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CLASS resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for $end resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RBRACE resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for END_S resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RPAREN resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ARROW resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for ANDAND resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for OROR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for AND resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for OR resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for DO resolved using rule 91 (primary -> variable .)
  ! reduce/reduce conflict for COLON resolved using rule 91 (primary -> variable .)
    LBRACKET        reduce using rule 91 (primary -> variable .)
    DOT             reduce using rule 91 (primary -> variable .)
    RANGE_INCL      reduce using rule 91 (primary -> variable .)
    RANGE_EXCL      reduce using rule 91 (primary -> variable .)
    PLUS            reduce using rule 91 (primary -> variable .)
    MINUS           reduce using rule 91 (primary -> variable .)
    MULT            reduce using rule 91 (primary -> variable .)
    DIV             reduce using rule 91 (primary -> variable .)
    MOD             reduce using rule 91 (primary -> variable .)
    POWER           reduce using rule 91 (primary -> variable .)
    LT              reduce using rule 91 (primary -> variable .)
    LE              reduce using rule 91 (primary -> variable .)
    GT              reduce using rule 91 (primary -> variable .)
    GE              reduce using rule 91 (primary -> variable .)
    EQ              reduce using rule 91 (primary -> variable .)
    NE              reduce using rule 91 (primary -> variable .)
    EQQ             reduce using rule 91 (primary -> variable .)
    MATCH           reduce using rule 91 (primary -> variable .)
    NMATCH          reduce using rule 91 (primary -> variable .)
    BREAK           reduce using rule 91 (primary -> variable .)
    NEXT            reduce using rule 91 (primary -> variable .)
    ELSIF           reduce using rule 91 (primary -> variable .)
    ELSE            reduce using rule 91 (primary -> variable .)
    RETURN          reduce using rule 91 (primary -> variable .)
    PRINT           reduce using rule 91 (primary -> variable .)
    PUTS            reduce using rule 91 (primary -> variable .)
    WHILE           reduce using rule 91 (primary -> variable .)
    FOR             reduce using rule 91 (primary -> variable .)
    LBRACE          reduce using rule 91 (primary -> variable .)
    DEF             reduce using rule 91 (primary -> variable .)
    IF              reduce using rule 91 (primary -> variable .)
    THEN            reduce using rule 91 (primary -> variable .)
    NOT             reduce using rule 91 (primary -> variable .)
    NIL             reduce using rule 91 (primary -> variable .)
    TRUE            reduce using rule 91 (primary -> variable .)
    FALSE           reduce using rule 91 (primary -> variable .)
    LPAREN          reduce using rule 91 (primary -> variable .)
    INTEGER         reduce using rule 91 (primary -> variable .)
    FLOAT           reduce using rule 91 (primary -> variable .)
    RATIONAL        reduce using rule 91 (primary -> variable .)
    COMPLEX         reduce using rule 91 (primary -> variable .)
    STR             reduce using rule 91 (primary -> variable .)
    SYMBOL          reduce using rule 91 (primary -> variable .)
    REGEXP          reduce using rule 91 (primary -> variable .)
    CLASS           reduce using rule 91 (primary -> variable .)
    INSTANCE_VAR    reduce using rule 91 (primary -> variable .)
    CLASS_VAR       reduce using rule 91 (primary -> variable .)
    GLOBAL_VAR      reduce using rule 91 (primary -> variable .)
    LOCAL_VAR       reduce using rule 91 (primary -> variable .)
    CONSTANT        reduce using rule 91 (primary -> variable .)
    $end            reduce using rule 91 (primary -> variable .)
    RBRACE          reduce using rule 91 (primary -> variable .)
    END_S           reduce using rule 91 (primary -> variable .)
    RPAREN          reduce using rule 91 (primary -> variable .)
    ARROW           reduce using rule 91 (primary -> variable .)
    COMMA           reduce using rule 91 (primary -> variable .)
    RBRACKET        reduce using rule 91 (primary -> variable .)
    ANDAND          reduce using rule 91 (primary -> variable .)
    OROR            reduce using rule 91 (primary -> variable .)
    AND             reduce using rule 91 (primary -> variable .)
    OR              reduce using rule 91 (primary -> variable .)
    DO              reduce using rule 91 (primary -> variable .)
    COLON           reduce using rule 91 (primary -> variable .)

  ! RANGE_INCL      [ reduce using rule 144 (expression -> variable .) ]
  ! RANGE_EXCL      [ reduce using rule 144 (expression -> variable .) ]
  ! PLUS            [ reduce using rule 144 (expression -> variable .) ]
  ! MINUS           [ reduce using rule 144 (expression -> variable .) ]
  ! MULT            [ reduce using rule 144 (expression -> variable .) ]
  ! DIV             [ reduce using rule 144 (expression -> variable .) ]
  ! MOD             [ reduce using rule 144 (expression -> variable .) ]
  ! POWER           [ reduce using rule 144 (expression -> variable .) ]
  ! LT              [ reduce using rule 144 (expression -> variable .) ]
  ! LE              [ reduce using rule 144 (expression -> variable .) ]
  ! GT              [ reduce using rule 144 (expression -> variable .) ]
  ! GE              [ reduce using rule 144 (expression -> variable .) ]
  ! EQ              [ reduce using rule 144 (expression -> variable .) ]
  ! NE              [ reduce using rule 144 (expression -> variable .) ]
  ! EQQ             [ reduce using rule 144 (expression -> variable .) ]
  ! MATCH           [ reduce using rule 144 (expression -> variable .) ]
  ! NMATCH          [ reduce using rule 144 (expression -> variable .) ]
  ! BREAK           [ reduce using rule 144 (expression -> variable .) ]
  ! NEXT            [ reduce using rule 144 (expression -> variable .) ]
  ! ELSIF           [ reduce using rule 144 (expression -> variable .) ]
  ! ELSE            [ reduce using rule 144 (expression -> variable .) ]
  ! RETURN          [ reduce using rule 144 (expression -> variable .) ]
  ! PRINT           [ reduce using rule 144 (expression -> variable .) ]
  ! PUTS            [ reduce using rule 144 (expression -> variable .) ]
  ! WHILE           [ reduce using rule 144 (expression -> variable .) ]
  ! FOR             [ reduce using rule 144 (expression -> variable .) ]
  ! LBRACE          [ reduce using rule 144 (expression -> variable .) ]
  ! DEF             [ reduce using rule 144 (expression -> variable .) ]
  ! IF              [ reduce using rule 144 (expression -> variable .) ]
  ! THEN            [ reduce using rule 144 (expression -> variable .) ]
  ! NOT             [ reduce using rule 144 (expression -> variable .) ]
  ! NIL             [ reduce using rule 144 (expression -> variable .) ]
  ! TRUE            [ reduce using rule 144 (expression -> variable .) ]
  ! FALSE           [ reduce using rule 144 (expression -> variable .) ]
  ! LPAREN          [ reduce using rule 144 (expression -> variable .) ]
  ! INTEGER         [ reduce using rule 144 (expression -> variable .) ]
  ! FLOAT           [ reduce using rule 144 (expression -> variable .) ]
  ! RATIONAL        [ reduce using rule 144 (expression -> variable .) ]
  ! COMPLEX         [ reduce using rule 144 (expression -> variable .) ]
  ! STR             [ reduce using rule 144 (expression -> variable .) ]
  ! SYMBOL          [ reduce using rule 144 (expression -> variable .) ]
  ! REGEXP          [ reduce using rule 144 (expression -> variable .) ]
  ! CLASS           [ reduce using rule 144 (expression -> variable .) ]
  ! INSTANCE_VAR    [ reduce using rule 144 (expression -> variable .) ]
  ! CLASS_VAR       [ reduce using rule 144 (expression -> variable .) ]
  ! GLOBAL_VAR      [ reduce using rule 144 (expression -> variable .) ]
  ! LOCAL_VAR       [ reduce using rule 144 (expression -> variable .) ]
  ! CONSTANT        [ reduce using rule 144 (expression -> variable .) ]
  ! LBRACKET        [ reduce using rule 144 (expression -> variable .) ]
  ! $end            [ reduce using rule 144 (expression -> variable .) ]
  ! RBRACE          [ reduce using rule 144 (expression -> variable .) ]
  ! END_S           [ reduce using rule 144 (expression -> variable .) ]
  ! RPAREN          [ reduce using rule 144 (expression -> variable .) ]
  ! ARROW           [ reduce using rule 144 (expression -> variable .) ]
  ! COMMA           [ reduce using rule 144 (expression -> variable .) ]
  ! RBRACKET        [ reduce using rule 144 (expression -> variable .) ]
  ! ANDAND          [ reduce using rule 144 (expression -> variable .) ]
  ! OROR            [ reduce using rule 144 (expression -> variable .) ]
  ! AND             [ reduce using rule 144 (expression -> variable .) ]
  ! OR              [ reduce using rule 144 (expression -> variable .) ]
  ! DO              [ reduce using rule 144 (expression -> variable .) ]
  ! COLON           [ reduce using rule 144 (expression -> variable .) ]


state 75

    (145) expression -> expr_postfix .
    (99) expr_postfix -> expr_postfix . LBRACKET expression RBRACKET
    (146) expr_postfix -> expr_postfix . DOT LOCAL_VAR
    (147) expr_postfix -> expr_postfix . DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> expr_postfix . DOT LOCAL_VAR LPAREN expr_list RPAREN

  ! shift/reduce conflict for LBRACKET resolved as shift
    RANGE_INCL      reduce using rule 145 (expression -> expr_postfix .)
    RANGE_EXCL      reduce using rule 145 (expression -> expr_postfix .)
    PLUS            reduce using rule 145 (expression -> expr_postfix .)
    MINUS           reduce using rule 145 (expression -> expr_postfix .)
    MULT            reduce using rule 145 (expression -> expr_postfix .)
    DIV             reduce using rule 145 (expression -> expr_postfix .)
    MOD             reduce using rule 145 (expression -> expr_postfix .)
    POWER           reduce using rule 145 (expression -> expr_postfix .)
    LT              reduce using rule 145 (expression -> expr_postfix .)
    LE              reduce using rule 145 (expression -> expr_postfix .)
    GT              reduce using rule 145 (expression -> expr_postfix .)
    GE              reduce using rule 145 (expression -> expr_postfix .)
    EQ              reduce using rule 145 (expression -> expr_postfix .)
    NE              reduce using rule 145 (expression -> expr_postfix .)
    EQQ             reduce using rule 145 (expression -> expr_postfix .)
    MATCH           reduce using rule 145 (expression -> expr_postfix .)
    NMATCH          reduce using rule 145 (expression -> expr_postfix .)
    BREAK           reduce using rule 145 (expression -> expr_postfix .)
    NEXT            reduce using rule 145 (expression -> expr_postfix .)
    ELSIF           reduce using rule 145 (expression -> expr_postfix .)
    ELSE            reduce using rule 145 (expression -> expr_postfix .)
    RETURN          reduce using rule 145 (expression -> expr_postfix .)
    PRINT           reduce using rule 145 (expression -> expr_postfix .)
    PUTS            reduce using rule 145 (expression -> expr_postfix .)
    WHILE           reduce using rule 145 (expression -> expr_postfix .)
    FOR             reduce using rule 145 (expression -> expr_postfix .)
    LBRACE          reduce using rule 145 (expression -> expr_postfix .)
    DEF             reduce using rule 145 (expression -> expr_postfix .)
    IF              reduce using rule 145 (expression -> expr_postfix .)
    THEN            reduce using rule 145 (expression -> expr_postfix .)
    NOT             reduce using rule 145 (expression -> expr_postfix .)
    NIL             reduce using rule 145 (expression -> expr_postfix .)
    TRUE            reduce using rule 145 (expression -> expr_postfix .)
    FALSE           reduce using rule 145 (expression -> expr_postfix .)
    LPAREN          reduce using rule 145 (expression -> expr_postfix .)
    INTEGER         reduce using rule 145 (expression -> expr_postfix .)
    FLOAT           reduce using rule 145 (expression -> expr_postfix .)
    RATIONAL        reduce using rule 145 (expression -> expr_postfix .)
    COMPLEX         reduce using rule 145 (expression -> expr_postfix .)
    STR             reduce using rule 145 (expression -> expr_postfix .)
    SYMBOL          reduce using rule 145 (expression -> expr_postfix .)
    REGEXP          reduce using rule 145 (expression -> expr_postfix .)
    CLASS           reduce using rule 145 (expression -> expr_postfix .)
    INSTANCE_VAR    reduce using rule 145 (expression -> expr_postfix .)
    CLASS_VAR       reduce using rule 145 (expression -> expr_postfix .)
    GLOBAL_VAR      reduce using rule 145 (expression -> expr_postfix .)
    LOCAL_VAR       reduce using rule 145 (expression -> expr_postfix .)
    CONSTANT        reduce using rule 145 (expression -> expr_postfix .)
    $end            reduce using rule 145 (expression -> expr_postfix .)
    RBRACE          reduce using rule 145 (expression -> expr_postfix .)
    END_S           reduce using rule 145 (expression -> expr_postfix .)
    RPAREN          reduce using rule 145 (expression -> expr_postfix .)
    ARROW           reduce using rule 145 (expression -> expr_postfix .)
    COMMA           reduce using rule 145 (expression -> expr_postfix .)
    RBRACKET        reduce using rule 145 (expression -> expr_postfix .)
    ANDAND          reduce using rule 145 (expression -> expr_postfix .)
    OROR            reduce using rule 145 (expression -> expr_postfix .)
    AND             reduce using rule 145 (expression -> expr_postfix .)
    OR              reduce using rule 145 (expression -> expr_postfix .)
    DO              reduce using rule 145 (expression -> expr_postfix .)
    COLON           reduce using rule 145 (expression -> expr_postfix .)
    LBRACKET        shift and go to state 94
    DOT             shift and go to state 95

  ! LBRACKET        [ reduce using rule 145 (expression -> expr_postfix .) ]


state 76

    (72) hash_literal -> LBRACE . hash_pairs_opt RBRACE
    (73) hash_pairs_opt -> .
    (74) hash_pairs_opt -> . hash_pairs
    (75) hash_pairs -> . hash_pairs COMMA hash_pair
    (76) hash_pairs -> . hash_pair
    (77) hash_pair -> . expression ARROW expression
    (78) hash_pair -> . SYMBOL COLON expression
    (79) hash_pair -> . LOCAL_VAR COLON expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    RBRACE          reduce using rule 73 (hash_pairs_opt -> .)
    SYMBOL          shift and go to state 104
    LOCAL_VAR       shift and go to state 105
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    hash_pairs_opt                 shift and go to state 99
    hash_pairs                     shift and go to state 101
    hash_pair                      shift and go to state 102
    expression                     shift and go to state 139
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 77

    (28) variable -> INSTANCE_VAR .

    RANGE_INCL      reduce using rule 28 (variable -> INSTANCE_VAR .)
    RANGE_EXCL      reduce using rule 28 (variable -> INSTANCE_VAR .)
    PLUS            reduce using rule 28 (variable -> INSTANCE_VAR .)
    MINUS           reduce using rule 28 (variable -> INSTANCE_VAR .)
    MULT            reduce using rule 28 (variable -> INSTANCE_VAR .)
    DIV             reduce using rule 28 (variable -> INSTANCE_VAR .)
    MOD             reduce using rule 28 (variable -> INSTANCE_VAR .)
    POWER           reduce using rule 28 (variable -> INSTANCE_VAR .)
    LT              reduce using rule 28 (variable -> INSTANCE_VAR .)
    LE              reduce using rule 28 (variable -> INSTANCE_VAR .)
    GT              reduce using rule 28 (variable -> INSTANCE_VAR .)
    GE              reduce using rule 28 (variable -> INSTANCE_VAR .)
    EQ              reduce using rule 28 (variable -> INSTANCE_VAR .)
    NE              reduce using rule 28 (variable -> INSTANCE_VAR .)
    EQQ             reduce using rule 28 (variable -> INSTANCE_VAR .)
    MATCH           reduce using rule 28 (variable -> INSTANCE_VAR .)
    NMATCH          reduce using rule 28 (variable -> INSTANCE_VAR .)
    BREAK           reduce using rule 28 (variable -> INSTANCE_VAR .)
    NEXT            reduce using rule 28 (variable -> INSTANCE_VAR .)
    ELSIF           reduce using rule 28 (variable -> INSTANCE_VAR .)
    ELSE            reduce using rule 28 (variable -> INSTANCE_VAR .)
    RETURN          reduce using rule 28 (variable -> INSTANCE_VAR .)
    PRINT           reduce using rule 28 (variable -> INSTANCE_VAR .)
    PUTS            reduce using rule 28 (variable -> INSTANCE_VAR .)
    WHILE           reduce using rule 28 (variable -> INSTANCE_VAR .)
    FOR             reduce using rule 28 (variable -> INSTANCE_VAR .)
    LBRACE          reduce using rule 28 (variable -> INSTANCE_VAR .)
    DEF             reduce using rule 28 (variable -> INSTANCE_VAR .)
    IF              reduce using rule 28 (variable -> INSTANCE_VAR .)
    THEN            reduce using rule 28 (variable -> INSTANCE_VAR .)
    NOT             reduce using rule 28 (variable -> INSTANCE_VAR .)
    NIL             reduce using rule 28 (variable -> INSTANCE_VAR .)
    TRUE            reduce using rule 28 (variable -> INSTANCE_VAR .)
    FALSE           reduce using rule 28 (variable -> INSTANCE_VAR .)
    LPAREN          reduce using rule 28 (variable -> INSTANCE_VAR .)
    INTEGER         reduce using rule 28 (variable -> INSTANCE_VAR .)
    FLOAT           reduce using rule 28 (variable -> INSTANCE_VAR .)
    RATIONAL        reduce using rule 28 (variable -> INSTANCE_VAR .)
    COMPLEX         reduce using rule 28 (variable -> INSTANCE_VAR .)
    STR             reduce using rule 28 (variable -> INSTANCE_VAR .)
    SYMBOL          reduce using rule 28 (variable -> INSTANCE_VAR .)
    REGEXP          reduce using rule 28 (variable -> INSTANCE_VAR .)
    CLASS           reduce using rule 28 (variable -> INSTANCE_VAR .)
    INSTANCE_VAR    reduce using rule 28 (variable -> INSTANCE_VAR .)
    CLASS_VAR       reduce using rule 28 (variable -> INSTANCE_VAR .)
    GLOBAL_VAR      reduce using rule 28 (variable -> INSTANCE_VAR .)
    LOCAL_VAR       reduce using rule 28 (variable -> INSTANCE_VAR .)
    CONSTANT        reduce using rule 28 (variable -> INSTANCE_VAR .)
    LBRACKET        reduce using rule 28 (variable -> INSTANCE_VAR .)
    $end            reduce using rule 28 (variable -> INSTANCE_VAR .)
    RBRACE          reduce using rule 28 (variable -> INSTANCE_VAR .)
    END_S           reduce using rule 28 (variable -> INSTANCE_VAR .)
    DOT             reduce using rule 28 (variable -> INSTANCE_VAR .)
    RPAREN          reduce using rule 28 (variable -> INSTANCE_VAR .)
    ARROW           reduce using rule 28 (variable -> INSTANCE_VAR .)
    COMMA           reduce using rule 28 (variable -> INSTANCE_VAR .)
    RBRACKET        reduce using rule 28 (variable -> INSTANCE_VAR .)
    ANDAND          reduce using rule 28 (variable -> INSTANCE_VAR .)
    OROR            reduce using rule 28 (variable -> INSTANCE_VAR .)
    AND             reduce using rule 28 (variable -> INSTANCE_VAR .)
    OR              reduce using rule 28 (variable -> INSTANCE_VAR .)
    DO              reduce using rule 28 (variable -> INSTANCE_VAR .)
    COLON           reduce using rule 28 (variable -> INSTANCE_VAR .)


state 78

    (29) variable -> CLASS_VAR .

    RANGE_INCL      reduce using rule 29 (variable -> CLASS_VAR .)
    RANGE_EXCL      reduce using rule 29 (variable -> CLASS_VAR .)
    PLUS            reduce using rule 29 (variable -> CLASS_VAR .)
    MINUS           reduce using rule 29 (variable -> CLASS_VAR .)
    MULT            reduce using rule 29 (variable -> CLASS_VAR .)
    DIV             reduce using rule 29 (variable -> CLASS_VAR .)
    MOD             reduce using rule 29 (variable -> CLASS_VAR .)
    POWER           reduce using rule 29 (variable -> CLASS_VAR .)
    LT              reduce using rule 29 (variable -> CLASS_VAR .)
    LE              reduce using rule 29 (variable -> CLASS_VAR .)
    GT              reduce using rule 29 (variable -> CLASS_VAR .)
    GE              reduce using rule 29 (variable -> CLASS_VAR .)
    EQ              reduce using rule 29 (variable -> CLASS_VAR .)
    NE              reduce using rule 29 (variable -> CLASS_VAR .)
    EQQ             reduce using rule 29 (variable -> CLASS_VAR .)
    MATCH           reduce using rule 29 (variable -> CLASS_VAR .)
    NMATCH          reduce using rule 29 (variable -> CLASS_VAR .)
    BREAK           reduce using rule 29 (variable -> CLASS_VAR .)
    NEXT            reduce using rule 29 (variable -> CLASS_VAR .)
    ELSIF           reduce using rule 29 (variable -> CLASS_VAR .)
    ELSE            reduce using rule 29 (variable -> CLASS_VAR .)
    RETURN          reduce using rule 29 (variable -> CLASS_VAR .)
    PRINT           reduce using rule 29 (variable -> CLASS_VAR .)
    PUTS            reduce using rule 29 (variable -> CLASS_VAR .)
    WHILE           reduce using rule 29 (variable -> CLASS_VAR .)
    FOR             reduce using rule 29 (variable -> CLASS_VAR .)
    LBRACE          reduce using rule 29 (variable -> CLASS_VAR .)
    DEF             reduce using rule 29 (variable -> CLASS_VAR .)
    IF              reduce using rule 29 (variable -> CLASS_VAR .)
    THEN            reduce using rule 29 (variable -> CLASS_VAR .)
    NOT             reduce using rule 29 (variable -> CLASS_VAR .)
    NIL             reduce using rule 29 (variable -> CLASS_VAR .)
    TRUE            reduce using rule 29 (variable -> CLASS_VAR .)
    FALSE           reduce using rule 29 (variable -> CLASS_VAR .)
    LPAREN          reduce using rule 29 (variable -> CLASS_VAR .)
    INTEGER         reduce using rule 29 (variable -> CLASS_VAR .)
    FLOAT           reduce using rule 29 (variable -> CLASS_VAR .)
    RATIONAL        reduce using rule 29 (variable -> CLASS_VAR .)
    COMPLEX         reduce using rule 29 (variable -> CLASS_VAR .)
    STR             reduce using rule 29 (variable -> CLASS_VAR .)
    SYMBOL          reduce using rule 29 (variable -> CLASS_VAR .)
    REGEXP          reduce using rule 29 (variable -> CLASS_VAR .)
    CLASS           reduce using rule 29 (variable -> CLASS_VAR .)
    INSTANCE_VAR    reduce using rule 29 (variable -> CLASS_VAR .)
    CLASS_VAR       reduce using rule 29 (variable -> CLASS_VAR .)
    GLOBAL_VAR      reduce using rule 29 (variable -> CLASS_VAR .)
    LOCAL_VAR       reduce using rule 29 (variable -> CLASS_VAR .)
    CONSTANT        reduce using rule 29 (variable -> CLASS_VAR .)
    LBRACKET        reduce using rule 29 (variable -> CLASS_VAR .)
    $end            reduce using rule 29 (variable -> CLASS_VAR .)
    RBRACE          reduce using rule 29 (variable -> CLASS_VAR .)
    END_S           reduce using rule 29 (variable -> CLASS_VAR .)
    DOT             reduce using rule 29 (variable -> CLASS_VAR .)
    RPAREN          reduce using rule 29 (variable -> CLASS_VAR .)
    ARROW           reduce using rule 29 (variable -> CLASS_VAR .)
    COMMA           reduce using rule 29 (variable -> CLASS_VAR .)
    RBRACKET        reduce using rule 29 (variable -> CLASS_VAR .)
    ANDAND          reduce using rule 29 (variable -> CLASS_VAR .)
    OROR            reduce using rule 29 (variable -> CLASS_VAR .)
    AND             reduce using rule 29 (variable -> CLASS_VAR .)
    OR              reduce using rule 29 (variable -> CLASS_VAR .)
    DO              reduce using rule 29 (variable -> CLASS_VAR .)
    COLON           reduce using rule 29 (variable -> CLASS_VAR .)


state 79

    (55) statement -> ELSE stmt_block .
    (52) else_part -> ELSE stmt_block .
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for BREAK resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for NEXT resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for ELSIF resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for ELSE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for PUTS resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for FOR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for DEF resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for IF resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for THEN resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for NOT resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for NIL resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for TRUE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for FALSE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for INTEGER resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for FLOAT resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for STR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for REGEXP resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for CLASS resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 52 (else_part -> ELSE stmt_block .)
  ! reduce/reduce conflict for BREAK resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NEXT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSIF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PUTS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for DEF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for IF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for THEN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NIL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for STR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for REGEXP resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 19 (statement -> stmt_block .)
    RBRACE          reduce using rule 19 (statement -> stmt_block .)
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! NEXT            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! ELSIF           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! ELSE            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! RETURN          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! PRINT           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! PUTS            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! WHILE           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! FOR             [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! LBRACE          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! DEF             [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! IF              [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! THEN            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! NOT             [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! NIL             [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! TRUE            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! FALSE           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! LPAREN          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! INTEGER         [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! FLOAT           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! RATIONAL        [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! COMPLEX         [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! STR             [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! SYMBOL          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! REGEXP          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! MINUS           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! CLASS           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! CONSTANT        [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! LBRACKET        [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! $end            [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! RBRACE          [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! END_S           [ reduce using rule 55 (statement -> ELSE stmt_block .) ]
  ! BREAK           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! NEXT            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! ELSIF           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! ELSE            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! RETURN          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! PRINT           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! PUTS            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! WHILE           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! FOR             [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! LBRACE          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! DEF             [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! IF              [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! THEN            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! NOT             [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! NIL             [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! TRUE            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! FALSE           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! LPAREN          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! INTEGER         [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! FLOAT           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! RATIONAL        [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! COMPLEX         [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! STR             [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! SYMBOL          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! REGEXP          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! MINUS           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! CLASS           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! CONSTANT        [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! LBRACKET        [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! $end            [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! RBRACE          [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! END_S           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 80

    (6) stmt_block -> statement .
    (3) statement_list -> statement .

  ! reduce/reduce conflict for BREAK resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NEXT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSIF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for ELSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RETURN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PRINT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for PUTS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for WHILE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FOR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for DEF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for IF resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for THEN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NOT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for NIL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for TRUE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FALSE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LPAREN resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INTEGER resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for FLOAT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for STR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for REGEXP resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for MINUS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for $end resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (statement_list -> statement .)
  ! reduce/reduce conflict for END_S resolved using rule 3 (statement_list -> statement .)
    BREAK           reduce using rule 3 (statement_list -> statement .)
    NEXT            reduce using rule 3 (statement_list -> statement .)
    ELSIF           reduce using rule 3 (statement_list -> statement .)
    ELSE            reduce using rule 3 (statement_list -> statement .)
    RETURN          reduce using rule 3 (statement_list -> statement .)
    PRINT           reduce using rule 3 (statement_list -> statement .)
    PUTS            reduce using rule 3 (statement_list -> statement .)
    WHILE           reduce using rule 3 (statement_list -> statement .)
    FOR             reduce using rule 3 (statement_list -> statement .)
    LBRACE          reduce using rule 3 (statement_list -> statement .)
    DEF             reduce using rule 3 (statement_list -> statement .)
    IF              reduce using rule 3 (statement_list -> statement .)
    THEN            reduce using rule 3 (statement_list -> statement .)
    NOT             reduce using rule 3 (statement_list -> statement .)
    NIL             reduce using rule 3 (statement_list -> statement .)
    TRUE            reduce using rule 3 (statement_list -> statement .)
    FALSE           reduce using rule 3 (statement_list -> statement .)
    LPAREN          reduce using rule 3 (statement_list -> statement .)
    INTEGER         reduce using rule 3 (statement_list -> statement .)
    FLOAT           reduce using rule 3 (statement_list -> statement .)
    RATIONAL        reduce using rule 3 (statement_list -> statement .)
    COMPLEX         reduce using rule 3 (statement_list -> statement .)
    STR             reduce using rule 3 (statement_list -> statement .)
    SYMBOL          reduce using rule 3 (statement_list -> statement .)
    REGEXP          reduce using rule 3 (statement_list -> statement .)
    MINUS           reduce using rule 3 (statement_list -> statement .)
    CLASS           reduce using rule 3 (statement_list -> statement .)
    INSTANCE_VAR    reduce using rule 3 (statement_list -> statement .)
    CLASS_VAR       reduce using rule 3 (statement_list -> statement .)
    GLOBAL_VAR      reduce using rule 3 (statement_list -> statement .)
    LOCAL_VAR       reduce using rule 3 (statement_list -> statement .)
    CONSTANT        reduce using rule 3 (statement_list -> statement .)
    LBRACKET        reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    RBRACE          reduce using rule 3 (statement_list -> statement .)
    END_S           reduce using rule 3 (statement_list -> statement .)

  ! BREAK           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NEXT            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSIF           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! ELSE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RETURN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PRINT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! PUTS            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! WHILE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FOR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! DEF             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! IF              [ reduce using rule 6 (stmt_block -> statement .) ]
  ! THEN            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NOT             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! NIL             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! TRUE            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FALSE           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LPAREN          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INTEGER         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! FLOAT           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RATIONAL        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! COMPLEX         [ reduce using rule 6 (stmt_block -> statement .) ]
  ! STR             [ reduce using rule 6 (stmt_block -> statement .) ]
  ! SYMBOL          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! REGEXP          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! MINUS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS           [ reduce using rule 6 (stmt_block -> statement .) ]
  ! INSTANCE_VAR    [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CLASS_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! GLOBAL_VAR      [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LOCAL_VAR       [ reduce using rule 6 (stmt_block -> statement .) ]
  ! CONSTANT        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! LBRACKET        [ reduce using rule 6 (stmt_block -> statement .) ]
  ! $end            [ reduce using rule 6 (stmt_block -> statement .) ]
  ! RBRACE          [ reduce using rule 6 (stmt_block -> statement .) ]
  ! END_S           [ reduce using rule 6 (stmt_block -> statement .) ]


state 81

    (8) stmt_block -> LBRACE . statement_list RBRACE
    (72) hash_literal -> LBRACE . hash_pairs_opt RBRACE
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (73) hash_pairs_opt -> .
    (74) hash_pairs_opt -> . hash_pairs
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (75) hash_pairs -> . hash_pairs COMMA hash_pair
    (76) hash_pairs -> . hash_pair
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (77) hash_pair -> . expression ARROW expression
    (78) hash_pair -> . SYMBOL COLON expression
    (79) hash_pair -> . LOCAL_VAR COLON expression
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for RBRACE resolved using rule 73 (hash_pairs_opt -> .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          reduce using rule 73 (hash_pairs_opt -> .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 141
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    LOCAL_VAR       shift and go to state 105
    GLOBAL_VAR      shift and go to state 54
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 100
    hash_pairs_opt                 shift and go to state 99
    statement                      shift and go to state 3
    hash_pairs                     shift and go to state 101
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 140
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    hash_pair                      shift and go to state 102
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 82

    (116) statement -> RETURN expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 116 (statement -> RETURN expression .)
    NEXT            reduce using rule 116 (statement -> RETURN expression .)
    ELSIF           reduce using rule 116 (statement -> RETURN expression .)
    ELSE            reduce using rule 116 (statement -> RETURN expression .)
    RETURN          reduce using rule 116 (statement -> RETURN expression .)
    PRINT           reduce using rule 116 (statement -> RETURN expression .)
    PUTS            reduce using rule 116 (statement -> RETURN expression .)
    WHILE           reduce using rule 116 (statement -> RETURN expression .)
    FOR             reduce using rule 116 (statement -> RETURN expression .)
    LBRACE          reduce using rule 116 (statement -> RETURN expression .)
    DEF             reduce using rule 116 (statement -> RETURN expression .)
    IF              reduce using rule 116 (statement -> RETURN expression .)
    THEN            reduce using rule 116 (statement -> RETURN expression .)
    NOT             reduce using rule 116 (statement -> RETURN expression .)
    NIL             reduce using rule 116 (statement -> RETURN expression .)
    TRUE            reduce using rule 116 (statement -> RETURN expression .)
    FALSE           reduce using rule 116 (statement -> RETURN expression .)
    LPAREN          reduce using rule 116 (statement -> RETURN expression .)
    INTEGER         reduce using rule 116 (statement -> RETURN expression .)
    FLOAT           reduce using rule 116 (statement -> RETURN expression .)
    RATIONAL        reduce using rule 116 (statement -> RETURN expression .)
    COMPLEX         reduce using rule 116 (statement -> RETURN expression .)
    STR             reduce using rule 116 (statement -> RETURN expression .)
    SYMBOL          reduce using rule 116 (statement -> RETURN expression .)
    REGEXP          reduce using rule 116 (statement -> RETURN expression .)
    CLASS           reduce using rule 116 (statement -> RETURN expression .)
    INSTANCE_VAR    reduce using rule 116 (statement -> RETURN expression .)
    CLASS_VAR       reduce using rule 116 (statement -> RETURN expression .)
    GLOBAL_VAR      reduce using rule 116 (statement -> RETURN expression .)
    LOCAL_VAR       reduce using rule 116 (statement -> RETURN expression .)
    CONSTANT        reduce using rule 116 (statement -> RETURN expression .)
    LBRACKET        reduce using rule 116 (statement -> RETURN expression .)
    $end            reduce using rule 116 (statement -> RETURN expression .)
    RBRACE          reduce using rule 116 (statement -> RETURN expression .)
    END_S           reduce using rule 116 (statement -> RETURN expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 116 (statement -> RETURN expression .) ]


state 83

    (23) print_stmt -> PRINT expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 23 (print_stmt -> PRINT expression .)
    NEXT            reduce using rule 23 (print_stmt -> PRINT expression .)
    ELSIF           reduce using rule 23 (print_stmt -> PRINT expression .)
    ELSE            reduce using rule 23 (print_stmt -> PRINT expression .)
    RETURN          reduce using rule 23 (print_stmt -> PRINT expression .)
    PRINT           reduce using rule 23 (print_stmt -> PRINT expression .)
    PUTS            reduce using rule 23 (print_stmt -> PRINT expression .)
    WHILE           reduce using rule 23 (print_stmt -> PRINT expression .)
    FOR             reduce using rule 23 (print_stmt -> PRINT expression .)
    LBRACE          reduce using rule 23 (print_stmt -> PRINT expression .)
    DEF             reduce using rule 23 (print_stmt -> PRINT expression .)
    IF              reduce using rule 23 (print_stmt -> PRINT expression .)
    THEN            reduce using rule 23 (print_stmt -> PRINT expression .)
    NOT             reduce using rule 23 (print_stmt -> PRINT expression .)
    NIL             reduce using rule 23 (print_stmt -> PRINT expression .)
    TRUE            reduce using rule 23 (print_stmt -> PRINT expression .)
    FALSE           reduce using rule 23 (print_stmt -> PRINT expression .)
    LPAREN          reduce using rule 23 (print_stmt -> PRINT expression .)
    INTEGER         reduce using rule 23 (print_stmt -> PRINT expression .)
    FLOAT           reduce using rule 23 (print_stmt -> PRINT expression .)
    RATIONAL        reduce using rule 23 (print_stmt -> PRINT expression .)
    COMPLEX         reduce using rule 23 (print_stmt -> PRINT expression .)
    STR             reduce using rule 23 (print_stmt -> PRINT expression .)
    SYMBOL          reduce using rule 23 (print_stmt -> PRINT expression .)
    REGEXP          reduce using rule 23 (print_stmt -> PRINT expression .)
    CLASS           reduce using rule 23 (print_stmt -> PRINT expression .)
    INSTANCE_VAR    reduce using rule 23 (print_stmt -> PRINT expression .)
    CLASS_VAR       reduce using rule 23 (print_stmt -> PRINT expression .)
    GLOBAL_VAR      reduce using rule 23 (print_stmt -> PRINT expression .)
    LOCAL_VAR       reduce using rule 23 (print_stmt -> PRINT expression .)
    CONSTANT        reduce using rule 23 (print_stmt -> PRINT expression .)
    LBRACKET        reduce using rule 23 (print_stmt -> PRINT expression .)
    $end            reduce using rule 23 (print_stmt -> PRINT expression .)
    RBRACE          reduce using rule 23 (print_stmt -> PRINT expression .)
    END_S           reduce using rule 23 (print_stmt -> PRINT expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 23 (print_stmt -> PRINT expression .) ]


state 84

    (24) print_stmt -> PUTS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 24 (print_stmt -> PUTS expression .)
    NEXT            reduce using rule 24 (print_stmt -> PUTS expression .)
    ELSIF           reduce using rule 24 (print_stmt -> PUTS expression .)
    ELSE            reduce using rule 24 (print_stmt -> PUTS expression .)
    RETURN          reduce using rule 24 (print_stmt -> PUTS expression .)
    PRINT           reduce using rule 24 (print_stmt -> PUTS expression .)
    PUTS            reduce using rule 24 (print_stmt -> PUTS expression .)
    WHILE           reduce using rule 24 (print_stmt -> PUTS expression .)
    FOR             reduce using rule 24 (print_stmt -> PUTS expression .)
    LBRACE          reduce using rule 24 (print_stmt -> PUTS expression .)
    DEF             reduce using rule 24 (print_stmt -> PUTS expression .)
    IF              reduce using rule 24 (print_stmt -> PUTS expression .)
    THEN            reduce using rule 24 (print_stmt -> PUTS expression .)
    NOT             reduce using rule 24 (print_stmt -> PUTS expression .)
    NIL             reduce using rule 24 (print_stmt -> PUTS expression .)
    TRUE            reduce using rule 24 (print_stmt -> PUTS expression .)
    FALSE           reduce using rule 24 (print_stmt -> PUTS expression .)
    LPAREN          reduce using rule 24 (print_stmt -> PUTS expression .)
    INTEGER         reduce using rule 24 (print_stmt -> PUTS expression .)
    FLOAT           reduce using rule 24 (print_stmt -> PUTS expression .)
    RATIONAL        reduce using rule 24 (print_stmt -> PUTS expression .)
    COMPLEX         reduce using rule 24 (print_stmt -> PUTS expression .)
    STR             reduce using rule 24 (print_stmt -> PUTS expression .)
    SYMBOL          reduce using rule 24 (print_stmt -> PUTS expression .)
    REGEXP          reduce using rule 24 (print_stmt -> PUTS expression .)
    CLASS           reduce using rule 24 (print_stmt -> PUTS expression .)
    INSTANCE_VAR    reduce using rule 24 (print_stmt -> PUTS expression .)
    CLASS_VAR       reduce using rule 24 (print_stmt -> PUTS expression .)
    GLOBAL_VAR      reduce using rule 24 (print_stmt -> PUTS expression .)
    LOCAL_VAR       reduce using rule 24 (print_stmt -> PUTS expression .)
    CONSTANT        reduce using rule 24 (print_stmt -> PUTS expression .)
    LBRACKET        reduce using rule 24 (print_stmt -> PUTS expression .)
    $end            reduce using rule 24 (print_stmt -> PUTS expression .)
    RBRACE          reduce using rule 24 (print_stmt -> PUTS expression .)
    END_S           reduce using rule 24 (print_stmt -> PUTS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 24 (print_stmt -> PUTS expression .) ]


state 85

    (25) input_stmt -> variable EQLS . LOCAL_VAR
    (31) assignment -> variable EQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    LOCAL_VAR       shift and go to state 142
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 143
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 86

    (32) assignment -> variable PLUSEQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 144
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 87

    (33) assignment -> variable MINUSEQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 145
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 88

    (34) assignment -> variable MULTEQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 146
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 89

    (35) assignment -> variable DIVEQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 147
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 90

    (36) assignment -> variable MODEQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 148
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 91

    (37) assignment -> variable POWEREQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    variable                       shift and go to state 74
    expression                     shift and go to state 149
    hash_literal                   shift and go to state 73
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 92

    (97) expr_postfix -> LOCAL_VAR LPAREN . RPAREN
    (98) expr_postfix -> LOCAL_VAR LPAREN . expr_list RPAREN
    (83) expr_list -> . expression
    (84) expr_list -> . expression COMMA expr_list
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    RPAREN          shift and go to state 150
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expr_list                      shift and go to state 151
    expression                     shift and go to state 114
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 93

    (102) assignment -> expr_postfix EQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expr_postfix                   shift and go to state 75
    expression                     shift and go to state 152
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 94

    (99) expr_postfix -> expr_postfix LBRACKET . expression RBRACKET
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expr_postfix                   shift and go to state 75
    expression                     shift and go to state 153
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 95

    (146) expr_postfix -> expr_postfix DOT . LOCAL_VAR
    (147) expr_postfix -> expr_postfix DOT . LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> expr_postfix DOT . LOCAL_VAR LPAREN expr_list RPAREN

    LOCAL_VAR       shift and go to state 154


state 96

    (38) while_stmt -> WHILE expression_logic . while_enter DO statement_list END_S while_exit
    (39) while_stmt -> WHILE expression_logic . while_enter statement_list END_S while_exit
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic
    (40) while_enter -> .

    ANDAND          shift and go to state 125
    OROR            shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128
    DO              reduce using rule 40 (while_enter -> .)
    BREAK           reduce using rule 40 (while_enter -> .)
    NEXT            reduce using rule 40 (while_enter -> .)
    ELSIF           reduce using rule 40 (while_enter -> .)
    ELSE            reduce using rule 40 (while_enter -> .)
    RETURN          reduce using rule 40 (while_enter -> .)
    PRINT           reduce using rule 40 (while_enter -> .)
    PUTS            reduce using rule 40 (while_enter -> .)
    WHILE           reduce using rule 40 (while_enter -> .)
    FOR             reduce using rule 40 (while_enter -> .)
    LBRACE          reduce using rule 40 (while_enter -> .)
    DEF             reduce using rule 40 (while_enter -> .)
    IF              reduce using rule 40 (while_enter -> .)
    THEN            reduce using rule 40 (while_enter -> .)
    NOT             reduce using rule 40 (while_enter -> .)
    NIL             reduce using rule 40 (while_enter -> .)
    TRUE            reduce using rule 40 (while_enter -> .)
    FALSE           reduce using rule 40 (while_enter -> .)
    LPAREN          reduce using rule 40 (while_enter -> .)
    INTEGER         reduce using rule 40 (while_enter -> .)
    FLOAT           reduce using rule 40 (while_enter -> .)
    RATIONAL        reduce using rule 40 (while_enter -> .)
    COMPLEX         reduce using rule 40 (while_enter -> .)
    STR             reduce using rule 40 (while_enter -> .)
    SYMBOL          reduce using rule 40 (while_enter -> .)
    REGEXP          reduce using rule 40 (while_enter -> .)
    MINUS           reduce using rule 40 (while_enter -> .)
    CLASS           reduce using rule 40 (while_enter -> .)
    INSTANCE_VAR    reduce using rule 40 (while_enter -> .)
    CLASS_VAR       reduce using rule 40 (while_enter -> .)
    GLOBAL_VAR      reduce using rule 40 (while_enter -> .)
    LOCAL_VAR       reduce using rule 40 (while_enter -> .)
    CONSTANT        reduce using rule 40 (while_enter -> .)
    LBRACKET        reduce using rule 40 (while_enter -> .)
    END_S           reduce using rule 40 (while_enter -> .)

    while_enter                    shift and go to state 155

state 97

    (62) expression_compare -> expression . LT expression
    (63) expression_compare -> expression . LE expression
    (64) expression_compare -> expression . GT expression
    (65) expression_compare -> expression . GE expression
    (66) expression_compare -> expression . EQ expression
    (67) expression_compare -> expression . NE expression
    (68) expression_compare -> expression . EQQ expression
    (69) expression_compare -> expression . MATCH expression
    (70) expression_compare -> expression . NMATCH expression
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    LT              shift and go to state 130
    LE              shift and go to state 131
    GT              shift and go to state 132
    GE              shift and go to state 133
    EQ              shift and go to state 134
    NE              shift and go to state 135
    EQQ             shift and go to state 136
    MATCH           shift and go to state 137
    NMATCH          shift and go to state 138
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 98

    (42) for_stmt -> FOR LOCAL_VAR . IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> FOR LOCAL_VAR . IN expression for_enter statement_list END_S for_exit

    IN              shift and go to state 156


state 99

    (72) hash_literal -> LBRACE hash_pairs_opt . RBRACE

    RBRACE          shift and go to state 157


state 100

    (8) stmt_block -> LBRACE statement_list . RBRACE
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACE          shift and go to state 158
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 101

    (74) hash_pairs_opt -> hash_pairs .
    (75) hash_pairs -> hash_pairs . COMMA hash_pair

    RBRACE          reduce using rule 74 (hash_pairs_opt -> hash_pairs .)
    COMMA           shift and go to state 159


state 102

    (76) hash_pairs -> hash_pair .

    COMMA           reduce using rule 76 (hash_pairs -> hash_pair .)
    RBRACE          reduce using rule 76 (hash_pairs -> hash_pair .)


state 103

    (22) statement -> expression .
    (77) hash_pair -> expression . ARROW expression
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 22 (statement -> expression .)
    NEXT            reduce using rule 22 (statement -> expression .)
    ELSIF           reduce using rule 22 (statement -> expression .)
    ELSE            reduce using rule 22 (statement -> expression .)
    RETURN          reduce using rule 22 (statement -> expression .)
    PRINT           reduce using rule 22 (statement -> expression .)
    PUTS            reduce using rule 22 (statement -> expression .)
    WHILE           reduce using rule 22 (statement -> expression .)
    FOR             reduce using rule 22 (statement -> expression .)
    LBRACE          reduce using rule 22 (statement -> expression .)
    DEF             reduce using rule 22 (statement -> expression .)
    IF              reduce using rule 22 (statement -> expression .)
    THEN            reduce using rule 22 (statement -> expression .)
    NOT             reduce using rule 22 (statement -> expression .)
    NIL             reduce using rule 22 (statement -> expression .)
    TRUE            reduce using rule 22 (statement -> expression .)
    FALSE           reduce using rule 22 (statement -> expression .)
    LPAREN          reduce using rule 22 (statement -> expression .)
    INTEGER         reduce using rule 22 (statement -> expression .)
    FLOAT           reduce using rule 22 (statement -> expression .)
    RATIONAL        reduce using rule 22 (statement -> expression .)
    COMPLEX         reduce using rule 22 (statement -> expression .)
    STR             reduce using rule 22 (statement -> expression .)
    SYMBOL          reduce using rule 22 (statement -> expression .)
    REGEXP          reduce using rule 22 (statement -> expression .)
    CLASS           reduce using rule 22 (statement -> expression .)
    INSTANCE_VAR    reduce using rule 22 (statement -> expression .)
    CLASS_VAR       reduce using rule 22 (statement -> expression .)
    GLOBAL_VAR      reduce using rule 22 (statement -> expression .)
    LOCAL_VAR       reduce using rule 22 (statement -> expression .)
    CONSTANT        reduce using rule 22 (statement -> expression .)
    LBRACKET        reduce using rule 22 (statement -> expression .)
    RBRACE          reduce using rule 22 (statement -> expression .)
    ARROW           shift and go to state 160
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 22 (statement -> expression .) ]


state 104

    (78) hash_pair -> SYMBOL . COLON expression
    (142) expression -> SYMBOL .
    (90) primary -> SYMBOL .

  ! reduce/reduce conflict for LBRACKET resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ARROW resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PLUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MINUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MULT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DIV resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MOD resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for POWER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for BREAK resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NEXT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSIF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RETURN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PRINT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PUTS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for WHILE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FOR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LBRACE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DEF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for IF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for THEN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NOT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NIL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for TRUE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FALSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LPAREN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INTEGER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for STR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for REGEXP resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RBRACE resolved using rule 90 (primary -> SYMBOL .)
    COLON           shift and go to state 161
    EQLS            reduce using rule 90 (primary -> SYMBOL .)
    LBRACKET        reduce using rule 90 (primary -> SYMBOL .)
    DOT             reduce using rule 90 (primary -> SYMBOL .)
    ARROW           reduce using rule 90 (primary -> SYMBOL .)
    RANGE_INCL      reduce using rule 90 (primary -> SYMBOL .)
    RANGE_EXCL      reduce using rule 90 (primary -> SYMBOL .)
    PLUS            reduce using rule 90 (primary -> SYMBOL .)
    MINUS           reduce using rule 90 (primary -> SYMBOL .)
    MULT            reduce using rule 90 (primary -> SYMBOL .)
    DIV             reduce using rule 90 (primary -> SYMBOL .)
    MOD             reduce using rule 90 (primary -> SYMBOL .)
    POWER           reduce using rule 90 (primary -> SYMBOL .)
    BREAK           reduce using rule 90 (primary -> SYMBOL .)
    NEXT            reduce using rule 90 (primary -> SYMBOL .)
    ELSIF           reduce using rule 90 (primary -> SYMBOL .)
    ELSE            reduce using rule 90 (primary -> SYMBOL .)
    RETURN          reduce using rule 90 (primary -> SYMBOL .)
    PRINT           reduce using rule 90 (primary -> SYMBOL .)
    PUTS            reduce using rule 90 (primary -> SYMBOL .)
    WHILE           reduce using rule 90 (primary -> SYMBOL .)
    FOR             reduce using rule 90 (primary -> SYMBOL .)
    LBRACE          reduce using rule 90 (primary -> SYMBOL .)
    DEF             reduce using rule 90 (primary -> SYMBOL .)
    IF              reduce using rule 90 (primary -> SYMBOL .)
    THEN            reduce using rule 90 (primary -> SYMBOL .)
    NOT             reduce using rule 90 (primary -> SYMBOL .)
    NIL             reduce using rule 90 (primary -> SYMBOL .)
    TRUE            reduce using rule 90 (primary -> SYMBOL .)
    FALSE           reduce using rule 90 (primary -> SYMBOL .)
    LPAREN          reduce using rule 90 (primary -> SYMBOL .)
    INTEGER         reduce using rule 90 (primary -> SYMBOL .)
    FLOAT           reduce using rule 90 (primary -> SYMBOL .)
    RATIONAL        reduce using rule 90 (primary -> SYMBOL .)
    COMPLEX         reduce using rule 90 (primary -> SYMBOL .)
    STR             reduce using rule 90 (primary -> SYMBOL .)
    SYMBOL          reduce using rule 90 (primary -> SYMBOL .)
    REGEXP          reduce using rule 90 (primary -> SYMBOL .)
    CLASS           reduce using rule 90 (primary -> SYMBOL .)
    INSTANCE_VAR    reduce using rule 90 (primary -> SYMBOL .)
    CLASS_VAR       reduce using rule 90 (primary -> SYMBOL .)
    GLOBAL_VAR      reduce using rule 90 (primary -> SYMBOL .)
    LOCAL_VAR       reduce using rule 90 (primary -> SYMBOL .)
    CONSTANT        reduce using rule 90 (primary -> SYMBOL .)
    RBRACE          reduce using rule 90 (primary -> SYMBOL .)

  ! ARROW           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RANGE_INCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RANGE_EXCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PLUS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MINUS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MULT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DIV             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MOD             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! POWER           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! BREAK           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NEXT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSIF           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RETURN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PRINT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PUTS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! WHILE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FOR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DEF             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! IF              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! THEN            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NOT             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NIL             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! TRUE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FALSE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LPAREN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INTEGER         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FLOAT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RATIONAL        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! COMPLEX         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! STR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! SYMBOL          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! REGEXP          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INSTANCE_VAR    [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! GLOBAL_VAR      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LOCAL_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CONSTANT        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACKET        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]


state 105

    (79) hash_pair -> LOCAL_VAR . COLON expression
    (27) variable -> LOCAL_VAR .
    (97) expr_postfix -> LOCAL_VAR . LPAREN RPAREN
    (98) expr_postfix -> LOCAL_VAR . LPAREN expr_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    COLON           shift and go to state 162
    EQLS            reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUSEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUSEQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    MULTEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    DIVEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    MODEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    POWEREQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    ARROW           reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_INCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_EXCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUS            reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUS           reduce using rule 27 (variable -> LOCAL_VAR .)
    MULT            reduce using rule 27 (variable -> LOCAL_VAR .)
    DIV             reduce using rule 27 (variable -> LOCAL_VAR .)
    MOD             reduce using rule 27 (variable -> LOCAL_VAR .)
    POWER           reduce using rule 27 (variable -> LOCAL_VAR .)
    BREAK           reduce using rule 27 (variable -> LOCAL_VAR .)
    NEXT            reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSIF           reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSE            reduce using rule 27 (variable -> LOCAL_VAR .)
    RETURN          reduce using rule 27 (variable -> LOCAL_VAR .)
    PRINT           reduce using rule 27 (variable -> LOCAL_VAR .)
    PUTS            reduce using rule 27 (variable -> LOCAL_VAR .)
    WHILE           reduce using rule 27 (variable -> LOCAL_VAR .)
    FOR             reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACE          reduce using rule 27 (variable -> LOCAL_VAR .)
    DEF             reduce using rule 27 (variable -> LOCAL_VAR .)
    IF              reduce using rule 27 (variable -> LOCAL_VAR .)
    THEN            reduce using rule 27 (variable -> LOCAL_VAR .)
    NOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    NIL             reduce using rule 27 (variable -> LOCAL_VAR .)
    TRUE            reduce using rule 27 (variable -> LOCAL_VAR .)
    FALSE           reduce using rule 27 (variable -> LOCAL_VAR .)
    INTEGER         reduce using rule 27 (variable -> LOCAL_VAR .)
    FLOAT           reduce using rule 27 (variable -> LOCAL_VAR .)
    RATIONAL        reduce using rule 27 (variable -> LOCAL_VAR .)
    COMPLEX         reduce using rule 27 (variable -> LOCAL_VAR .)
    STR             reduce using rule 27 (variable -> LOCAL_VAR .)
    SYMBOL          reduce using rule 27 (variable -> LOCAL_VAR .)
    REGEXP          reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS           reduce using rule 27 (variable -> LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 27 (variable -> LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    CONSTANT        reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACKET        reduce using rule 27 (variable -> LOCAL_VAR .)
    RBRACE          reduce using rule 27 (variable -> LOCAL_VAR .)
    DOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    LPAREN          shift and go to state 92

  ! LPAREN          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]


state 106

    (103) function_def -> DEF LOCAL_VAR . statement_list END_S
    (104) function_def -> DEF LOCAL_VAR . LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> DEF LOCAL_VAR . optional_params optional_ret statement_list END_S
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (105) optional_params -> . param_list
    (106) optional_params -> . empty
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (107) param_list -> . parameter
    (108) param_list -> . param_list COMMA parameter
    (111) empty -> .
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (109) parameter -> . LOCAL_VAR
    (110) parameter -> . LOCAL_VAR EQLS expression
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 165
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    COLON           reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    LOCAL_VAR       shift and go to state 163
    GLOBAL_VAR      shift and go to state 54
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 164
    param_list                     shift and go to state 166
    optional_params                shift and go to state 167
    statement                      shift and go to state 3
    empty                          shift and go to state 168
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    parameter                      shift and go to state 169
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 107

    (136) expression -> LPAREN expression . RPAREN
    (95) primary -> LPAREN expression . RPAREN
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RPAREN          shift and go to state 170
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 108

    (46) if_stmt -> IF expression_logic . optional_then stmt_block elsif_list else_part END_S
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (111) empty -> .

  ! shift/reduce conflict for THEN resolved as shift
    ANDAND          shift and go to state 125
    OROR            shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128
    THEN            shift and go to state 36
    LBRACE          reduce using rule 111 (empty -> .)
    BREAK           reduce using rule 111 (empty -> .)
    NEXT            reduce using rule 111 (empty -> .)
    ELSIF           reduce using rule 111 (empty -> .)
    ELSE            reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    PUTS            reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    DEF             reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    NOT             reduce using rule 111 (empty -> .)
    NIL             reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)
    INTEGER         reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    RATIONAL        reduce using rule 111 (empty -> .)
    COMPLEX         reduce using rule 111 (empty -> .)
    STR             reduce using rule 111 (empty -> .)
    SYMBOL          reduce using rule 111 (empty -> .)
    REGEXP          reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    CLASS           reduce using rule 111 (empty -> .)
    INSTANCE_VAR    reduce using rule 111 (empty -> .)
    CLASS_VAR       reduce using rule 111 (empty -> .)
    GLOBAL_VAR      reduce using rule 111 (empty -> .)
    LOCAL_VAR       reduce using rule 111 (empty -> .)
    CONSTANT        reduce using rule 111 (empty -> .)
    LBRACKET        reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)

  ! THEN            [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 171
    empty                          shift and go to state 129

state 109

    (71) expression -> NOT expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCL resolved as shift
  ! shift/reduce conflict for RANGE_EXCL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    BREAK           reduce using rule 71 (expression -> NOT expression .)
    NEXT            reduce using rule 71 (expression -> NOT expression .)
    ELSIF           reduce using rule 71 (expression -> NOT expression .)
    ELSE            reduce using rule 71 (expression -> NOT expression .)
    RETURN          reduce using rule 71 (expression -> NOT expression .)
    PRINT           reduce using rule 71 (expression -> NOT expression .)
    PUTS            reduce using rule 71 (expression -> NOT expression .)
    WHILE           reduce using rule 71 (expression -> NOT expression .)
    FOR             reduce using rule 71 (expression -> NOT expression .)
    LBRACE          reduce using rule 71 (expression -> NOT expression .)
    DEF             reduce using rule 71 (expression -> NOT expression .)
    IF              reduce using rule 71 (expression -> NOT expression .)
    THEN            reduce using rule 71 (expression -> NOT expression .)
    NOT             reduce using rule 71 (expression -> NOT expression .)
    NIL             reduce using rule 71 (expression -> NOT expression .)
    TRUE            reduce using rule 71 (expression -> NOT expression .)
    FALSE           reduce using rule 71 (expression -> NOT expression .)
    LPAREN          reduce using rule 71 (expression -> NOT expression .)
    INTEGER         reduce using rule 71 (expression -> NOT expression .)
    FLOAT           reduce using rule 71 (expression -> NOT expression .)
    RATIONAL        reduce using rule 71 (expression -> NOT expression .)
    COMPLEX         reduce using rule 71 (expression -> NOT expression .)
    STR             reduce using rule 71 (expression -> NOT expression .)
    SYMBOL          reduce using rule 71 (expression -> NOT expression .)
    REGEXP          reduce using rule 71 (expression -> NOT expression .)
    CLASS           reduce using rule 71 (expression -> NOT expression .)
    INSTANCE_VAR    reduce using rule 71 (expression -> NOT expression .)
    CLASS_VAR       reduce using rule 71 (expression -> NOT expression .)
    GLOBAL_VAR      reduce using rule 71 (expression -> NOT expression .)
    LOCAL_VAR       reduce using rule 71 (expression -> NOT expression .)
    CONSTANT        reduce using rule 71 (expression -> NOT expression .)
    LBRACKET        reduce using rule 71 (expression -> NOT expression .)
    $end            reduce using rule 71 (expression -> NOT expression .)
    RBRACE          reduce using rule 71 (expression -> NOT expression .)
    END_S           reduce using rule 71 (expression -> NOT expression .)
    LT              reduce using rule 71 (expression -> NOT expression .)
    LE              reduce using rule 71 (expression -> NOT expression .)
    GT              reduce using rule 71 (expression -> NOT expression .)
    GE              reduce using rule 71 (expression -> NOT expression .)
    EQ              reduce using rule 71 (expression -> NOT expression .)
    NE              reduce using rule 71 (expression -> NOT expression .)
    EQQ             reduce using rule 71 (expression -> NOT expression .)
    MATCH           reduce using rule 71 (expression -> NOT expression .)
    NMATCH          reduce using rule 71 (expression -> NOT expression .)
    ARROW           reduce using rule 71 (expression -> NOT expression .)
    RPAREN          reduce using rule 71 (expression -> NOT expression .)
    COMMA           reduce using rule 71 (expression -> NOT expression .)
    RBRACKET        reduce using rule 71 (expression -> NOT expression .)
    ANDAND          reduce using rule 71 (expression -> NOT expression .)
    OROR            reduce using rule 71 (expression -> NOT expression .)
    AND             reduce using rule 71 (expression -> NOT expression .)
    OR              reduce using rule 71 (expression -> NOT expression .)
    DO              reduce using rule 71 (expression -> NOT expression .)
    COLON           reduce using rule 71 (expression -> NOT expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! RANGE_INCL      [ reduce using rule 71 (expression -> NOT expression .) ]
  ! RANGE_EXCL      [ reduce using rule 71 (expression -> NOT expression .) ]
  ! PLUS            [ reduce using rule 71 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> NOT expression .) ]
  ! MULT            [ reduce using rule 71 (expression -> NOT expression .) ]
  ! DIV             [ reduce using rule 71 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 71 (expression -> NOT expression .) ]
  ! POWER           [ reduce using rule 71 (expression -> NOT expression .) ]


state 110

    (149) expression -> MINUS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 149 (expression -> MINUS expression .)
    RANGE_EXCL      reduce using rule 149 (expression -> MINUS expression .)
    PLUS            reduce using rule 149 (expression -> MINUS expression .)
    MINUS           reduce using rule 149 (expression -> MINUS expression .)
    MULT            reduce using rule 149 (expression -> MINUS expression .)
    DIV             reduce using rule 149 (expression -> MINUS expression .)
    MOD             reduce using rule 149 (expression -> MINUS expression .)
    POWER           reduce using rule 149 (expression -> MINUS expression .)
    BREAK           reduce using rule 149 (expression -> MINUS expression .)
    NEXT            reduce using rule 149 (expression -> MINUS expression .)
    ELSIF           reduce using rule 149 (expression -> MINUS expression .)
    ELSE            reduce using rule 149 (expression -> MINUS expression .)
    RETURN          reduce using rule 149 (expression -> MINUS expression .)
    PRINT           reduce using rule 149 (expression -> MINUS expression .)
    PUTS            reduce using rule 149 (expression -> MINUS expression .)
    WHILE           reduce using rule 149 (expression -> MINUS expression .)
    FOR             reduce using rule 149 (expression -> MINUS expression .)
    LBRACE          reduce using rule 149 (expression -> MINUS expression .)
    DEF             reduce using rule 149 (expression -> MINUS expression .)
    IF              reduce using rule 149 (expression -> MINUS expression .)
    THEN            reduce using rule 149 (expression -> MINUS expression .)
    NOT             reduce using rule 149 (expression -> MINUS expression .)
    NIL             reduce using rule 149 (expression -> MINUS expression .)
    TRUE            reduce using rule 149 (expression -> MINUS expression .)
    FALSE           reduce using rule 149 (expression -> MINUS expression .)
    LPAREN          reduce using rule 149 (expression -> MINUS expression .)
    INTEGER         reduce using rule 149 (expression -> MINUS expression .)
    FLOAT           reduce using rule 149 (expression -> MINUS expression .)
    RATIONAL        reduce using rule 149 (expression -> MINUS expression .)
    COMPLEX         reduce using rule 149 (expression -> MINUS expression .)
    STR             reduce using rule 149 (expression -> MINUS expression .)
    SYMBOL          reduce using rule 149 (expression -> MINUS expression .)
    REGEXP          reduce using rule 149 (expression -> MINUS expression .)
    CLASS           reduce using rule 149 (expression -> MINUS expression .)
    INSTANCE_VAR    reduce using rule 149 (expression -> MINUS expression .)
    CLASS_VAR       reduce using rule 149 (expression -> MINUS expression .)
    GLOBAL_VAR      reduce using rule 149 (expression -> MINUS expression .)
    LOCAL_VAR       reduce using rule 149 (expression -> MINUS expression .)
    CONSTANT        reduce using rule 149 (expression -> MINUS expression .)
    LBRACKET        reduce using rule 149 (expression -> MINUS expression .)
    $end            reduce using rule 149 (expression -> MINUS expression .)
    RBRACE          reduce using rule 149 (expression -> MINUS expression .)
    END_S           reduce using rule 149 (expression -> MINUS expression .)
    LT              reduce using rule 149 (expression -> MINUS expression .)
    LE              reduce using rule 149 (expression -> MINUS expression .)
    GT              reduce using rule 149 (expression -> MINUS expression .)
    GE              reduce using rule 149 (expression -> MINUS expression .)
    EQ              reduce using rule 149 (expression -> MINUS expression .)
    NE              reduce using rule 149 (expression -> MINUS expression .)
    EQQ             reduce using rule 149 (expression -> MINUS expression .)
    MATCH           reduce using rule 149 (expression -> MINUS expression .)
    NMATCH          reduce using rule 149 (expression -> MINUS expression .)
    ARROW           reduce using rule 149 (expression -> MINUS expression .)
    RPAREN          reduce using rule 149 (expression -> MINUS expression .)
    COMMA           reduce using rule 149 (expression -> MINUS expression .)
    RBRACKET        reduce using rule 149 (expression -> MINUS expression .)
    ANDAND          reduce using rule 149 (expression -> MINUS expression .)
    OROR            reduce using rule 149 (expression -> MINUS expression .)
    AND             reduce using rule 149 (expression -> MINUS expression .)
    OR              reduce using rule 149 (expression -> MINUS expression .)
    DO              reduce using rule 149 (expression -> MINUS expression .)
    COLON           reduce using rule 149 (expression -> MINUS expression .)

  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! MULT            [ shift and go to state 66 ]
  ! DIV             [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]
  ! POWER           [ shift and go to state 69 ]


state 111

    (120) class_def -> CLASS CONSTANT . stmt_block END_S
    (121) class_def -> CLASS CONSTANT . opt_inherit stmt_block END_S
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (122) opt_inherit -> . LT CONSTANT
    (123) opt_inherit -> . empty
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (111) empty -> .
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    LT              shift and go to state 174
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    END_S           reduce using rule 111 (empty -> .)
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 172
    opt_inherit                    shift and go to state 173
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    empty                          shift and go to state 175
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 112

    (85) array_literal -> LBRACKET RBRACKET .

    EQLS            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    DOT             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RANGE_INCL      reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RANGE_EXCL      reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    MULT            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    DIV             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    MOD             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    POWER           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    BREAK           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    NEXT            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    ELSIF           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    PRINT           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    PUTS            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    FOR             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LBRACE          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    DEF             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    IF              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    THEN            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    NOT             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    NIL             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    TRUE            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    FALSE           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    INTEGER         reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    FLOAT           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RATIONAL        reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    COMPLEX         reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    STR             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    SYMBOL          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    REGEXP          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    INSTANCE_VAR    reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    CLASS_VAR       reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    GLOBAL_VAR      reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LOCAL_VAR       reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    CONSTANT        reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    $end            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RBRACE          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    END_S           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LT              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    LE              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    GT              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    GE              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    EQ              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    NE              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    EQQ             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    MATCH           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    NMATCH          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    ARROW           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    ANDAND          reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    OROR            reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    AND             reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    OR              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    DO              reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)
    COLON           reduce using rule 85 (array_literal -> LBRACKET RBRACKET .)


state 113

    (86) array_literal -> LBRACKET expr_list . RBRACKET

    RBRACKET        shift and go to state 176


state 114

    (83) expr_list -> expression .
    (84) expr_list -> expression . COMMA expr_list
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RBRACKET        reduce using rule 83 (expr_list -> expression .)
    RPAREN          reduce using rule 83 (expr_list -> expression .)
    COMMA           shift and go to state 177
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 115

    (50) elsif_list -> elsif_list ELSIF expression_logic . optional_then stmt_block
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (111) empty -> .

  ! shift/reduce conflict for THEN resolved as shift
    ANDAND          shift and go to state 125
    OROR            shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128
    THEN            shift and go to state 36
    LBRACE          reduce using rule 111 (empty -> .)
    BREAK           reduce using rule 111 (empty -> .)
    NEXT            reduce using rule 111 (empty -> .)
    ELSIF           reduce using rule 111 (empty -> .)
    ELSE            reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    PUTS            reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    DEF             reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    NOT             reduce using rule 111 (empty -> .)
    NIL             reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)
    INTEGER         reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    RATIONAL        reduce using rule 111 (empty -> .)
    COMPLEX         reduce using rule 111 (empty -> .)
    STR             reduce using rule 111 (empty -> .)
    SYMBOL          reduce using rule 111 (empty -> .)
    REGEXP          reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    CLASS           reduce using rule 111 (empty -> .)
    INSTANCE_VAR    reduce using rule 111 (empty -> .)
    CLASS_VAR       reduce using rule 111 (empty -> .)
    GLOBAL_VAR      reduce using rule 111 (empty -> .)
    LOCAL_VAR       reduce using rule 111 (empty -> .)
    CONSTANT        reduce using rule 111 (empty -> .)
    LBRACKET        reduce using rule 111 (empty -> .)
    $end            reduce using rule 111 (empty -> .)
    RBRACE          reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)

  ! THEN            [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 178
    empty                          shift and go to state 129

state 116

    (81) expression -> expression RANGE_INCL expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCL resolved as shift
  ! shift/reduce conflict for RANGE_EXCL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    BREAK           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    NEXT            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    ELSIF           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    ELSE            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RETURN          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    PRINT           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    PUTS            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    WHILE           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    FOR             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LBRACE          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    DEF             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    IF              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    THEN            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    NOT             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    NIL             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    TRUE            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    FALSE           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LPAREN          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    INTEGER         reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    FLOAT           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RATIONAL        reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    COMPLEX         reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    STR             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    SYMBOL          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    REGEXP          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    CLASS           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    INSTANCE_VAR    reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    CLASS_VAR       reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    GLOBAL_VAR      reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LOCAL_VAR       reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    CONSTANT        reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LBRACKET        reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    $end            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RBRACE          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    END_S           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LT              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    LE              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    GT              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    GE              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    EQ              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    NE              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    EQQ             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    MATCH           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    NMATCH          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    ARROW           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RPAREN          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    COMMA           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RBRACKET        reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    ANDAND          reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    OROR            reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    AND             reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    OR              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    DO              reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    COLON           reduce using rule 81 (expression -> expression RANGE_INCL expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! RANGE_INCL      [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! RANGE_EXCL      [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! PLUS            [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! MINUS           [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! MULT            [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! DIV             [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! MOD             [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]
  ! POWER           [ reduce using rule 81 (expression -> expression RANGE_INCL expression .) ]


state 117

    (82) expression -> expression RANGE_EXCL expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for RANGE_INCL resolved as shift
  ! shift/reduce conflict for RANGE_EXCL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULT resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
    BREAK           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    NEXT            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    ELSIF           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    ELSE            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RETURN          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    PRINT           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    PUTS            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    WHILE           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    FOR             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LBRACE          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    DEF             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    IF              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    THEN            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    NOT             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    NIL             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    TRUE            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    FALSE           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LPAREN          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    INTEGER         reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    FLOAT           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RATIONAL        reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    COMPLEX         reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    STR             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    SYMBOL          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    REGEXP          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    CLASS           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    INSTANCE_VAR    reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    CLASS_VAR       reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    GLOBAL_VAR      reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LOCAL_VAR       reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    CONSTANT        reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LBRACKET        reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    $end            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RBRACE          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    END_S           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LT              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    LE              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    GT              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    GE              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    EQ              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    NE              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    EQQ             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    MATCH           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    NMATCH          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    ARROW           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RPAREN          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    COMMA           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RBRACKET        reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    ANDAND          reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    OROR            reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    AND             reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    OR              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    DO              reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    COLON           reduce using rule 82 (expression -> expression RANGE_EXCL expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! RANGE_INCL      [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! RANGE_EXCL      [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! PLUS            [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! MINUS           [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! MULT            [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! DIV             [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! MOD             [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]
  ! POWER           [ reduce using rule 82 (expression -> expression RANGE_EXCL expression .) ]


state 118

    (130) expression -> expression PLUS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 130 (expression -> expression PLUS expression .)
    RANGE_EXCL      reduce using rule 130 (expression -> expression PLUS expression .)
    PLUS            reduce using rule 130 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 130 (expression -> expression PLUS expression .)
    BREAK           reduce using rule 130 (expression -> expression PLUS expression .)
    NEXT            reduce using rule 130 (expression -> expression PLUS expression .)
    ELSIF           reduce using rule 130 (expression -> expression PLUS expression .)
    ELSE            reduce using rule 130 (expression -> expression PLUS expression .)
    RETURN          reduce using rule 130 (expression -> expression PLUS expression .)
    PRINT           reduce using rule 130 (expression -> expression PLUS expression .)
    PUTS            reduce using rule 130 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 130 (expression -> expression PLUS expression .)
    FOR             reduce using rule 130 (expression -> expression PLUS expression .)
    LBRACE          reduce using rule 130 (expression -> expression PLUS expression .)
    DEF             reduce using rule 130 (expression -> expression PLUS expression .)
    IF              reduce using rule 130 (expression -> expression PLUS expression .)
    THEN            reduce using rule 130 (expression -> expression PLUS expression .)
    NOT             reduce using rule 130 (expression -> expression PLUS expression .)
    NIL             reduce using rule 130 (expression -> expression PLUS expression .)
    TRUE            reduce using rule 130 (expression -> expression PLUS expression .)
    FALSE           reduce using rule 130 (expression -> expression PLUS expression .)
    LPAREN          reduce using rule 130 (expression -> expression PLUS expression .)
    INTEGER         reduce using rule 130 (expression -> expression PLUS expression .)
    FLOAT           reduce using rule 130 (expression -> expression PLUS expression .)
    RATIONAL        reduce using rule 130 (expression -> expression PLUS expression .)
    COMPLEX         reduce using rule 130 (expression -> expression PLUS expression .)
    STR             reduce using rule 130 (expression -> expression PLUS expression .)
    SYMBOL          reduce using rule 130 (expression -> expression PLUS expression .)
    REGEXP          reduce using rule 130 (expression -> expression PLUS expression .)
    CLASS           reduce using rule 130 (expression -> expression PLUS expression .)
    INSTANCE_VAR    reduce using rule 130 (expression -> expression PLUS expression .)
    CLASS_VAR       reduce using rule 130 (expression -> expression PLUS expression .)
    GLOBAL_VAR      reduce using rule 130 (expression -> expression PLUS expression .)
    LOCAL_VAR       reduce using rule 130 (expression -> expression PLUS expression .)
    CONSTANT        reduce using rule 130 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 130 (expression -> expression PLUS expression .)
    $end            reduce using rule 130 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 130 (expression -> expression PLUS expression .)
    END_S           reduce using rule 130 (expression -> expression PLUS expression .)
    LT              reduce using rule 130 (expression -> expression PLUS expression .)
    LE              reduce using rule 130 (expression -> expression PLUS expression .)
    GT              reduce using rule 130 (expression -> expression PLUS expression .)
    GE              reduce using rule 130 (expression -> expression PLUS expression .)
    EQ              reduce using rule 130 (expression -> expression PLUS expression .)
    NE              reduce using rule 130 (expression -> expression PLUS expression .)
    EQQ             reduce using rule 130 (expression -> expression PLUS expression .)
    MATCH           reduce using rule 130 (expression -> expression PLUS expression .)
    NMATCH          reduce using rule 130 (expression -> expression PLUS expression .)
    ARROW           reduce using rule 130 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 130 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 130 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 130 (expression -> expression PLUS expression .)
    ANDAND          reduce using rule 130 (expression -> expression PLUS expression .)
    OROR            reduce using rule 130 (expression -> expression PLUS expression .)
    AND             reduce using rule 130 (expression -> expression PLUS expression .)
    OR              reduce using rule 130 (expression -> expression PLUS expression .)
    DO              reduce using rule 130 (expression -> expression PLUS expression .)
    COLON           reduce using rule 130 (expression -> expression PLUS expression .)
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MULT            [ reduce using rule 130 (expression -> expression PLUS expression .) ]
  ! DIV             [ reduce using rule 130 (expression -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 130 (expression -> expression PLUS expression .) ]
  ! POWER           [ reduce using rule 130 (expression -> expression PLUS expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]


state 119

    (131) expression -> expression MINUS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 131 (expression -> expression MINUS expression .)
    RANGE_EXCL      reduce using rule 131 (expression -> expression MINUS expression .)
    PLUS            reduce using rule 131 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 131 (expression -> expression MINUS expression .)
    BREAK           reduce using rule 131 (expression -> expression MINUS expression .)
    NEXT            reduce using rule 131 (expression -> expression MINUS expression .)
    ELSIF           reduce using rule 131 (expression -> expression MINUS expression .)
    ELSE            reduce using rule 131 (expression -> expression MINUS expression .)
    RETURN          reduce using rule 131 (expression -> expression MINUS expression .)
    PRINT           reduce using rule 131 (expression -> expression MINUS expression .)
    PUTS            reduce using rule 131 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 131 (expression -> expression MINUS expression .)
    FOR             reduce using rule 131 (expression -> expression MINUS expression .)
    LBRACE          reduce using rule 131 (expression -> expression MINUS expression .)
    DEF             reduce using rule 131 (expression -> expression MINUS expression .)
    IF              reduce using rule 131 (expression -> expression MINUS expression .)
    THEN            reduce using rule 131 (expression -> expression MINUS expression .)
    NOT             reduce using rule 131 (expression -> expression MINUS expression .)
    NIL             reduce using rule 131 (expression -> expression MINUS expression .)
    TRUE            reduce using rule 131 (expression -> expression MINUS expression .)
    FALSE           reduce using rule 131 (expression -> expression MINUS expression .)
    LPAREN          reduce using rule 131 (expression -> expression MINUS expression .)
    INTEGER         reduce using rule 131 (expression -> expression MINUS expression .)
    FLOAT           reduce using rule 131 (expression -> expression MINUS expression .)
    RATIONAL        reduce using rule 131 (expression -> expression MINUS expression .)
    COMPLEX         reduce using rule 131 (expression -> expression MINUS expression .)
    STR             reduce using rule 131 (expression -> expression MINUS expression .)
    SYMBOL          reduce using rule 131 (expression -> expression MINUS expression .)
    REGEXP          reduce using rule 131 (expression -> expression MINUS expression .)
    CLASS           reduce using rule 131 (expression -> expression MINUS expression .)
    INSTANCE_VAR    reduce using rule 131 (expression -> expression MINUS expression .)
    CLASS_VAR       reduce using rule 131 (expression -> expression MINUS expression .)
    GLOBAL_VAR      reduce using rule 131 (expression -> expression MINUS expression .)
    LOCAL_VAR       reduce using rule 131 (expression -> expression MINUS expression .)
    CONSTANT        reduce using rule 131 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 131 (expression -> expression MINUS expression .)
    $end            reduce using rule 131 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 131 (expression -> expression MINUS expression .)
    END_S           reduce using rule 131 (expression -> expression MINUS expression .)
    LT              reduce using rule 131 (expression -> expression MINUS expression .)
    LE              reduce using rule 131 (expression -> expression MINUS expression .)
    GT              reduce using rule 131 (expression -> expression MINUS expression .)
    GE              reduce using rule 131 (expression -> expression MINUS expression .)
    EQ              reduce using rule 131 (expression -> expression MINUS expression .)
    NE              reduce using rule 131 (expression -> expression MINUS expression .)
    EQQ             reduce using rule 131 (expression -> expression MINUS expression .)
    MATCH           reduce using rule 131 (expression -> expression MINUS expression .)
    NMATCH          reduce using rule 131 (expression -> expression MINUS expression .)
    ARROW           reduce using rule 131 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 131 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 131 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 131 (expression -> expression MINUS expression .)
    ANDAND          reduce using rule 131 (expression -> expression MINUS expression .)
    OROR            reduce using rule 131 (expression -> expression MINUS expression .)
    AND             reduce using rule 131 (expression -> expression MINUS expression .)
    OR              reduce using rule 131 (expression -> expression MINUS expression .)
    DO              reduce using rule 131 (expression -> expression MINUS expression .)
    COLON           reduce using rule 131 (expression -> expression MINUS expression .)
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MULT            [ reduce using rule 131 (expression -> expression MINUS expression .) ]
  ! DIV             [ reduce using rule 131 (expression -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 131 (expression -> expression MINUS expression .) ]
  ! POWER           [ reduce using rule 131 (expression -> expression MINUS expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]


state 120

    (132) expression -> expression MULT expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 132 (expression -> expression MULT expression .)
    RANGE_EXCL      reduce using rule 132 (expression -> expression MULT expression .)
    PLUS            reduce using rule 132 (expression -> expression MULT expression .)
    MINUS           reduce using rule 132 (expression -> expression MULT expression .)
    MULT            reduce using rule 132 (expression -> expression MULT expression .)
    DIV             reduce using rule 132 (expression -> expression MULT expression .)
    MOD             reduce using rule 132 (expression -> expression MULT expression .)
    BREAK           reduce using rule 132 (expression -> expression MULT expression .)
    NEXT            reduce using rule 132 (expression -> expression MULT expression .)
    ELSIF           reduce using rule 132 (expression -> expression MULT expression .)
    ELSE            reduce using rule 132 (expression -> expression MULT expression .)
    RETURN          reduce using rule 132 (expression -> expression MULT expression .)
    PRINT           reduce using rule 132 (expression -> expression MULT expression .)
    PUTS            reduce using rule 132 (expression -> expression MULT expression .)
    WHILE           reduce using rule 132 (expression -> expression MULT expression .)
    FOR             reduce using rule 132 (expression -> expression MULT expression .)
    LBRACE          reduce using rule 132 (expression -> expression MULT expression .)
    DEF             reduce using rule 132 (expression -> expression MULT expression .)
    IF              reduce using rule 132 (expression -> expression MULT expression .)
    THEN            reduce using rule 132 (expression -> expression MULT expression .)
    NOT             reduce using rule 132 (expression -> expression MULT expression .)
    NIL             reduce using rule 132 (expression -> expression MULT expression .)
    TRUE            reduce using rule 132 (expression -> expression MULT expression .)
    FALSE           reduce using rule 132 (expression -> expression MULT expression .)
    LPAREN          reduce using rule 132 (expression -> expression MULT expression .)
    INTEGER         reduce using rule 132 (expression -> expression MULT expression .)
    FLOAT           reduce using rule 132 (expression -> expression MULT expression .)
    RATIONAL        reduce using rule 132 (expression -> expression MULT expression .)
    COMPLEX         reduce using rule 132 (expression -> expression MULT expression .)
    STR             reduce using rule 132 (expression -> expression MULT expression .)
    SYMBOL          reduce using rule 132 (expression -> expression MULT expression .)
    REGEXP          reduce using rule 132 (expression -> expression MULT expression .)
    CLASS           reduce using rule 132 (expression -> expression MULT expression .)
    INSTANCE_VAR    reduce using rule 132 (expression -> expression MULT expression .)
    CLASS_VAR       reduce using rule 132 (expression -> expression MULT expression .)
    GLOBAL_VAR      reduce using rule 132 (expression -> expression MULT expression .)
    LOCAL_VAR       reduce using rule 132 (expression -> expression MULT expression .)
    CONSTANT        reduce using rule 132 (expression -> expression MULT expression .)
    LBRACKET        reduce using rule 132 (expression -> expression MULT expression .)
    $end            reduce using rule 132 (expression -> expression MULT expression .)
    RBRACE          reduce using rule 132 (expression -> expression MULT expression .)
    END_S           reduce using rule 132 (expression -> expression MULT expression .)
    LT              reduce using rule 132 (expression -> expression MULT expression .)
    LE              reduce using rule 132 (expression -> expression MULT expression .)
    GT              reduce using rule 132 (expression -> expression MULT expression .)
    GE              reduce using rule 132 (expression -> expression MULT expression .)
    EQ              reduce using rule 132 (expression -> expression MULT expression .)
    NE              reduce using rule 132 (expression -> expression MULT expression .)
    EQQ             reduce using rule 132 (expression -> expression MULT expression .)
    MATCH           reduce using rule 132 (expression -> expression MULT expression .)
    NMATCH          reduce using rule 132 (expression -> expression MULT expression .)
    ARROW           reduce using rule 132 (expression -> expression MULT expression .)
    RPAREN          reduce using rule 132 (expression -> expression MULT expression .)
    COMMA           reduce using rule 132 (expression -> expression MULT expression .)
    RBRACKET        reduce using rule 132 (expression -> expression MULT expression .)
    ANDAND          reduce using rule 132 (expression -> expression MULT expression .)
    OROR            reduce using rule 132 (expression -> expression MULT expression .)
    AND             reduce using rule 132 (expression -> expression MULT expression .)
    OR              reduce using rule 132 (expression -> expression MULT expression .)
    DO              reduce using rule 132 (expression -> expression MULT expression .)
    COLON           reduce using rule 132 (expression -> expression MULT expression .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 132 (expression -> expression MULT expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! MULT            [ shift and go to state 66 ]
  ! DIV             [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]


state 121

    (133) expression -> expression DIV expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 133 (expression -> expression DIV expression .)
    RANGE_EXCL      reduce using rule 133 (expression -> expression DIV expression .)
    PLUS            reduce using rule 133 (expression -> expression DIV expression .)
    MINUS           reduce using rule 133 (expression -> expression DIV expression .)
    MULT            reduce using rule 133 (expression -> expression DIV expression .)
    DIV             reduce using rule 133 (expression -> expression DIV expression .)
    MOD             reduce using rule 133 (expression -> expression DIV expression .)
    BREAK           reduce using rule 133 (expression -> expression DIV expression .)
    NEXT            reduce using rule 133 (expression -> expression DIV expression .)
    ELSIF           reduce using rule 133 (expression -> expression DIV expression .)
    ELSE            reduce using rule 133 (expression -> expression DIV expression .)
    RETURN          reduce using rule 133 (expression -> expression DIV expression .)
    PRINT           reduce using rule 133 (expression -> expression DIV expression .)
    PUTS            reduce using rule 133 (expression -> expression DIV expression .)
    WHILE           reduce using rule 133 (expression -> expression DIV expression .)
    FOR             reduce using rule 133 (expression -> expression DIV expression .)
    LBRACE          reduce using rule 133 (expression -> expression DIV expression .)
    DEF             reduce using rule 133 (expression -> expression DIV expression .)
    IF              reduce using rule 133 (expression -> expression DIV expression .)
    THEN            reduce using rule 133 (expression -> expression DIV expression .)
    NOT             reduce using rule 133 (expression -> expression DIV expression .)
    NIL             reduce using rule 133 (expression -> expression DIV expression .)
    TRUE            reduce using rule 133 (expression -> expression DIV expression .)
    FALSE           reduce using rule 133 (expression -> expression DIV expression .)
    LPAREN          reduce using rule 133 (expression -> expression DIV expression .)
    INTEGER         reduce using rule 133 (expression -> expression DIV expression .)
    FLOAT           reduce using rule 133 (expression -> expression DIV expression .)
    RATIONAL        reduce using rule 133 (expression -> expression DIV expression .)
    COMPLEX         reduce using rule 133 (expression -> expression DIV expression .)
    STR             reduce using rule 133 (expression -> expression DIV expression .)
    SYMBOL          reduce using rule 133 (expression -> expression DIV expression .)
    REGEXP          reduce using rule 133 (expression -> expression DIV expression .)
    CLASS           reduce using rule 133 (expression -> expression DIV expression .)
    INSTANCE_VAR    reduce using rule 133 (expression -> expression DIV expression .)
    CLASS_VAR       reduce using rule 133 (expression -> expression DIV expression .)
    GLOBAL_VAR      reduce using rule 133 (expression -> expression DIV expression .)
    LOCAL_VAR       reduce using rule 133 (expression -> expression DIV expression .)
    CONSTANT        reduce using rule 133 (expression -> expression DIV expression .)
    LBRACKET        reduce using rule 133 (expression -> expression DIV expression .)
    $end            reduce using rule 133 (expression -> expression DIV expression .)
    RBRACE          reduce using rule 133 (expression -> expression DIV expression .)
    END_S           reduce using rule 133 (expression -> expression DIV expression .)
    LT              reduce using rule 133 (expression -> expression DIV expression .)
    LE              reduce using rule 133 (expression -> expression DIV expression .)
    GT              reduce using rule 133 (expression -> expression DIV expression .)
    GE              reduce using rule 133 (expression -> expression DIV expression .)
    EQ              reduce using rule 133 (expression -> expression DIV expression .)
    NE              reduce using rule 133 (expression -> expression DIV expression .)
    EQQ             reduce using rule 133 (expression -> expression DIV expression .)
    MATCH           reduce using rule 133 (expression -> expression DIV expression .)
    NMATCH          reduce using rule 133 (expression -> expression DIV expression .)
    ARROW           reduce using rule 133 (expression -> expression DIV expression .)
    RPAREN          reduce using rule 133 (expression -> expression DIV expression .)
    COMMA           reduce using rule 133 (expression -> expression DIV expression .)
    RBRACKET        reduce using rule 133 (expression -> expression DIV expression .)
    ANDAND          reduce using rule 133 (expression -> expression DIV expression .)
    OROR            reduce using rule 133 (expression -> expression DIV expression .)
    AND             reduce using rule 133 (expression -> expression DIV expression .)
    OR              reduce using rule 133 (expression -> expression DIV expression .)
    DO              reduce using rule 133 (expression -> expression DIV expression .)
    COLON           reduce using rule 133 (expression -> expression DIV expression .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 133 (expression -> expression DIV expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! MULT            [ shift and go to state 66 ]
  ! DIV             [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]


state 122

    (134) expression -> expression MOD expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 134 (expression -> expression MOD expression .)
    RANGE_EXCL      reduce using rule 134 (expression -> expression MOD expression .)
    PLUS            reduce using rule 134 (expression -> expression MOD expression .)
    MINUS           reduce using rule 134 (expression -> expression MOD expression .)
    MULT            reduce using rule 134 (expression -> expression MOD expression .)
    DIV             reduce using rule 134 (expression -> expression MOD expression .)
    MOD             reduce using rule 134 (expression -> expression MOD expression .)
    BREAK           reduce using rule 134 (expression -> expression MOD expression .)
    NEXT            reduce using rule 134 (expression -> expression MOD expression .)
    ELSIF           reduce using rule 134 (expression -> expression MOD expression .)
    ELSE            reduce using rule 134 (expression -> expression MOD expression .)
    RETURN          reduce using rule 134 (expression -> expression MOD expression .)
    PRINT           reduce using rule 134 (expression -> expression MOD expression .)
    PUTS            reduce using rule 134 (expression -> expression MOD expression .)
    WHILE           reduce using rule 134 (expression -> expression MOD expression .)
    FOR             reduce using rule 134 (expression -> expression MOD expression .)
    LBRACE          reduce using rule 134 (expression -> expression MOD expression .)
    DEF             reduce using rule 134 (expression -> expression MOD expression .)
    IF              reduce using rule 134 (expression -> expression MOD expression .)
    THEN            reduce using rule 134 (expression -> expression MOD expression .)
    NOT             reduce using rule 134 (expression -> expression MOD expression .)
    NIL             reduce using rule 134 (expression -> expression MOD expression .)
    TRUE            reduce using rule 134 (expression -> expression MOD expression .)
    FALSE           reduce using rule 134 (expression -> expression MOD expression .)
    LPAREN          reduce using rule 134 (expression -> expression MOD expression .)
    INTEGER         reduce using rule 134 (expression -> expression MOD expression .)
    FLOAT           reduce using rule 134 (expression -> expression MOD expression .)
    RATIONAL        reduce using rule 134 (expression -> expression MOD expression .)
    COMPLEX         reduce using rule 134 (expression -> expression MOD expression .)
    STR             reduce using rule 134 (expression -> expression MOD expression .)
    SYMBOL          reduce using rule 134 (expression -> expression MOD expression .)
    REGEXP          reduce using rule 134 (expression -> expression MOD expression .)
    CLASS           reduce using rule 134 (expression -> expression MOD expression .)
    INSTANCE_VAR    reduce using rule 134 (expression -> expression MOD expression .)
    CLASS_VAR       reduce using rule 134 (expression -> expression MOD expression .)
    GLOBAL_VAR      reduce using rule 134 (expression -> expression MOD expression .)
    LOCAL_VAR       reduce using rule 134 (expression -> expression MOD expression .)
    CONSTANT        reduce using rule 134 (expression -> expression MOD expression .)
    LBRACKET        reduce using rule 134 (expression -> expression MOD expression .)
    $end            reduce using rule 134 (expression -> expression MOD expression .)
    RBRACE          reduce using rule 134 (expression -> expression MOD expression .)
    END_S           reduce using rule 134 (expression -> expression MOD expression .)
    LT              reduce using rule 134 (expression -> expression MOD expression .)
    LE              reduce using rule 134 (expression -> expression MOD expression .)
    GT              reduce using rule 134 (expression -> expression MOD expression .)
    GE              reduce using rule 134 (expression -> expression MOD expression .)
    EQ              reduce using rule 134 (expression -> expression MOD expression .)
    NE              reduce using rule 134 (expression -> expression MOD expression .)
    EQQ             reduce using rule 134 (expression -> expression MOD expression .)
    MATCH           reduce using rule 134 (expression -> expression MOD expression .)
    NMATCH          reduce using rule 134 (expression -> expression MOD expression .)
    ARROW           reduce using rule 134 (expression -> expression MOD expression .)
    RPAREN          reduce using rule 134 (expression -> expression MOD expression .)
    COMMA           reduce using rule 134 (expression -> expression MOD expression .)
    RBRACKET        reduce using rule 134 (expression -> expression MOD expression .)
    ANDAND          reduce using rule 134 (expression -> expression MOD expression .)
    OROR            reduce using rule 134 (expression -> expression MOD expression .)
    AND             reduce using rule 134 (expression -> expression MOD expression .)
    OR              reduce using rule 134 (expression -> expression MOD expression .)
    DO              reduce using rule 134 (expression -> expression MOD expression .)
    COLON           reduce using rule 134 (expression -> expression MOD expression .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 134 (expression -> expression MOD expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! MULT            [ shift and go to state 66 ]
  ! DIV             [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]


state 123

    (135) expression -> expression POWER expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RANGE_INCL      reduce using rule 135 (expression -> expression POWER expression .)
    RANGE_EXCL      reduce using rule 135 (expression -> expression POWER expression .)
    PLUS            reduce using rule 135 (expression -> expression POWER expression .)
    MINUS           reduce using rule 135 (expression -> expression POWER expression .)
    MULT            reduce using rule 135 (expression -> expression POWER expression .)
    DIV             reduce using rule 135 (expression -> expression POWER expression .)
    MOD             reduce using rule 135 (expression -> expression POWER expression .)
    BREAK           reduce using rule 135 (expression -> expression POWER expression .)
    NEXT            reduce using rule 135 (expression -> expression POWER expression .)
    ELSIF           reduce using rule 135 (expression -> expression POWER expression .)
    ELSE            reduce using rule 135 (expression -> expression POWER expression .)
    RETURN          reduce using rule 135 (expression -> expression POWER expression .)
    PRINT           reduce using rule 135 (expression -> expression POWER expression .)
    PUTS            reduce using rule 135 (expression -> expression POWER expression .)
    WHILE           reduce using rule 135 (expression -> expression POWER expression .)
    FOR             reduce using rule 135 (expression -> expression POWER expression .)
    LBRACE          reduce using rule 135 (expression -> expression POWER expression .)
    DEF             reduce using rule 135 (expression -> expression POWER expression .)
    IF              reduce using rule 135 (expression -> expression POWER expression .)
    THEN            reduce using rule 135 (expression -> expression POWER expression .)
    NOT             reduce using rule 135 (expression -> expression POWER expression .)
    NIL             reduce using rule 135 (expression -> expression POWER expression .)
    TRUE            reduce using rule 135 (expression -> expression POWER expression .)
    FALSE           reduce using rule 135 (expression -> expression POWER expression .)
    LPAREN          reduce using rule 135 (expression -> expression POWER expression .)
    INTEGER         reduce using rule 135 (expression -> expression POWER expression .)
    FLOAT           reduce using rule 135 (expression -> expression POWER expression .)
    RATIONAL        reduce using rule 135 (expression -> expression POWER expression .)
    COMPLEX         reduce using rule 135 (expression -> expression POWER expression .)
    STR             reduce using rule 135 (expression -> expression POWER expression .)
    SYMBOL          reduce using rule 135 (expression -> expression POWER expression .)
    REGEXP          reduce using rule 135 (expression -> expression POWER expression .)
    CLASS           reduce using rule 135 (expression -> expression POWER expression .)
    INSTANCE_VAR    reduce using rule 135 (expression -> expression POWER expression .)
    CLASS_VAR       reduce using rule 135 (expression -> expression POWER expression .)
    GLOBAL_VAR      reduce using rule 135 (expression -> expression POWER expression .)
    LOCAL_VAR       reduce using rule 135 (expression -> expression POWER expression .)
    CONSTANT        reduce using rule 135 (expression -> expression POWER expression .)
    LBRACKET        reduce using rule 135 (expression -> expression POWER expression .)
    $end            reduce using rule 135 (expression -> expression POWER expression .)
    RBRACE          reduce using rule 135 (expression -> expression POWER expression .)
    END_S           reduce using rule 135 (expression -> expression POWER expression .)
    LT              reduce using rule 135 (expression -> expression POWER expression .)
    LE              reduce using rule 135 (expression -> expression POWER expression .)
    GT              reduce using rule 135 (expression -> expression POWER expression .)
    GE              reduce using rule 135 (expression -> expression POWER expression .)
    EQ              reduce using rule 135 (expression -> expression POWER expression .)
    NE              reduce using rule 135 (expression -> expression POWER expression .)
    EQQ             reduce using rule 135 (expression -> expression POWER expression .)
    MATCH           reduce using rule 135 (expression -> expression POWER expression .)
    NMATCH          reduce using rule 135 (expression -> expression POWER expression .)
    ARROW           reduce using rule 135 (expression -> expression POWER expression .)
    RPAREN          reduce using rule 135 (expression -> expression POWER expression .)
    COMMA           reduce using rule 135 (expression -> expression POWER expression .)
    RBRACKET        reduce using rule 135 (expression -> expression POWER expression .)
    ANDAND          reduce using rule 135 (expression -> expression POWER expression .)
    OROR            reduce using rule 135 (expression -> expression POWER expression .)
    AND             reduce using rule 135 (expression -> expression POWER expression .)
    OR              reduce using rule 135 (expression -> expression POWER expression .)
    DO              reduce using rule 135 (expression -> expression POWER expression .)
    COLON           reduce using rule 135 (expression -> expression POWER expression .)
    POWER           shift and go to state 69

  ! POWER           [ reduce using rule 135 (expression -> expression POWER expression .) ]
  ! RANGE_INCL      [ shift and go to state 62 ]
  ! RANGE_EXCL      [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! MINUS           [ shift and go to state 65 ]
  ! MULT            [ shift and go to state 66 ]
  ! DIV             [ shift and go to state 67 ]
  ! MOD             [ shift and go to state 68 ]


state 124

    (53) statement -> ELSIF expression_logic optional_then . stmt_block
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    $end            reduce using rule 111 (empty -> .)
    RBRACE          reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 179
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 125

    (57) expression_logic -> expression_logic ANDAND . expression_logic
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 180
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 126

    (58) expression_logic -> expression_logic OROR . expression_logic
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 181
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 127

    (59) expression_logic -> expression_logic AND . expression_logic
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 182
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 128

    (60) expression_logic -> expression_logic OR . expression_logic
    (57) expression_logic -> . expression_logic ANDAND expression_logic
    (58) expression_logic -> . expression_logic OROR expression_logic
    (59) expression_logic -> . expression_logic AND expression_logic
    (60) expression_logic -> . expression_logic OR expression_logic
    (61) expression_logic -> . expression_compare
    (62) expression_compare -> . expression LT expression
    (63) expression_compare -> . expression LE expression
    (64) expression_compare -> . expression GT expression
    (65) expression_compare -> . expression GE expression
    (66) expression_compare -> . expression EQ expression
    (67) expression_compare -> . expression NE expression
    (68) expression_compare -> . expression EQQ expression
    (69) expression_compare -> . expression MATCH expression
    (70) expression_compare -> . expression NMATCH expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression_logic               shift and go to state 183
    expression_compare             shift and go to state 72
    expression                     shift and go to state 97
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 129

    (48) optional_then -> empty .

    LBRACE          reduce using rule 48 (optional_then -> empty .)
    BREAK           reduce using rule 48 (optional_then -> empty .)
    NEXT            reduce using rule 48 (optional_then -> empty .)
    ELSIF           reduce using rule 48 (optional_then -> empty .)
    ELSE            reduce using rule 48 (optional_then -> empty .)
    RETURN          reduce using rule 48 (optional_then -> empty .)
    PRINT           reduce using rule 48 (optional_then -> empty .)
    PUTS            reduce using rule 48 (optional_then -> empty .)
    WHILE           reduce using rule 48 (optional_then -> empty .)
    FOR             reduce using rule 48 (optional_then -> empty .)
    DEF             reduce using rule 48 (optional_then -> empty .)
    IF              reduce using rule 48 (optional_then -> empty .)
    THEN            reduce using rule 48 (optional_then -> empty .)
    NOT             reduce using rule 48 (optional_then -> empty .)
    NIL             reduce using rule 48 (optional_then -> empty .)
    TRUE            reduce using rule 48 (optional_then -> empty .)
    FALSE           reduce using rule 48 (optional_then -> empty .)
    LPAREN          reduce using rule 48 (optional_then -> empty .)
    INTEGER         reduce using rule 48 (optional_then -> empty .)
    FLOAT           reduce using rule 48 (optional_then -> empty .)
    RATIONAL        reduce using rule 48 (optional_then -> empty .)
    COMPLEX         reduce using rule 48 (optional_then -> empty .)
    STR             reduce using rule 48 (optional_then -> empty .)
    SYMBOL          reduce using rule 48 (optional_then -> empty .)
    REGEXP          reduce using rule 48 (optional_then -> empty .)
    MINUS           reduce using rule 48 (optional_then -> empty .)
    CLASS           reduce using rule 48 (optional_then -> empty .)
    INSTANCE_VAR    reduce using rule 48 (optional_then -> empty .)
    CLASS_VAR       reduce using rule 48 (optional_then -> empty .)
    GLOBAL_VAR      reduce using rule 48 (optional_then -> empty .)
    LOCAL_VAR       reduce using rule 48 (optional_then -> empty .)
    CONSTANT        reduce using rule 48 (optional_then -> empty .)
    LBRACKET        reduce using rule 48 (optional_then -> empty .)
    $end            reduce using rule 48 (optional_then -> empty .)
    RBRACE          reduce using rule 48 (optional_then -> empty .)
    END_S           reduce using rule 48 (optional_then -> empty .)


state 130

    (62) expression_compare -> expression LT . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 184
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 131

    (63) expression_compare -> expression LE . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 185
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 132

    (64) expression_compare -> expression GT . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 186
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 133

    (65) expression_compare -> expression GE . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 187
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 134

    (66) expression_compare -> expression EQ . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 188
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 135

    (67) expression_compare -> expression NE . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 189
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 136

    (68) expression_compare -> expression EQQ . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 190
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 137

    (69) expression_compare -> expression MATCH . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 191
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 138

    (70) expression_compare -> expression NMATCH . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 192
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 139

    (77) hash_pair -> expression . ARROW expression
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ARROW           shift and go to state 160
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 140

    (22) statement -> expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression
    (77) hash_pair -> expression . ARROW expression

  ! shift/reduce conflict for MINUS resolved as shift
    RBRACE          reduce using rule 22 (statement -> expression .)
    BREAK           reduce using rule 22 (statement -> expression .)
    NEXT            reduce using rule 22 (statement -> expression .)
    ELSIF           reduce using rule 22 (statement -> expression .)
    ELSE            reduce using rule 22 (statement -> expression .)
    RETURN          reduce using rule 22 (statement -> expression .)
    PRINT           reduce using rule 22 (statement -> expression .)
    PUTS            reduce using rule 22 (statement -> expression .)
    WHILE           reduce using rule 22 (statement -> expression .)
    FOR             reduce using rule 22 (statement -> expression .)
    LBRACE          reduce using rule 22 (statement -> expression .)
    DEF             reduce using rule 22 (statement -> expression .)
    IF              reduce using rule 22 (statement -> expression .)
    THEN            reduce using rule 22 (statement -> expression .)
    NOT             reduce using rule 22 (statement -> expression .)
    NIL             reduce using rule 22 (statement -> expression .)
    TRUE            reduce using rule 22 (statement -> expression .)
    FALSE           reduce using rule 22 (statement -> expression .)
    LPAREN          reduce using rule 22 (statement -> expression .)
    INTEGER         reduce using rule 22 (statement -> expression .)
    FLOAT           reduce using rule 22 (statement -> expression .)
    RATIONAL        reduce using rule 22 (statement -> expression .)
    COMPLEX         reduce using rule 22 (statement -> expression .)
    STR             reduce using rule 22 (statement -> expression .)
    SYMBOL          reduce using rule 22 (statement -> expression .)
    REGEXP          reduce using rule 22 (statement -> expression .)
    CLASS           reduce using rule 22 (statement -> expression .)
    INSTANCE_VAR    reduce using rule 22 (statement -> expression .)
    CLASS_VAR       reduce using rule 22 (statement -> expression .)
    GLOBAL_VAR      reduce using rule 22 (statement -> expression .)
    LOCAL_VAR       reduce using rule 22 (statement -> expression .)
    CONSTANT        reduce using rule 22 (statement -> expression .)
    LBRACKET        reduce using rule 22 (statement -> expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    ARROW           shift and go to state 160

  ! MINUS           [ reduce using rule 22 (statement -> expression .) ]


state 141

    (142) expression -> SYMBOL .
    (78) hash_pair -> SYMBOL . COLON expression
    (90) primary -> SYMBOL .

  ! reduce/reduce conflict for LBRACKET resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PLUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MINUS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MULT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DIV resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for MOD resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for POWER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ARROW resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RBRACE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for BREAK resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NEXT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSIF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for ELSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RETURN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PRINT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for PUTS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for WHILE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FOR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LBRACE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for DEF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for IF resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for THEN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NOT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for NIL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for TRUE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FALSE resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LPAREN resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INTEGER resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for FLOAT resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for STR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for REGEXP resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 90 (primary -> SYMBOL .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 90 (primary -> SYMBOL .)
    COLON           shift and go to state 161
    EQLS            reduce using rule 90 (primary -> SYMBOL .)
    LBRACKET        reduce using rule 90 (primary -> SYMBOL .)
    DOT             reduce using rule 90 (primary -> SYMBOL .)
    RANGE_INCL      reduce using rule 90 (primary -> SYMBOL .)
    RANGE_EXCL      reduce using rule 90 (primary -> SYMBOL .)
    PLUS            reduce using rule 90 (primary -> SYMBOL .)
    MINUS           reduce using rule 90 (primary -> SYMBOL .)
    MULT            reduce using rule 90 (primary -> SYMBOL .)
    DIV             reduce using rule 90 (primary -> SYMBOL .)
    MOD             reduce using rule 90 (primary -> SYMBOL .)
    POWER           reduce using rule 90 (primary -> SYMBOL .)
    ARROW           reduce using rule 90 (primary -> SYMBOL .)
    RBRACE          reduce using rule 90 (primary -> SYMBOL .)
    BREAK           reduce using rule 90 (primary -> SYMBOL .)
    NEXT            reduce using rule 90 (primary -> SYMBOL .)
    ELSIF           reduce using rule 90 (primary -> SYMBOL .)
    ELSE            reduce using rule 90 (primary -> SYMBOL .)
    RETURN          reduce using rule 90 (primary -> SYMBOL .)
    PRINT           reduce using rule 90 (primary -> SYMBOL .)
    PUTS            reduce using rule 90 (primary -> SYMBOL .)
    WHILE           reduce using rule 90 (primary -> SYMBOL .)
    FOR             reduce using rule 90 (primary -> SYMBOL .)
    LBRACE          reduce using rule 90 (primary -> SYMBOL .)
    DEF             reduce using rule 90 (primary -> SYMBOL .)
    IF              reduce using rule 90 (primary -> SYMBOL .)
    THEN            reduce using rule 90 (primary -> SYMBOL .)
    NOT             reduce using rule 90 (primary -> SYMBOL .)
    NIL             reduce using rule 90 (primary -> SYMBOL .)
    TRUE            reduce using rule 90 (primary -> SYMBOL .)
    FALSE           reduce using rule 90 (primary -> SYMBOL .)
    LPAREN          reduce using rule 90 (primary -> SYMBOL .)
    INTEGER         reduce using rule 90 (primary -> SYMBOL .)
    FLOAT           reduce using rule 90 (primary -> SYMBOL .)
    RATIONAL        reduce using rule 90 (primary -> SYMBOL .)
    COMPLEX         reduce using rule 90 (primary -> SYMBOL .)
    STR             reduce using rule 90 (primary -> SYMBOL .)
    SYMBOL          reduce using rule 90 (primary -> SYMBOL .)
    REGEXP          reduce using rule 90 (primary -> SYMBOL .)
    CLASS           reduce using rule 90 (primary -> SYMBOL .)
    INSTANCE_VAR    reduce using rule 90 (primary -> SYMBOL .)
    CLASS_VAR       reduce using rule 90 (primary -> SYMBOL .)
    GLOBAL_VAR      reduce using rule 90 (primary -> SYMBOL .)
    LOCAL_VAR       reduce using rule 90 (primary -> SYMBOL .)
    CONSTANT        reduce using rule 90 (primary -> SYMBOL .)

  ! RANGE_INCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RANGE_EXCL      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PLUS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MINUS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MULT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DIV             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! MOD             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! POWER           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ARROW           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! BREAK           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NEXT            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSIF           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! ELSE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RETURN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PRINT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! PUTS            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! WHILE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FOR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACE          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! DEF             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! IF              [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! THEN            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NOT             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! NIL             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! TRUE            [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FALSE           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LPAREN          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INTEGER         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! FLOAT           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! RATIONAL        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! COMPLEX         [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! STR             [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! SYMBOL          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! REGEXP          [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS           [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! INSTANCE_VAR    [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CLASS_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! GLOBAL_VAR      [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LOCAL_VAR       [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! CONSTANT        [ reduce using rule 142 (expression -> SYMBOL .) ]
  ! LBRACKET        [ reduce using rule 142 (expression -> SYMBOL .) ]


state 142

    (25) input_stmt -> variable EQLS LOCAL_VAR .
    (27) variable -> LOCAL_VAR .
    (97) expr_postfix -> LOCAL_VAR . LPAREN RPAREN
    (98) expr_postfix -> LOCAL_VAR . LPAREN expr_list RPAREN

  ! reduce/reduce conflict for MINUS resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for BREAK resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for NEXT resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for ELSIF resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for ELSE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for RETURN resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for PRINT resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for PUTS resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for WHILE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for FOR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for LBRACE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for DEF resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for IF resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for THEN resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for NOT resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for NIL resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for TRUE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for FALSE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for INTEGER resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for STR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for REGEXP resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for CLASS resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for $end resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for RBRACE resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! reduce/reduce conflict for END_S resolved using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
  ! shift/reduce conflict for LPAREN resolved as shift
    BREAK           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    NEXT            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    ELSIF           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    ELSE            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    RETURN          reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    PRINT           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    PUTS            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    WHILE           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    FOR             reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    LBRACE          reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    DEF             reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    IF              reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    THEN            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    NOT             reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    NIL             reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    TRUE            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    FALSE           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    INTEGER         reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    FLOAT           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    RATIONAL        reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    COMPLEX         reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    STR             reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    SYMBOL          reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    REGEXP          reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    MINUS           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    CLASS           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    CLASS_VAR       reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    CONSTANT        reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    LBRACKET        reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    $end            reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    RBRACE          reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    END_S           reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .)
    RANGE_INCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_EXCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUS            reduce using rule 27 (variable -> LOCAL_VAR .)
    MULT            reduce using rule 27 (variable -> LOCAL_VAR .)
    DIV             reduce using rule 27 (variable -> LOCAL_VAR .)
    MOD             reduce using rule 27 (variable -> LOCAL_VAR .)
    POWER           reduce using rule 27 (variable -> LOCAL_VAR .)
    DOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    LPAREN          shift and go to state 92

  ! LPAREN          [ reduce using rule 25 (input_stmt -> variable EQLS LOCAL_VAR .) ]
  ! MINUS           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! BREAK           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! NEXT            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! ELSIF           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! ELSE            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! RETURN          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! PRINT           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! PUTS            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! WHILE           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! FOR             [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! LBRACE          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! DEF             [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! IF              [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! THEN            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! NOT             [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! NIL             [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! TRUE            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! FALSE           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! LPAREN          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! INTEGER         [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! FLOAT           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! RATIONAL        [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! COMPLEX         [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! STR             [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! SYMBOL          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! REGEXP          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! CLASS           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! INSTANCE_VAR    [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! CLASS_VAR       [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! GLOBAL_VAR      [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! LOCAL_VAR       [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! CONSTANT        [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! LBRACKET        [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! $end            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! RBRACE          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! END_S           [ reduce using rule 27 (variable -> LOCAL_VAR .) ]


state 143

    (31) assignment -> variable EQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 31 (assignment -> variable EQLS expression .)
    NEXT            reduce using rule 31 (assignment -> variable EQLS expression .)
    ELSIF           reduce using rule 31 (assignment -> variable EQLS expression .)
    ELSE            reduce using rule 31 (assignment -> variable EQLS expression .)
    RETURN          reduce using rule 31 (assignment -> variable EQLS expression .)
    PRINT           reduce using rule 31 (assignment -> variable EQLS expression .)
    PUTS            reduce using rule 31 (assignment -> variable EQLS expression .)
    WHILE           reduce using rule 31 (assignment -> variable EQLS expression .)
    FOR             reduce using rule 31 (assignment -> variable EQLS expression .)
    LBRACE          reduce using rule 31 (assignment -> variable EQLS expression .)
    DEF             reduce using rule 31 (assignment -> variable EQLS expression .)
    IF              reduce using rule 31 (assignment -> variable EQLS expression .)
    THEN            reduce using rule 31 (assignment -> variable EQLS expression .)
    NOT             reduce using rule 31 (assignment -> variable EQLS expression .)
    NIL             reduce using rule 31 (assignment -> variable EQLS expression .)
    TRUE            reduce using rule 31 (assignment -> variable EQLS expression .)
    FALSE           reduce using rule 31 (assignment -> variable EQLS expression .)
    LPAREN          reduce using rule 31 (assignment -> variable EQLS expression .)
    INTEGER         reduce using rule 31 (assignment -> variable EQLS expression .)
    FLOAT           reduce using rule 31 (assignment -> variable EQLS expression .)
    RATIONAL        reduce using rule 31 (assignment -> variable EQLS expression .)
    COMPLEX         reduce using rule 31 (assignment -> variable EQLS expression .)
    STR             reduce using rule 31 (assignment -> variable EQLS expression .)
    SYMBOL          reduce using rule 31 (assignment -> variable EQLS expression .)
    REGEXP          reduce using rule 31 (assignment -> variable EQLS expression .)
    CLASS           reduce using rule 31 (assignment -> variable EQLS expression .)
    INSTANCE_VAR    reduce using rule 31 (assignment -> variable EQLS expression .)
    CLASS_VAR       reduce using rule 31 (assignment -> variable EQLS expression .)
    GLOBAL_VAR      reduce using rule 31 (assignment -> variable EQLS expression .)
    LOCAL_VAR       reduce using rule 31 (assignment -> variable EQLS expression .)
    CONSTANT        reduce using rule 31 (assignment -> variable EQLS expression .)
    LBRACKET        reduce using rule 31 (assignment -> variable EQLS expression .)
    $end            reduce using rule 31 (assignment -> variable EQLS expression .)
    RBRACE          reduce using rule 31 (assignment -> variable EQLS expression .)
    END_S           reduce using rule 31 (assignment -> variable EQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 31 (assignment -> variable EQLS expression .) ]


state 144

    (32) assignment -> variable PLUSEQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    NEXT            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    ELSIF           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    ELSE            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    RETURN          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    PRINT           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    PUTS            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    WHILE           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    FOR             reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    LBRACE          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    DEF             reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    IF              reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    THEN            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    NOT             reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    NIL             reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    TRUE            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    FALSE           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    LPAREN          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    INTEGER         reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    FLOAT           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    RATIONAL        reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    COMPLEX         reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    STR             reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    SYMBOL          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    REGEXP          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    CLASS           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    INSTANCE_VAR    reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    CLASS_VAR       reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    GLOBAL_VAR      reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    LOCAL_VAR       reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    CONSTANT        reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    LBRACKET        reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    $end            reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    RBRACE          reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    END_S           reduce using rule 32 (assignment -> variable PLUSEQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 32 (assignment -> variable PLUSEQLS expression .) ]


state 145

    (33) assignment -> variable MINUSEQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    NEXT            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    ELSIF           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    ELSE            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    RETURN          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    PRINT           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    PUTS            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    WHILE           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    FOR             reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    LBRACE          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    DEF             reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    IF              reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    THEN            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    NOT             reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    NIL             reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    TRUE            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    FALSE           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    LPAREN          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    INTEGER         reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    FLOAT           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    RATIONAL        reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    COMPLEX         reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    STR             reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    SYMBOL          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    REGEXP          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    CLASS           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    INSTANCE_VAR    reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    CLASS_VAR       reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    GLOBAL_VAR      reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    LOCAL_VAR       reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    CONSTANT        reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    LBRACKET        reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    $end            reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    RBRACE          reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    END_S           reduce using rule 33 (assignment -> variable MINUSEQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 33 (assignment -> variable MINUSEQLS expression .) ]


state 146

    (34) assignment -> variable MULTEQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    NEXT            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    ELSIF           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    ELSE            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    RETURN          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    PRINT           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    PUTS            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    WHILE           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    FOR             reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    LBRACE          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    DEF             reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    IF              reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    THEN            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    NOT             reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    NIL             reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    TRUE            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    FALSE           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    LPAREN          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    INTEGER         reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    FLOAT           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    RATIONAL        reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    COMPLEX         reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    STR             reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    SYMBOL          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    REGEXP          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    CLASS           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    INSTANCE_VAR    reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    CLASS_VAR       reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    GLOBAL_VAR      reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    LOCAL_VAR       reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    CONSTANT        reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    LBRACKET        reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    $end            reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    RBRACE          reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    END_S           reduce using rule 34 (assignment -> variable MULTEQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 34 (assignment -> variable MULTEQLS expression .) ]


state 147

    (35) assignment -> variable DIVEQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    NEXT            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    ELSIF           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    ELSE            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    RETURN          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    PRINT           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    PUTS            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    WHILE           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    FOR             reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    LBRACE          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    DEF             reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    IF              reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    THEN            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    NOT             reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    NIL             reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    TRUE            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    FALSE           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    LPAREN          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    INTEGER         reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    FLOAT           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    RATIONAL        reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    COMPLEX         reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    STR             reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    SYMBOL          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    REGEXP          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    CLASS           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    INSTANCE_VAR    reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    CLASS_VAR       reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    GLOBAL_VAR      reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    LOCAL_VAR       reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    CONSTANT        reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    LBRACKET        reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    $end            reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    RBRACE          reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    END_S           reduce using rule 35 (assignment -> variable DIVEQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 35 (assignment -> variable DIVEQLS expression .) ]


state 148

    (36) assignment -> variable MODEQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    NEXT            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    ELSIF           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    ELSE            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    RETURN          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    PRINT           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    PUTS            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    WHILE           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    FOR             reduce using rule 36 (assignment -> variable MODEQLS expression .)
    LBRACE          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    DEF             reduce using rule 36 (assignment -> variable MODEQLS expression .)
    IF              reduce using rule 36 (assignment -> variable MODEQLS expression .)
    THEN            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    NOT             reduce using rule 36 (assignment -> variable MODEQLS expression .)
    NIL             reduce using rule 36 (assignment -> variable MODEQLS expression .)
    TRUE            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    FALSE           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    LPAREN          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    INTEGER         reduce using rule 36 (assignment -> variable MODEQLS expression .)
    FLOAT           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    RATIONAL        reduce using rule 36 (assignment -> variable MODEQLS expression .)
    COMPLEX         reduce using rule 36 (assignment -> variable MODEQLS expression .)
    STR             reduce using rule 36 (assignment -> variable MODEQLS expression .)
    SYMBOL          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    REGEXP          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    CLASS           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    INSTANCE_VAR    reduce using rule 36 (assignment -> variable MODEQLS expression .)
    CLASS_VAR       reduce using rule 36 (assignment -> variable MODEQLS expression .)
    GLOBAL_VAR      reduce using rule 36 (assignment -> variable MODEQLS expression .)
    LOCAL_VAR       reduce using rule 36 (assignment -> variable MODEQLS expression .)
    CONSTANT        reduce using rule 36 (assignment -> variable MODEQLS expression .)
    LBRACKET        reduce using rule 36 (assignment -> variable MODEQLS expression .)
    $end            reduce using rule 36 (assignment -> variable MODEQLS expression .)
    RBRACE          reduce using rule 36 (assignment -> variable MODEQLS expression .)
    END_S           reduce using rule 36 (assignment -> variable MODEQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 36 (assignment -> variable MODEQLS expression .) ]


state 149

    (37) assignment -> variable POWEREQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    NEXT            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    ELSIF           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    ELSE            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    RETURN          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    PRINT           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    PUTS            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    WHILE           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    FOR             reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    LBRACE          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    DEF             reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    IF              reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    THEN            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    NOT             reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    NIL             reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    TRUE            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    FALSE           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    LPAREN          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    INTEGER         reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    FLOAT           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    RATIONAL        reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    COMPLEX         reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    STR             reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    SYMBOL          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    REGEXP          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    CLASS           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    INSTANCE_VAR    reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    CLASS_VAR       reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    GLOBAL_VAR      reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    LOCAL_VAR       reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    CONSTANT        reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    LBRACKET        reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    $end            reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    RBRACE          reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    END_S           reduce using rule 37 (assignment -> variable POWEREQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 37 (assignment -> variable POWEREQLS expression .) ]


state 150

    (97) expr_postfix -> LOCAL_VAR LPAREN RPAREN .

    EQLS            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LBRACKET        reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    DOT             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RANGE_INCL      reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RANGE_EXCL      reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    PLUS            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    MINUS           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    MULT            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    DIV             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    MOD             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    POWER           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    BREAK           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    NEXT            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    ELSIF           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    ELSE            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RETURN          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    PRINT           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    PUTS            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    WHILE           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    FOR             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LBRACE          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    DEF             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    IF              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    THEN            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    NOT             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    NIL             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    TRUE            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    FALSE           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LPAREN          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    INTEGER         reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    FLOAT           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RATIONAL        reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    COMPLEX         reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    STR             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    SYMBOL          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    REGEXP          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    CLASS           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    INSTANCE_VAR    reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    CLASS_VAR       reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    GLOBAL_VAR      reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LOCAL_VAR       reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    CONSTANT        reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    $end            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RBRACE          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    END_S           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LT              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    LE              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    GT              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    GE              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    EQ              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    NE              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    EQQ             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    MATCH           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    NMATCH          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    ARROW           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RPAREN          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    COMMA           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    RBRACKET        reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    ANDAND          reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    OROR            reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    AND             reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    OR              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    DO              reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)
    COLON           reduce using rule 97 (expr_postfix -> LOCAL_VAR LPAREN RPAREN .)


state 151

    (98) expr_postfix -> LOCAL_VAR LPAREN expr_list . RPAREN

    RPAREN          shift and go to state 193


state 152

    (102) assignment -> expr_postfix EQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    BREAK           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    NEXT            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    ELSIF           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    ELSE            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    RETURN          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    PRINT           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    PUTS            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    WHILE           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    FOR             reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    LBRACE          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    DEF             reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    IF              reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    THEN            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    NOT             reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    NIL             reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    TRUE            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    FALSE           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    LPAREN          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    INTEGER         reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    FLOAT           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    RATIONAL        reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    COMPLEX         reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    STR             reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    SYMBOL          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    REGEXP          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    CLASS           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    INSTANCE_VAR    reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    CLASS_VAR       reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    GLOBAL_VAR      reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    LOCAL_VAR       reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    CONSTANT        reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    LBRACKET        reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    $end            reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    RBRACE          reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    END_S           reduce using rule 102 (assignment -> expr_postfix EQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 102 (assignment -> expr_postfix EQLS expression .) ]


state 153

    (99) expr_postfix -> expr_postfix LBRACKET expression . RBRACKET
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    RBRACKET        shift and go to state 194
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 154

    (146) expr_postfix -> expr_postfix DOT LOCAL_VAR .
    (147) expr_postfix -> expr_postfix DOT LOCAL_VAR . LPAREN RPAREN
    (148) expr_postfix -> expr_postfix DOT LOCAL_VAR . LPAREN expr_list RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    EQLS            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LBRACKET        reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    DOT             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RANGE_INCL      reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RANGE_EXCL      reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    PLUS            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    MINUS           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    MULT            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    DIV             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    MOD             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    POWER           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    BREAK           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    NEXT            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    ELSIF           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    ELSE            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RETURN          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    PRINT           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    PUTS            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    WHILE           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    FOR             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LBRACE          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    DEF             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    IF              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    THEN            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    NOT             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    NIL             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    TRUE            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    FALSE           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    INTEGER         reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    FLOAT           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RATIONAL        reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    COMPLEX         reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    STR             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    SYMBOL          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    REGEXP          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    CLASS           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    CLASS_VAR       reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    CONSTANT        reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    $end            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RBRACE          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    END_S           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LT              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LE              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    GT              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    GE              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    EQ              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    NE              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    EQQ             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    MATCH           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    NMATCH          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    ARROW           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RPAREN          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    COMMA           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    RBRACKET        reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    ANDAND          reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    OROR            reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    AND             reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    OR              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    DO              reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    COLON           reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .)
    LPAREN          shift and go to state 195

  ! LPAREN          [ reduce using rule 146 (expr_postfix -> expr_postfix DOT LOCAL_VAR .) ]


state 155

    (38) while_stmt -> WHILE expression_logic while_enter . DO statement_list END_S while_exit
    (39) while_stmt -> WHILE expression_logic while_enter . statement_list END_S while_exit
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    DO              shift and go to state 196
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 197
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 156

    (42) for_stmt -> FOR LOCAL_VAR IN . expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> FOR LOCAL_VAR IN . expression for_enter statement_list END_S for_exit
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 198
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 157

    (72) hash_literal -> LBRACE hash_pairs_opt RBRACE .

    BREAK           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    NEXT            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    ELSIF           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    ELSE            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RETURN          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    PRINT           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    PUTS            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    WHILE           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    FOR             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LBRACE          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    DEF             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    IF              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    THEN            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    NOT             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    NIL             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    TRUE            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    FALSE           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LPAREN          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    INTEGER         reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    FLOAT           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RATIONAL        reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    COMPLEX         reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    STR             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    SYMBOL          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    REGEXP          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    MINUS           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    CLASS           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    INSTANCE_VAR    reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    CLASS_VAR       reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    GLOBAL_VAR      reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LOCAL_VAR       reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    CONSTANT        reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LBRACKET        reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    $end            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RANGE_INCL      reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RANGE_EXCL      reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    PLUS            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    MULT            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    DIV             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    MOD             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    POWER           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RBRACE          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    END_S           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LT              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    LE              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    GT              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    GE              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    EQ              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    NE              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    EQQ             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    MATCH           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    NMATCH          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    ARROW           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RPAREN          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    COMMA           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    RBRACKET        reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    ANDAND          reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    OROR            reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    AND             reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    OR              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    DO              reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)
    COLON           reduce using rule 72 (hash_literal -> LBRACE hash_pairs_opt RBRACE .)


state 158

    (8) stmt_block -> LBRACE statement_list RBRACE .

    BREAK           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    NEXT            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    ELSIF           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    PRINT           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    PUTS            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    FOR             reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    LBRACE          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    DEF             reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    THEN            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    NOT             reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    NIL             reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    TRUE            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    FALSE           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    INTEGER         reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    FLOAT           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    RATIONAL        reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    COMPLEX         reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    STR             reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    SYMBOL          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    REGEXP          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    MINUS           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    CLASS           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    INSTANCE_VAR    reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    CLASS_VAR       reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    GLOBAL_VAR      reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    LOCAL_VAR       reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    CONSTANT        reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    LBRACKET        reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    $end            reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)
    END_S           reduce using rule 8 (stmt_block -> LBRACE statement_list RBRACE .)


state 159

    (75) hash_pairs -> hash_pairs COMMA . hash_pair
    (77) hash_pair -> . expression ARROW expression
    (78) hash_pair -> . SYMBOL COLON expression
    (79) hash_pair -> . LOCAL_VAR COLON expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    SYMBOL          shift and go to state 104
    LOCAL_VAR       shift and go to state 105
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    hash_pair                      shift and go to state 199
    expression                     shift and go to state 139
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 160

    (77) hash_pair -> expression ARROW . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 200
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 161

    (78) hash_pair -> SYMBOL COLON . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 201
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 162

    (79) hash_pair -> LOCAL_VAR COLON . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 202
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 163

    (109) parameter -> LOCAL_VAR .
    (110) parameter -> LOCAL_VAR . EQLS expression
    (27) variable -> LOCAL_VAR .
    (97) expr_postfix -> LOCAL_VAR . LPAREN RPAREN
    (98) expr_postfix -> LOCAL_VAR . LPAREN expr_list RPAREN

  ! shift/reduce conflict for EQLS resolved as shift
  ! reduce/reduce conflict for MINUS resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for END_S resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for BREAK resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for NEXT resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for ELSIF resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for ELSE resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for RETURN resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for PRINT resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for PUTS resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for WHILE resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for FOR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for LBRACE resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for DEF resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for IF resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for THEN resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for NOT resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for NIL resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for TRUE resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for FALSE resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for LPAREN resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for INTEGER resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for FLOAT resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for STR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for REGEXP resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for CLASS resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 27 (variable -> LOCAL_VAR .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (variable -> LOCAL_VAR .)
  ! shift/reduce conflict for LPAREN resolved as shift
    COMMA           reduce using rule 109 (parameter -> LOCAL_VAR .)
    COLON           reduce using rule 109 (parameter -> LOCAL_VAR .)
    EQLS            shift and go to state 203
    PLUSEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUSEQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    MULTEQLS        reduce using rule 27 (variable -> LOCAL_VAR .)
    DIVEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    MODEQLS         reduce using rule 27 (variable -> LOCAL_VAR .)
    POWEREQLS       reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_INCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    RANGE_EXCL      reduce using rule 27 (variable -> LOCAL_VAR .)
    PLUS            reduce using rule 27 (variable -> LOCAL_VAR .)
    MINUS           reduce using rule 27 (variable -> LOCAL_VAR .)
    MULT            reduce using rule 27 (variable -> LOCAL_VAR .)
    DIV             reduce using rule 27 (variable -> LOCAL_VAR .)
    MOD             reduce using rule 27 (variable -> LOCAL_VAR .)
    POWER           reduce using rule 27 (variable -> LOCAL_VAR .)
    END_S           reduce using rule 27 (variable -> LOCAL_VAR .)
    BREAK           reduce using rule 27 (variable -> LOCAL_VAR .)
    NEXT            reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSIF           reduce using rule 27 (variable -> LOCAL_VAR .)
    ELSE            reduce using rule 27 (variable -> LOCAL_VAR .)
    RETURN          reduce using rule 27 (variable -> LOCAL_VAR .)
    PRINT           reduce using rule 27 (variable -> LOCAL_VAR .)
    PUTS            reduce using rule 27 (variable -> LOCAL_VAR .)
    WHILE           reduce using rule 27 (variable -> LOCAL_VAR .)
    FOR             reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACE          reduce using rule 27 (variable -> LOCAL_VAR .)
    DEF             reduce using rule 27 (variable -> LOCAL_VAR .)
    IF              reduce using rule 27 (variable -> LOCAL_VAR .)
    THEN            reduce using rule 27 (variable -> LOCAL_VAR .)
    NOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    NIL             reduce using rule 27 (variable -> LOCAL_VAR .)
    TRUE            reduce using rule 27 (variable -> LOCAL_VAR .)
    FALSE           reduce using rule 27 (variable -> LOCAL_VAR .)
    INTEGER         reduce using rule 27 (variable -> LOCAL_VAR .)
    FLOAT           reduce using rule 27 (variable -> LOCAL_VAR .)
    RATIONAL        reduce using rule 27 (variable -> LOCAL_VAR .)
    COMPLEX         reduce using rule 27 (variable -> LOCAL_VAR .)
    STR             reduce using rule 27 (variable -> LOCAL_VAR .)
    SYMBOL          reduce using rule 27 (variable -> LOCAL_VAR .)
    REGEXP          reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS           reduce using rule 27 (variable -> LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 27 (variable -> LOCAL_VAR .)
    CLASS_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 27 (variable -> LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 27 (variable -> LOCAL_VAR .)
    CONSTANT        reduce using rule 27 (variable -> LOCAL_VAR .)
    LBRACKET        reduce using rule 27 (variable -> LOCAL_VAR .)
    DOT             reduce using rule 27 (variable -> LOCAL_VAR .)
    RPAREN          reduce using rule 27 (variable -> LOCAL_VAR .)
    LPAREN          shift and go to state 92

  ! BREAK           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! NEXT            [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! ELSIF           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! ELSE            [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! RETURN          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! PRINT           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! PUTS            [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! WHILE           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! FOR             [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! LBRACE          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! DEF             [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! IF              [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! THEN            [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! NOT             [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! NIL             [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! TRUE            [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! FALSE           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! LPAREN          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! INTEGER         [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! FLOAT           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! RATIONAL        [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! COMPLEX         [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! STR             [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! SYMBOL          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! REGEXP          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! MINUS           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! CLASS           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! INSTANCE_VAR    [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! CLASS_VAR       [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! GLOBAL_VAR      [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! LOCAL_VAR       [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! CONSTANT        [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! LBRACKET        [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! END_S           [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! RPAREN          [ reduce using rule 109 (parameter -> LOCAL_VAR .) ]
  ! EQLS            [ reduce using rule 27 (variable -> LOCAL_VAR .) ]
  ! LPAREN          [ reduce using rule 27 (variable -> LOCAL_VAR .) ]


state 164

    (103) function_def -> DEF LOCAL_VAR statement_list . END_S
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 204
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 165

    (104) function_def -> DEF LOCAL_VAR LPAREN . param_list RPAREN statement_list END_S
    (136) expression -> LPAREN . expression RPAREN
    (95) primary -> LPAREN . expression RPAREN
    (107) param_list -> . parameter
    (108) param_list -> . param_list COMMA parameter
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (109) parameter -> . LOCAL_VAR
    (110) parameter -> . LOCAL_VAR EQLS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LOCAL_VAR       shift and go to state 163
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    param_list                     shift and go to state 205
    expression                     shift and go to state 107
    parameter                      shift and go to state 169
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 166

    (105) optional_params -> param_list .
    (108) param_list -> param_list . COMMA parameter

    COLON           reduce using rule 105 (optional_params -> param_list .)
    BREAK           reduce using rule 105 (optional_params -> param_list .)
    NEXT            reduce using rule 105 (optional_params -> param_list .)
    ELSIF           reduce using rule 105 (optional_params -> param_list .)
    ELSE            reduce using rule 105 (optional_params -> param_list .)
    RETURN          reduce using rule 105 (optional_params -> param_list .)
    PRINT           reduce using rule 105 (optional_params -> param_list .)
    PUTS            reduce using rule 105 (optional_params -> param_list .)
    WHILE           reduce using rule 105 (optional_params -> param_list .)
    FOR             reduce using rule 105 (optional_params -> param_list .)
    LBRACE          reduce using rule 105 (optional_params -> param_list .)
    DEF             reduce using rule 105 (optional_params -> param_list .)
    IF              reduce using rule 105 (optional_params -> param_list .)
    THEN            reduce using rule 105 (optional_params -> param_list .)
    NOT             reduce using rule 105 (optional_params -> param_list .)
    NIL             reduce using rule 105 (optional_params -> param_list .)
    TRUE            reduce using rule 105 (optional_params -> param_list .)
    FALSE           reduce using rule 105 (optional_params -> param_list .)
    LPAREN          reduce using rule 105 (optional_params -> param_list .)
    INTEGER         reduce using rule 105 (optional_params -> param_list .)
    FLOAT           reduce using rule 105 (optional_params -> param_list .)
    RATIONAL        reduce using rule 105 (optional_params -> param_list .)
    COMPLEX         reduce using rule 105 (optional_params -> param_list .)
    STR             reduce using rule 105 (optional_params -> param_list .)
    SYMBOL          reduce using rule 105 (optional_params -> param_list .)
    REGEXP          reduce using rule 105 (optional_params -> param_list .)
    MINUS           reduce using rule 105 (optional_params -> param_list .)
    CLASS           reduce using rule 105 (optional_params -> param_list .)
    INSTANCE_VAR    reduce using rule 105 (optional_params -> param_list .)
    CLASS_VAR       reduce using rule 105 (optional_params -> param_list .)
    GLOBAL_VAR      reduce using rule 105 (optional_params -> param_list .)
    LOCAL_VAR       reduce using rule 105 (optional_params -> param_list .)
    CONSTANT        reduce using rule 105 (optional_params -> param_list .)
    LBRACKET        reduce using rule 105 (optional_params -> param_list .)
    END_S           reduce using rule 105 (optional_params -> param_list .)
    COMMA           shift and go to state 206


state 167

    (112) function_def -> DEF LOCAL_VAR optional_params . optional_ret statement_list END_S
    (113) optional_ret -> . COLON TYPE
    (114) optional_ret -> . empty
    (111) empty -> .

    COLON           shift and go to state 208
    BREAK           reduce using rule 111 (empty -> .)
    NEXT            reduce using rule 111 (empty -> .)
    ELSIF           reduce using rule 111 (empty -> .)
    ELSE            reduce using rule 111 (empty -> .)
    RETURN          reduce using rule 111 (empty -> .)
    PRINT           reduce using rule 111 (empty -> .)
    PUTS            reduce using rule 111 (empty -> .)
    WHILE           reduce using rule 111 (empty -> .)
    FOR             reduce using rule 111 (empty -> .)
    LBRACE          reduce using rule 111 (empty -> .)
    DEF             reduce using rule 111 (empty -> .)
    IF              reduce using rule 111 (empty -> .)
    THEN            reduce using rule 111 (empty -> .)
    NOT             reduce using rule 111 (empty -> .)
    NIL             reduce using rule 111 (empty -> .)
    TRUE            reduce using rule 111 (empty -> .)
    FALSE           reduce using rule 111 (empty -> .)
    LPAREN          reduce using rule 111 (empty -> .)
    INTEGER         reduce using rule 111 (empty -> .)
    FLOAT           reduce using rule 111 (empty -> .)
    RATIONAL        reduce using rule 111 (empty -> .)
    COMPLEX         reduce using rule 111 (empty -> .)
    STR             reduce using rule 111 (empty -> .)
    SYMBOL          reduce using rule 111 (empty -> .)
    REGEXP          reduce using rule 111 (empty -> .)
    MINUS           reduce using rule 111 (empty -> .)
    CLASS           reduce using rule 111 (empty -> .)
    INSTANCE_VAR    reduce using rule 111 (empty -> .)
    CLASS_VAR       reduce using rule 111 (empty -> .)
    GLOBAL_VAR      reduce using rule 111 (empty -> .)
    LOCAL_VAR       reduce using rule 111 (empty -> .)
    CONSTANT        reduce using rule 111 (empty -> .)
    LBRACKET        reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)

    optional_ret                   shift and go to state 207
    empty                          shift and go to state 209

state 168

    (106) optional_params -> empty .
    (48) optional_then -> empty .
    (49) elsif_list -> empty .
    (51) else_part -> empty .

  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
    COLON           reduce using rule 106 (optional_params -> empty .)
    END_S           reduce using rule 48 (optional_then -> empty .)
    BREAK           reduce using rule 48 (optional_then -> empty .)
    NEXT            reduce using rule 48 (optional_then -> empty .)
    ELSIF           reduce using rule 48 (optional_then -> empty .)
    ELSE            reduce using rule 48 (optional_then -> empty .)
    RETURN          reduce using rule 48 (optional_then -> empty .)
    PRINT           reduce using rule 48 (optional_then -> empty .)
    PUTS            reduce using rule 48 (optional_then -> empty .)
    WHILE           reduce using rule 48 (optional_then -> empty .)
    FOR             reduce using rule 48 (optional_then -> empty .)
    LBRACE          reduce using rule 48 (optional_then -> empty .)
    DEF             reduce using rule 48 (optional_then -> empty .)
    IF              reduce using rule 48 (optional_then -> empty .)
    THEN            reduce using rule 48 (optional_then -> empty .)
    NOT             reduce using rule 48 (optional_then -> empty .)
    NIL             reduce using rule 48 (optional_then -> empty .)
    TRUE            reduce using rule 48 (optional_then -> empty .)
    FALSE           reduce using rule 48 (optional_then -> empty .)
    LPAREN          reduce using rule 48 (optional_then -> empty .)
    INTEGER         reduce using rule 48 (optional_then -> empty .)
    FLOAT           reduce using rule 48 (optional_then -> empty .)
    RATIONAL        reduce using rule 48 (optional_then -> empty .)
    COMPLEX         reduce using rule 48 (optional_then -> empty .)
    STR             reduce using rule 48 (optional_then -> empty .)
    SYMBOL          reduce using rule 48 (optional_then -> empty .)
    REGEXP          reduce using rule 48 (optional_then -> empty .)
    MINUS           reduce using rule 48 (optional_then -> empty .)
    CLASS           reduce using rule 48 (optional_then -> empty .)
    INSTANCE_VAR    reduce using rule 48 (optional_then -> empty .)
    CLASS_VAR       reduce using rule 48 (optional_then -> empty .)
    GLOBAL_VAR      reduce using rule 48 (optional_then -> empty .)
    LOCAL_VAR       reduce using rule 48 (optional_then -> empty .)
    CONSTANT        reduce using rule 48 (optional_then -> empty .)
    LBRACKET        reduce using rule 48 (optional_then -> empty .)

  ! BREAK           [ reduce using rule 106 (optional_params -> empty .) ]
  ! NEXT            [ reduce using rule 106 (optional_params -> empty .) ]
  ! ELSIF           [ reduce using rule 106 (optional_params -> empty .) ]
  ! ELSE            [ reduce using rule 106 (optional_params -> empty .) ]
  ! RETURN          [ reduce using rule 106 (optional_params -> empty .) ]
  ! PRINT           [ reduce using rule 106 (optional_params -> empty .) ]
  ! PUTS            [ reduce using rule 106 (optional_params -> empty .) ]
  ! WHILE           [ reduce using rule 106 (optional_params -> empty .) ]
  ! FOR             [ reduce using rule 106 (optional_params -> empty .) ]
  ! LBRACE          [ reduce using rule 106 (optional_params -> empty .) ]
  ! DEF             [ reduce using rule 106 (optional_params -> empty .) ]
  ! IF              [ reduce using rule 106 (optional_params -> empty .) ]
  ! THEN            [ reduce using rule 106 (optional_params -> empty .) ]
  ! NOT             [ reduce using rule 106 (optional_params -> empty .) ]
  ! NIL             [ reduce using rule 106 (optional_params -> empty .) ]
  ! TRUE            [ reduce using rule 106 (optional_params -> empty .) ]
  ! FALSE           [ reduce using rule 106 (optional_params -> empty .) ]
  ! LPAREN          [ reduce using rule 106 (optional_params -> empty .) ]
  ! INTEGER         [ reduce using rule 106 (optional_params -> empty .) ]
  ! FLOAT           [ reduce using rule 106 (optional_params -> empty .) ]
  ! RATIONAL        [ reduce using rule 106 (optional_params -> empty .) ]
  ! COMPLEX         [ reduce using rule 106 (optional_params -> empty .) ]
  ! STR             [ reduce using rule 106 (optional_params -> empty .) ]
  ! SYMBOL          [ reduce using rule 106 (optional_params -> empty .) ]
  ! REGEXP          [ reduce using rule 106 (optional_params -> empty .) ]
  ! MINUS           [ reduce using rule 106 (optional_params -> empty .) ]
  ! CLASS           [ reduce using rule 106 (optional_params -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 106 (optional_params -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 106 (optional_params -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 106 (optional_params -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 106 (optional_params -> empty .) ]
  ! CONSTANT        [ reduce using rule 106 (optional_params -> empty .) ]
  ! LBRACKET        [ reduce using rule 106 (optional_params -> empty .) ]
  ! END_S           [ reduce using rule 106 (optional_params -> empty .) ]
  ! ELSIF           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NEXT            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! ELSE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RETURN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PRINT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PUTS            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! WHILE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FOR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACE          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! DEF             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! IF              [ reduce using rule 49 (elsif_list -> empty .) ]
  ! THEN            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NOT             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NIL             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! TRUE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FALSE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LPAREN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INTEGER         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FLOAT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RATIONAL        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! COMPLEX         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! STR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! SYMBOL          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! REGEXP          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! MINUS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CONSTANT        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACKET        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 51 (else_part -> empty .) ]
  ! BREAK           [ reduce using rule 51 (else_part -> empty .) ]
  ! NEXT            [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSIF           [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSE            [ reduce using rule 51 (else_part -> empty .) ]
  ! RETURN          [ reduce using rule 51 (else_part -> empty .) ]
  ! PRINT           [ reduce using rule 51 (else_part -> empty .) ]
  ! PUTS            [ reduce using rule 51 (else_part -> empty .) ]
  ! WHILE           [ reduce using rule 51 (else_part -> empty .) ]
  ! FOR             [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACE          [ reduce using rule 51 (else_part -> empty .) ]
  ! DEF             [ reduce using rule 51 (else_part -> empty .) ]
  ! IF              [ reduce using rule 51 (else_part -> empty .) ]
  ! THEN            [ reduce using rule 51 (else_part -> empty .) ]
  ! NOT             [ reduce using rule 51 (else_part -> empty .) ]
  ! NIL             [ reduce using rule 51 (else_part -> empty .) ]
  ! TRUE            [ reduce using rule 51 (else_part -> empty .) ]
  ! FALSE           [ reduce using rule 51 (else_part -> empty .) ]
  ! LPAREN          [ reduce using rule 51 (else_part -> empty .) ]
  ! INTEGER         [ reduce using rule 51 (else_part -> empty .) ]
  ! FLOAT           [ reduce using rule 51 (else_part -> empty .) ]
  ! RATIONAL        [ reduce using rule 51 (else_part -> empty .) ]
  ! COMPLEX         [ reduce using rule 51 (else_part -> empty .) ]
  ! STR             [ reduce using rule 51 (else_part -> empty .) ]
  ! SYMBOL          [ reduce using rule 51 (else_part -> empty .) ]
  ! REGEXP          [ reduce using rule 51 (else_part -> empty .) ]
  ! MINUS           [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS           [ reduce using rule 51 (else_part -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 51 (else_part -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! CONSTANT        [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACKET        [ reduce using rule 51 (else_part -> empty .) ]


state 169

    (107) param_list -> parameter .

    COMMA           reduce using rule 107 (param_list -> parameter .)
    COLON           reduce using rule 107 (param_list -> parameter .)
    BREAK           reduce using rule 107 (param_list -> parameter .)
    NEXT            reduce using rule 107 (param_list -> parameter .)
    ELSIF           reduce using rule 107 (param_list -> parameter .)
    ELSE            reduce using rule 107 (param_list -> parameter .)
    RETURN          reduce using rule 107 (param_list -> parameter .)
    PRINT           reduce using rule 107 (param_list -> parameter .)
    PUTS            reduce using rule 107 (param_list -> parameter .)
    WHILE           reduce using rule 107 (param_list -> parameter .)
    FOR             reduce using rule 107 (param_list -> parameter .)
    LBRACE          reduce using rule 107 (param_list -> parameter .)
    DEF             reduce using rule 107 (param_list -> parameter .)
    IF              reduce using rule 107 (param_list -> parameter .)
    THEN            reduce using rule 107 (param_list -> parameter .)
    NOT             reduce using rule 107 (param_list -> parameter .)
    NIL             reduce using rule 107 (param_list -> parameter .)
    TRUE            reduce using rule 107 (param_list -> parameter .)
    FALSE           reduce using rule 107 (param_list -> parameter .)
    LPAREN          reduce using rule 107 (param_list -> parameter .)
    INTEGER         reduce using rule 107 (param_list -> parameter .)
    FLOAT           reduce using rule 107 (param_list -> parameter .)
    RATIONAL        reduce using rule 107 (param_list -> parameter .)
    COMPLEX         reduce using rule 107 (param_list -> parameter .)
    STR             reduce using rule 107 (param_list -> parameter .)
    SYMBOL          reduce using rule 107 (param_list -> parameter .)
    REGEXP          reduce using rule 107 (param_list -> parameter .)
    MINUS           reduce using rule 107 (param_list -> parameter .)
    CLASS           reduce using rule 107 (param_list -> parameter .)
    INSTANCE_VAR    reduce using rule 107 (param_list -> parameter .)
    CLASS_VAR       reduce using rule 107 (param_list -> parameter .)
    GLOBAL_VAR      reduce using rule 107 (param_list -> parameter .)
    LOCAL_VAR       reduce using rule 107 (param_list -> parameter .)
    CONSTANT        reduce using rule 107 (param_list -> parameter .)
    LBRACKET        reduce using rule 107 (param_list -> parameter .)
    END_S           reduce using rule 107 (param_list -> parameter .)
    RPAREN          reduce using rule 107 (param_list -> parameter .)


state 170

    (136) expression -> LPAREN expression RPAREN .
    (95) primary -> LPAREN expression RPAREN .

  ! reduce/reduce conflict for LBRACKET resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RANGE_INCL resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RANGE_EXCL resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for PLUS resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for MINUS resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for MULT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for DIV resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for MOD resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for POWER resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for NEXT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for ELSIF resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for ELSE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for PRINT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for PUTS resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for WHILE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for LBRACE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for DEF resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for THEN resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for NOT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for NIL resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for TRUE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for FALSE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for LPAREN resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for INTEGER resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for FLOAT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for STR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for REGEXP resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for CLASS resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for END_S resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for LT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for LE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for GT resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for GE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for EQ resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for NE resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for EQQ resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for MATCH resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for NMATCH resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for ARROW resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RPAREN resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for COMMA resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for ANDAND resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for OROR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for AND resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for OR resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for DO resolved using rule 95 (primary -> LPAREN expression RPAREN .)
  ! reduce/reduce conflict for COLON resolved using rule 95 (primary -> LPAREN expression RPAREN .)
    EQLS            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    DOT             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RANGE_INCL      reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RANGE_EXCL      reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    MULT            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    DIV             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    MOD             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    POWER           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    NEXT            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    PRINT           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    FOR             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    DEF             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    IF              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    THEN            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    NOT             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    NIL             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    TRUE            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    FALSE           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RATIONAL        reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    COMPLEX         reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    STR             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    SYMBOL          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    REGEXP          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    CLASS           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    INSTANCE_VAR    reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    CLASS_VAR       reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    GLOBAL_VAR      reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LOCAL_VAR       reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    CONSTANT        reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    $end            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    END_S           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LT              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    LE              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    GT              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    GE              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    EQ              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    NE              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    EQQ             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    MATCH           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    NMATCH          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    ARROW           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    ANDAND          reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    OROR            reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    DO              reduce using rule 95 (primary -> LPAREN expression RPAREN .)
    COLON           reduce using rule 95 (primary -> LPAREN expression RPAREN .)

  ! RANGE_INCL      [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RANGE_EXCL      [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! PLUS            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! MINUS           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! MULT            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! DIV             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! MOD             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! POWER           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! BREAK           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! NEXT            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! ELSIF           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! ELSE            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RETURN          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! PRINT           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! PUTS            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! WHILE           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! FOR             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LBRACE          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! DEF             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! IF              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! THEN            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! NOT             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! NIL             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! TRUE            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! FALSE           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LPAREN          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! INTEGER         [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! FLOAT           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RATIONAL        [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! COMPLEX         [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! STR             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! SYMBOL          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! REGEXP          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! CLASS           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! INSTANCE_VAR    [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! CLASS_VAR       [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! GLOBAL_VAR      [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LOCAL_VAR       [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! CONSTANT        [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LBRACKET        [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! $end            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RBRACE          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! END_S           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LT              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! LE              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! GT              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! GE              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! EQ              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! NE              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! EQQ             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! MATCH           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! NMATCH          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! ARROW           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RPAREN          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! COMMA           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! RBRACKET        [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! ANDAND          [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! OROR            [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! AND             [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! OR              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! DO              [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]
  ! COLON           [ reduce using rule 136 (expression -> LPAREN expression RPAREN .) ]


state 171

    (46) if_stmt -> IF expression_logic optional_then . stmt_block elsif_list else_part END_S
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 210
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 172

    (120) class_def -> CLASS CONSTANT stmt_block . END_S
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 211
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 173

    (121) class_def -> CLASS CONSTANT opt_inherit . stmt_block END_S
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 212
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 174

    (122) opt_inherit -> LT . CONSTANT

    CONSTANT        shift and go to state 213


state 175

    (123) opt_inherit -> empty .
    (48) optional_then -> empty .
    (49) elsif_list -> empty .
    (51) else_part -> empty .

  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
    END_S           reduce using rule 48 (optional_then -> empty .)
    BREAK           reduce using rule 48 (optional_then -> empty .)
    NEXT            reduce using rule 48 (optional_then -> empty .)
    ELSIF           reduce using rule 48 (optional_then -> empty .)
    ELSE            reduce using rule 48 (optional_then -> empty .)
    RETURN          reduce using rule 48 (optional_then -> empty .)
    PRINT           reduce using rule 48 (optional_then -> empty .)
    PUTS            reduce using rule 48 (optional_then -> empty .)
    WHILE           reduce using rule 48 (optional_then -> empty .)
    FOR             reduce using rule 48 (optional_then -> empty .)
    LBRACE          reduce using rule 48 (optional_then -> empty .)
    DEF             reduce using rule 48 (optional_then -> empty .)
    IF              reduce using rule 48 (optional_then -> empty .)
    THEN            reduce using rule 48 (optional_then -> empty .)
    NOT             reduce using rule 48 (optional_then -> empty .)
    NIL             reduce using rule 48 (optional_then -> empty .)
    TRUE            reduce using rule 48 (optional_then -> empty .)
    FALSE           reduce using rule 48 (optional_then -> empty .)
    LPAREN          reduce using rule 48 (optional_then -> empty .)
    INTEGER         reduce using rule 48 (optional_then -> empty .)
    FLOAT           reduce using rule 48 (optional_then -> empty .)
    RATIONAL        reduce using rule 48 (optional_then -> empty .)
    COMPLEX         reduce using rule 48 (optional_then -> empty .)
    STR             reduce using rule 48 (optional_then -> empty .)
    SYMBOL          reduce using rule 48 (optional_then -> empty .)
    REGEXP          reduce using rule 48 (optional_then -> empty .)
    MINUS           reduce using rule 48 (optional_then -> empty .)
    CLASS           reduce using rule 48 (optional_then -> empty .)
    INSTANCE_VAR    reduce using rule 48 (optional_then -> empty .)
    CLASS_VAR       reduce using rule 48 (optional_then -> empty .)
    GLOBAL_VAR      reduce using rule 48 (optional_then -> empty .)
    LOCAL_VAR       reduce using rule 48 (optional_then -> empty .)
    CONSTANT        reduce using rule 48 (optional_then -> empty .)
    LBRACKET        reduce using rule 48 (optional_then -> empty .)

  ! LBRACE          [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! BREAK           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! NEXT            [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! ELSIF           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! ELSE            [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! RETURN          [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! PRINT           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! PUTS            [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! WHILE           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! FOR             [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! DEF             [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! IF              [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! THEN            [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! NOT             [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! NIL             [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! TRUE            [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! FALSE           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! LPAREN          [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! INTEGER         [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! FLOAT           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! RATIONAL        [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! COMPLEX         [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! STR             [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! SYMBOL          [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! REGEXP          [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! MINUS           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! CLASS           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! CONSTANT        [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! LBRACKET        [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! END_S           [ reduce using rule 123 (opt_inherit -> empty .) ]
  ! ELSIF           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NEXT            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! ELSE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RETURN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PRINT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PUTS            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! WHILE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FOR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACE          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! DEF             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! IF              [ reduce using rule 49 (elsif_list -> empty .) ]
  ! THEN            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NOT             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NIL             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! TRUE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FALSE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LPAREN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INTEGER         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FLOAT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RATIONAL        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! COMPLEX         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! STR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! SYMBOL          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! REGEXP          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! MINUS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CONSTANT        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACKET        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 51 (else_part -> empty .) ]
  ! BREAK           [ reduce using rule 51 (else_part -> empty .) ]
  ! NEXT            [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSIF           [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSE            [ reduce using rule 51 (else_part -> empty .) ]
  ! RETURN          [ reduce using rule 51 (else_part -> empty .) ]
  ! PRINT           [ reduce using rule 51 (else_part -> empty .) ]
  ! PUTS            [ reduce using rule 51 (else_part -> empty .) ]
  ! WHILE           [ reduce using rule 51 (else_part -> empty .) ]
  ! FOR             [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACE          [ reduce using rule 51 (else_part -> empty .) ]
  ! DEF             [ reduce using rule 51 (else_part -> empty .) ]
  ! IF              [ reduce using rule 51 (else_part -> empty .) ]
  ! THEN            [ reduce using rule 51 (else_part -> empty .) ]
  ! NOT             [ reduce using rule 51 (else_part -> empty .) ]
  ! NIL             [ reduce using rule 51 (else_part -> empty .) ]
  ! TRUE            [ reduce using rule 51 (else_part -> empty .) ]
  ! FALSE           [ reduce using rule 51 (else_part -> empty .) ]
  ! LPAREN          [ reduce using rule 51 (else_part -> empty .) ]
  ! INTEGER         [ reduce using rule 51 (else_part -> empty .) ]
  ! FLOAT           [ reduce using rule 51 (else_part -> empty .) ]
  ! RATIONAL        [ reduce using rule 51 (else_part -> empty .) ]
  ! COMPLEX         [ reduce using rule 51 (else_part -> empty .) ]
  ! STR             [ reduce using rule 51 (else_part -> empty .) ]
  ! SYMBOL          [ reduce using rule 51 (else_part -> empty .) ]
  ! REGEXP          [ reduce using rule 51 (else_part -> empty .) ]
  ! MINUS           [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS           [ reduce using rule 51 (else_part -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 51 (else_part -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! CONSTANT        [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACKET        [ reduce using rule 51 (else_part -> empty .) ]


state 176

    (86) array_literal -> LBRACKET expr_list RBRACKET .

    EQLS            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LBRACKET        reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    DOT             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RANGE_INCL      reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RANGE_EXCL      reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    PLUS            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    MINUS           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    MULT            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    DIV             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    MOD             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    POWER           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    BREAK           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    NEXT            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    ELSIF           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    ELSE            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RETURN          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    PRINT           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    PUTS            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    WHILE           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    FOR             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LBRACE          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    DEF             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    IF              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    THEN            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    NOT             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    NIL             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    TRUE            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    FALSE           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LPAREN          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    INTEGER         reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    FLOAT           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RATIONAL        reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    COMPLEX         reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    STR             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    SYMBOL          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    REGEXP          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    CLASS           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    INSTANCE_VAR    reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    CLASS_VAR       reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    GLOBAL_VAR      reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LOCAL_VAR       reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    CONSTANT        reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    $end            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RBRACE          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    END_S           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LT              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    LE              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    GT              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    GE              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    EQ              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    NE              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    EQQ             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    MATCH           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    NMATCH          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    ARROW           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RPAREN          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    COMMA           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    RBRACKET        reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    ANDAND          reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    OROR            reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    AND             reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    OR              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    DO              reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)
    COLON           reduce using rule 86 (array_literal -> LBRACKET expr_list RBRACKET .)


state 177

    (84) expr_list -> expression COMMA . expr_list
    (83) expr_list -> . expression
    (84) expr_list -> . expression COMMA expr_list
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 114
    expr_list                      shift and go to state 214
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 178

    (50) elsif_list -> elsif_list ELSIF expression_logic optional_then . stmt_block
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    $end            reduce using rule 111 (empty -> .)
    RBRACE          reduce using rule 111 (empty -> .)
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    elsif_list                     shift and go to state 16
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 215
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 179

    (53) statement -> ELSIF expression_logic optional_then stmt_block .
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for BREAK resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NEXT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSIF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PUTS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for DEF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for IF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for THEN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NIL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for STR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for REGEXP resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 19 (statement -> stmt_block .)
    RBRACE          reduce using rule 19 (statement -> stmt_block .)
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! NEXT            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! ELSIF           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! ELSE            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! RETURN          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! PRINT           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! PUTS            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! WHILE           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! FOR             [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! LBRACE          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! DEF             [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! IF              [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! THEN            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! NOT             [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! NIL             [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! TRUE            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! FALSE           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! LPAREN          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! INTEGER         [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! FLOAT           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! RATIONAL        [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! COMPLEX         [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! STR             [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! SYMBOL          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! REGEXP          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! MINUS           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! CLASS           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! CONSTANT        [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! LBRACKET        [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! $end            [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! RBRACE          [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! END_S           [ reduce using rule 53 (statement -> ELSIF expression_logic optional_then stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 180

    (57) expression_logic -> expression_logic ANDAND expression_logic .
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic

    ANDAND          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    OROR            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    AND             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    OR              reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    THEN            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    LBRACE          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    BREAK           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    NEXT            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    ELSIF           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    ELSE            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    RETURN          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    PRINT           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    PUTS            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    WHILE           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    FOR             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    DEF             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    IF              reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    NOT             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    NIL             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    TRUE            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    FALSE           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    LPAREN          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    INTEGER         reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    FLOAT           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    RATIONAL        reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    COMPLEX         reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    STR             reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    SYMBOL          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    REGEXP          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    MINUS           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    CLASS           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    INSTANCE_VAR    reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    CLASS_VAR       reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    GLOBAL_VAR      reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    LOCAL_VAR       reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    CONSTANT        reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    LBRACKET        reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    $end            reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    RBRACE          reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    END_S           reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)
    DO              reduce using rule 57 (expression_logic -> expression_logic ANDAND expression_logic .)

  ! ANDAND          [ shift and go to state 125 ]
  ! OROR            [ shift and go to state 126 ]
  ! AND             [ shift and go to state 127 ]
  ! OR              [ shift and go to state 128 ]


state 181

    (58) expression_logic -> expression_logic OROR expression_logic .
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic

    OROR            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    OR              reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    THEN            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    LBRACE          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    BREAK           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    NEXT            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    ELSIF           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    ELSE            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    RETURN          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    PRINT           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    PUTS            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    WHILE           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    FOR             reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    DEF             reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    IF              reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    NOT             reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    NIL             reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    TRUE            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    FALSE           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    LPAREN          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    INTEGER         reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    FLOAT           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    RATIONAL        reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    COMPLEX         reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    STR             reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    SYMBOL          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    REGEXP          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    MINUS           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    CLASS           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    INSTANCE_VAR    reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    CLASS_VAR       reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    GLOBAL_VAR      reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    LOCAL_VAR       reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    CONSTANT        reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    LBRACKET        reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    $end            reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    RBRACE          reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    END_S           reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    DO              reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .)
    ANDAND          shift and go to state 125
    AND             shift and go to state 127

  ! ANDAND          [ reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .) ]
  ! AND             [ reduce using rule 58 (expression_logic -> expression_logic OROR expression_logic .) ]
  ! OROR            [ shift and go to state 126 ]
  ! OR              [ shift and go to state 128 ]


state 182

    (59) expression_logic -> expression_logic AND expression_logic .
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic

    ANDAND          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    OROR            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    AND             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    OR              reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    THEN            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    LBRACE          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    BREAK           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    NEXT            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    ELSIF           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    ELSE            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    RETURN          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    PRINT           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    PUTS            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    WHILE           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    FOR             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    DEF             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    IF              reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    NOT             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    NIL             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    TRUE            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    FALSE           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    LPAREN          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    INTEGER         reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    FLOAT           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    RATIONAL        reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    COMPLEX         reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    STR             reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    SYMBOL          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    REGEXP          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    MINUS           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    CLASS           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    INSTANCE_VAR    reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    CLASS_VAR       reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    GLOBAL_VAR      reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    LOCAL_VAR       reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    CONSTANT        reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    LBRACKET        reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    $end            reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    RBRACE          reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    END_S           reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)
    DO              reduce using rule 59 (expression_logic -> expression_logic AND expression_logic .)

  ! ANDAND          [ shift and go to state 125 ]
  ! OROR            [ shift and go to state 126 ]
  ! AND             [ shift and go to state 127 ]
  ! OR              [ shift and go to state 128 ]


state 183

    (60) expression_logic -> expression_logic OR expression_logic .
    (57) expression_logic -> expression_logic . ANDAND expression_logic
    (58) expression_logic -> expression_logic . OROR expression_logic
    (59) expression_logic -> expression_logic . AND expression_logic
    (60) expression_logic -> expression_logic . OR expression_logic

    OROR            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    OR              reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    THEN            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    LBRACE          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    BREAK           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    NEXT            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    ELSIF           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    ELSE            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    RETURN          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    PRINT           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    PUTS            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    WHILE           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    FOR             reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    DEF             reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    IF              reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    NOT             reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    NIL             reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    TRUE            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    FALSE           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    LPAREN          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    INTEGER         reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    FLOAT           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    RATIONAL        reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    COMPLEX         reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    STR             reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    SYMBOL          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    REGEXP          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    MINUS           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    CLASS           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    INSTANCE_VAR    reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    CLASS_VAR       reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    GLOBAL_VAR      reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    LOCAL_VAR       reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    CONSTANT        reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    LBRACKET        reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    $end            reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    RBRACE          reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    END_S           reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    DO              reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .)
    ANDAND          shift and go to state 125
    AND             shift and go to state 127

  ! ANDAND          [ reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .) ]
  ! AND             [ reduce using rule 60 (expression_logic -> expression_logic OR expression_logic .) ]
  ! OROR            [ shift and go to state 126 ]
  ! OR              [ shift and go to state 128 ]


state 184

    (62) expression_compare -> expression LT expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 62 (expression_compare -> expression LT expression .)
    OROR            reduce using rule 62 (expression_compare -> expression LT expression .)
    AND             reduce using rule 62 (expression_compare -> expression LT expression .)
    OR              reduce using rule 62 (expression_compare -> expression LT expression .)
    THEN            reduce using rule 62 (expression_compare -> expression LT expression .)
    LBRACE          reduce using rule 62 (expression_compare -> expression LT expression .)
    BREAK           reduce using rule 62 (expression_compare -> expression LT expression .)
    NEXT            reduce using rule 62 (expression_compare -> expression LT expression .)
    ELSIF           reduce using rule 62 (expression_compare -> expression LT expression .)
    ELSE            reduce using rule 62 (expression_compare -> expression LT expression .)
    RETURN          reduce using rule 62 (expression_compare -> expression LT expression .)
    PRINT           reduce using rule 62 (expression_compare -> expression LT expression .)
    PUTS            reduce using rule 62 (expression_compare -> expression LT expression .)
    WHILE           reduce using rule 62 (expression_compare -> expression LT expression .)
    FOR             reduce using rule 62 (expression_compare -> expression LT expression .)
    DEF             reduce using rule 62 (expression_compare -> expression LT expression .)
    IF              reduce using rule 62 (expression_compare -> expression LT expression .)
    NOT             reduce using rule 62 (expression_compare -> expression LT expression .)
    NIL             reduce using rule 62 (expression_compare -> expression LT expression .)
    TRUE            reduce using rule 62 (expression_compare -> expression LT expression .)
    FALSE           reduce using rule 62 (expression_compare -> expression LT expression .)
    LPAREN          reduce using rule 62 (expression_compare -> expression LT expression .)
    INTEGER         reduce using rule 62 (expression_compare -> expression LT expression .)
    FLOAT           reduce using rule 62 (expression_compare -> expression LT expression .)
    RATIONAL        reduce using rule 62 (expression_compare -> expression LT expression .)
    COMPLEX         reduce using rule 62 (expression_compare -> expression LT expression .)
    STR             reduce using rule 62 (expression_compare -> expression LT expression .)
    SYMBOL          reduce using rule 62 (expression_compare -> expression LT expression .)
    REGEXP          reduce using rule 62 (expression_compare -> expression LT expression .)
    CLASS           reduce using rule 62 (expression_compare -> expression LT expression .)
    INSTANCE_VAR    reduce using rule 62 (expression_compare -> expression LT expression .)
    CLASS_VAR       reduce using rule 62 (expression_compare -> expression LT expression .)
    GLOBAL_VAR      reduce using rule 62 (expression_compare -> expression LT expression .)
    LOCAL_VAR       reduce using rule 62 (expression_compare -> expression LT expression .)
    CONSTANT        reduce using rule 62 (expression_compare -> expression LT expression .)
    LBRACKET        reduce using rule 62 (expression_compare -> expression LT expression .)
    $end            reduce using rule 62 (expression_compare -> expression LT expression .)
    RBRACE          reduce using rule 62 (expression_compare -> expression LT expression .)
    END_S           reduce using rule 62 (expression_compare -> expression LT expression .)
    DO              reduce using rule 62 (expression_compare -> expression LT expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 62 (expression_compare -> expression LT expression .) ]


state 185

    (63) expression_compare -> expression LE expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 63 (expression_compare -> expression LE expression .)
    OROR            reduce using rule 63 (expression_compare -> expression LE expression .)
    AND             reduce using rule 63 (expression_compare -> expression LE expression .)
    OR              reduce using rule 63 (expression_compare -> expression LE expression .)
    THEN            reduce using rule 63 (expression_compare -> expression LE expression .)
    LBRACE          reduce using rule 63 (expression_compare -> expression LE expression .)
    BREAK           reduce using rule 63 (expression_compare -> expression LE expression .)
    NEXT            reduce using rule 63 (expression_compare -> expression LE expression .)
    ELSIF           reduce using rule 63 (expression_compare -> expression LE expression .)
    ELSE            reduce using rule 63 (expression_compare -> expression LE expression .)
    RETURN          reduce using rule 63 (expression_compare -> expression LE expression .)
    PRINT           reduce using rule 63 (expression_compare -> expression LE expression .)
    PUTS            reduce using rule 63 (expression_compare -> expression LE expression .)
    WHILE           reduce using rule 63 (expression_compare -> expression LE expression .)
    FOR             reduce using rule 63 (expression_compare -> expression LE expression .)
    DEF             reduce using rule 63 (expression_compare -> expression LE expression .)
    IF              reduce using rule 63 (expression_compare -> expression LE expression .)
    NOT             reduce using rule 63 (expression_compare -> expression LE expression .)
    NIL             reduce using rule 63 (expression_compare -> expression LE expression .)
    TRUE            reduce using rule 63 (expression_compare -> expression LE expression .)
    FALSE           reduce using rule 63 (expression_compare -> expression LE expression .)
    LPAREN          reduce using rule 63 (expression_compare -> expression LE expression .)
    INTEGER         reduce using rule 63 (expression_compare -> expression LE expression .)
    FLOAT           reduce using rule 63 (expression_compare -> expression LE expression .)
    RATIONAL        reduce using rule 63 (expression_compare -> expression LE expression .)
    COMPLEX         reduce using rule 63 (expression_compare -> expression LE expression .)
    STR             reduce using rule 63 (expression_compare -> expression LE expression .)
    SYMBOL          reduce using rule 63 (expression_compare -> expression LE expression .)
    REGEXP          reduce using rule 63 (expression_compare -> expression LE expression .)
    CLASS           reduce using rule 63 (expression_compare -> expression LE expression .)
    INSTANCE_VAR    reduce using rule 63 (expression_compare -> expression LE expression .)
    CLASS_VAR       reduce using rule 63 (expression_compare -> expression LE expression .)
    GLOBAL_VAR      reduce using rule 63 (expression_compare -> expression LE expression .)
    LOCAL_VAR       reduce using rule 63 (expression_compare -> expression LE expression .)
    CONSTANT        reduce using rule 63 (expression_compare -> expression LE expression .)
    LBRACKET        reduce using rule 63 (expression_compare -> expression LE expression .)
    $end            reduce using rule 63 (expression_compare -> expression LE expression .)
    RBRACE          reduce using rule 63 (expression_compare -> expression LE expression .)
    END_S           reduce using rule 63 (expression_compare -> expression LE expression .)
    DO              reduce using rule 63 (expression_compare -> expression LE expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 63 (expression_compare -> expression LE expression .) ]


state 186

    (64) expression_compare -> expression GT expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 64 (expression_compare -> expression GT expression .)
    OROR            reduce using rule 64 (expression_compare -> expression GT expression .)
    AND             reduce using rule 64 (expression_compare -> expression GT expression .)
    OR              reduce using rule 64 (expression_compare -> expression GT expression .)
    THEN            reduce using rule 64 (expression_compare -> expression GT expression .)
    LBRACE          reduce using rule 64 (expression_compare -> expression GT expression .)
    BREAK           reduce using rule 64 (expression_compare -> expression GT expression .)
    NEXT            reduce using rule 64 (expression_compare -> expression GT expression .)
    ELSIF           reduce using rule 64 (expression_compare -> expression GT expression .)
    ELSE            reduce using rule 64 (expression_compare -> expression GT expression .)
    RETURN          reduce using rule 64 (expression_compare -> expression GT expression .)
    PRINT           reduce using rule 64 (expression_compare -> expression GT expression .)
    PUTS            reduce using rule 64 (expression_compare -> expression GT expression .)
    WHILE           reduce using rule 64 (expression_compare -> expression GT expression .)
    FOR             reduce using rule 64 (expression_compare -> expression GT expression .)
    DEF             reduce using rule 64 (expression_compare -> expression GT expression .)
    IF              reduce using rule 64 (expression_compare -> expression GT expression .)
    NOT             reduce using rule 64 (expression_compare -> expression GT expression .)
    NIL             reduce using rule 64 (expression_compare -> expression GT expression .)
    TRUE            reduce using rule 64 (expression_compare -> expression GT expression .)
    FALSE           reduce using rule 64 (expression_compare -> expression GT expression .)
    LPAREN          reduce using rule 64 (expression_compare -> expression GT expression .)
    INTEGER         reduce using rule 64 (expression_compare -> expression GT expression .)
    FLOAT           reduce using rule 64 (expression_compare -> expression GT expression .)
    RATIONAL        reduce using rule 64 (expression_compare -> expression GT expression .)
    COMPLEX         reduce using rule 64 (expression_compare -> expression GT expression .)
    STR             reduce using rule 64 (expression_compare -> expression GT expression .)
    SYMBOL          reduce using rule 64 (expression_compare -> expression GT expression .)
    REGEXP          reduce using rule 64 (expression_compare -> expression GT expression .)
    CLASS           reduce using rule 64 (expression_compare -> expression GT expression .)
    INSTANCE_VAR    reduce using rule 64 (expression_compare -> expression GT expression .)
    CLASS_VAR       reduce using rule 64 (expression_compare -> expression GT expression .)
    GLOBAL_VAR      reduce using rule 64 (expression_compare -> expression GT expression .)
    LOCAL_VAR       reduce using rule 64 (expression_compare -> expression GT expression .)
    CONSTANT        reduce using rule 64 (expression_compare -> expression GT expression .)
    LBRACKET        reduce using rule 64 (expression_compare -> expression GT expression .)
    $end            reduce using rule 64 (expression_compare -> expression GT expression .)
    RBRACE          reduce using rule 64 (expression_compare -> expression GT expression .)
    END_S           reduce using rule 64 (expression_compare -> expression GT expression .)
    DO              reduce using rule 64 (expression_compare -> expression GT expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 64 (expression_compare -> expression GT expression .) ]


state 187

    (65) expression_compare -> expression GE expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 65 (expression_compare -> expression GE expression .)
    OROR            reduce using rule 65 (expression_compare -> expression GE expression .)
    AND             reduce using rule 65 (expression_compare -> expression GE expression .)
    OR              reduce using rule 65 (expression_compare -> expression GE expression .)
    THEN            reduce using rule 65 (expression_compare -> expression GE expression .)
    LBRACE          reduce using rule 65 (expression_compare -> expression GE expression .)
    BREAK           reduce using rule 65 (expression_compare -> expression GE expression .)
    NEXT            reduce using rule 65 (expression_compare -> expression GE expression .)
    ELSIF           reduce using rule 65 (expression_compare -> expression GE expression .)
    ELSE            reduce using rule 65 (expression_compare -> expression GE expression .)
    RETURN          reduce using rule 65 (expression_compare -> expression GE expression .)
    PRINT           reduce using rule 65 (expression_compare -> expression GE expression .)
    PUTS            reduce using rule 65 (expression_compare -> expression GE expression .)
    WHILE           reduce using rule 65 (expression_compare -> expression GE expression .)
    FOR             reduce using rule 65 (expression_compare -> expression GE expression .)
    DEF             reduce using rule 65 (expression_compare -> expression GE expression .)
    IF              reduce using rule 65 (expression_compare -> expression GE expression .)
    NOT             reduce using rule 65 (expression_compare -> expression GE expression .)
    NIL             reduce using rule 65 (expression_compare -> expression GE expression .)
    TRUE            reduce using rule 65 (expression_compare -> expression GE expression .)
    FALSE           reduce using rule 65 (expression_compare -> expression GE expression .)
    LPAREN          reduce using rule 65 (expression_compare -> expression GE expression .)
    INTEGER         reduce using rule 65 (expression_compare -> expression GE expression .)
    FLOAT           reduce using rule 65 (expression_compare -> expression GE expression .)
    RATIONAL        reduce using rule 65 (expression_compare -> expression GE expression .)
    COMPLEX         reduce using rule 65 (expression_compare -> expression GE expression .)
    STR             reduce using rule 65 (expression_compare -> expression GE expression .)
    SYMBOL          reduce using rule 65 (expression_compare -> expression GE expression .)
    REGEXP          reduce using rule 65 (expression_compare -> expression GE expression .)
    CLASS           reduce using rule 65 (expression_compare -> expression GE expression .)
    INSTANCE_VAR    reduce using rule 65 (expression_compare -> expression GE expression .)
    CLASS_VAR       reduce using rule 65 (expression_compare -> expression GE expression .)
    GLOBAL_VAR      reduce using rule 65 (expression_compare -> expression GE expression .)
    LOCAL_VAR       reduce using rule 65 (expression_compare -> expression GE expression .)
    CONSTANT        reduce using rule 65 (expression_compare -> expression GE expression .)
    LBRACKET        reduce using rule 65 (expression_compare -> expression GE expression .)
    $end            reduce using rule 65 (expression_compare -> expression GE expression .)
    RBRACE          reduce using rule 65 (expression_compare -> expression GE expression .)
    END_S           reduce using rule 65 (expression_compare -> expression GE expression .)
    DO              reduce using rule 65 (expression_compare -> expression GE expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 65 (expression_compare -> expression GE expression .) ]


state 188

    (66) expression_compare -> expression EQ expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 66 (expression_compare -> expression EQ expression .)
    OROR            reduce using rule 66 (expression_compare -> expression EQ expression .)
    AND             reduce using rule 66 (expression_compare -> expression EQ expression .)
    OR              reduce using rule 66 (expression_compare -> expression EQ expression .)
    THEN            reduce using rule 66 (expression_compare -> expression EQ expression .)
    LBRACE          reduce using rule 66 (expression_compare -> expression EQ expression .)
    BREAK           reduce using rule 66 (expression_compare -> expression EQ expression .)
    NEXT            reduce using rule 66 (expression_compare -> expression EQ expression .)
    ELSIF           reduce using rule 66 (expression_compare -> expression EQ expression .)
    ELSE            reduce using rule 66 (expression_compare -> expression EQ expression .)
    RETURN          reduce using rule 66 (expression_compare -> expression EQ expression .)
    PRINT           reduce using rule 66 (expression_compare -> expression EQ expression .)
    PUTS            reduce using rule 66 (expression_compare -> expression EQ expression .)
    WHILE           reduce using rule 66 (expression_compare -> expression EQ expression .)
    FOR             reduce using rule 66 (expression_compare -> expression EQ expression .)
    DEF             reduce using rule 66 (expression_compare -> expression EQ expression .)
    IF              reduce using rule 66 (expression_compare -> expression EQ expression .)
    NOT             reduce using rule 66 (expression_compare -> expression EQ expression .)
    NIL             reduce using rule 66 (expression_compare -> expression EQ expression .)
    TRUE            reduce using rule 66 (expression_compare -> expression EQ expression .)
    FALSE           reduce using rule 66 (expression_compare -> expression EQ expression .)
    LPAREN          reduce using rule 66 (expression_compare -> expression EQ expression .)
    INTEGER         reduce using rule 66 (expression_compare -> expression EQ expression .)
    FLOAT           reduce using rule 66 (expression_compare -> expression EQ expression .)
    RATIONAL        reduce using rule 66 (expression_compare -> expression EQ expression .)
    COMPLEX         reduce using rule 66 (expression_compare -> expression EQ expression .)
    STR             reduce using rule 66 (expression_compare -> expression EQ expression .)
    SYMBOL          reduce using rule 66 (expression_compare -> expression EQ expression .)
    REGEXP          reduce using rule 66 (expression_compare -> expression EQ expression .)
    CLASS           reduce using rule 66 (expression_compare -> expression EQ expression .)
    INSTANCE_VAR    reduce using rule 66 (expression_compare -> expression EQ expression .)
    CLASS_VAR       reduce using rule 66 (expression_compare -> expression EQ expression .)
    GLOBAL_VAR      reduce using rule 66 (expression_compare -> expression EQ expression .)
    LOCAL_VAR       reduce using rule 66 (expression_compare -> expression EQ expression .)
    CONSTANT        reduce using rule 66 (expression_compare -> expression EQ expression .)
    LBRACKET        reduce using rule 66 (expression_compare -> expression EQ expression .)
    $end            reduce using rule 66 (expression_compare -> expression EQ expression .)
    RBRACE          reduce using rule 66 (expression_compare -> expression EQ expression .)
    END_S           reduce using rule 66 (expression_compare -> expression EQ expression .)
    DO              reduce using rule 66 (expression_compare -> expression EQ expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 66 (expression_compare -> expression EQ expression .) ]


state 189

    (67) expression_compare -> expression NE expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 67 (expression_compare -> expression NE expression .)
    OROR            reduce using rule 67 (expression_compare -> expression NE expression .)
    AND             reduce using rule 67 (expression_compare -> expression NE expression .)
    OR              reduce using rule 67 (expression_compare -> expression NE expression .)
    THEN            reduce using rule 67 (expression_compare -> expression NE expression .)
    LBRACE          reduce using rule 67 (expression_compare -> expression NE expression .)
    BREAK           reduce using rule 67 (expression_compare -> expression NE expression .)
    NEXT            reduce using rule 67 (expression_compare -> expression NE expression .)
    ELSIF           reduce using rule 67 (expression_compare -> expression NE expression .)
    ELSE            reduce using rule 67 (expression_compare -> expression NE expression .)
    RETURN          reduce using rule 67 (expression_compare -> expression NE expression .)
    PRINT           reduce using rule 67 (expression_compare -> expression NE expression .)
    PUTS            reduce using rule 67 (expression_compare -> expression NE expression .)
    WHILE           reduce using rule 67 (expression_compare -> expression NE expression .)
    FOR             reduce using rule 67 (expression_compare -> expression NE expression .)
    DEF             reduce using rule 67 (expression_compare -> expression NE expression .)
    IF              reduce using rule 67 (expression_compare -> expression NE expression .)
    NOT             reduce using rule 67 (expression_compare -> expression NE expression .)
    NIL             reduce using rule 67 (expression_compare -> expression NE expression .)
    TRUE            reduce using rule 67 (expression_compare -> expression NE expression .)
    FALSE           reduce using rule 67 (expression_compare -> expression NE expression .)
    LPAREN          reduce using rule 67 (expression_compare -> expression NE expression .)
    INTEGER         reduce using rule 67 (expression_compare -> expression NE expression .)
    FLOAT           reduce using rule 67 (expression_compare -> expression NE expression .)
    RATIONAL        reduce using rule 67 (expression_compare -> expression NE expression .)
    COMPLEX         reduce using rule 67 (expression_compare -> expression NE expression .)
    STR             reduce using rule 67 (expression_compare -> expression NE expression .)
    SYMBOL          reduce using rule 67 (expression_compare -> expression NE expression .)
    REGEXP          reduce using rule 67 (expression_compare -> expression NE expression .)
    CLASS           reduce using rule 67 (expression_compare -> expression NE expression .)
    INSTANCE_VAR    reduce using rule 67 (expression_compare -> expression NE expression .)
    CLASS_VAR       reduce using rule 67 (expression_compare -> expression NE expression .)
    GLOBAL_VAR      reduce using rule 67 (expression_compare -> expression NE expression .)
    LOCAL_VAR       reduce using rule 67 (expression_compare -> expression NE expression .)
    CONSTANT        reduce using rule 67 (expression_compare -> expression NE expression .)
    LBRACKET        reduce using rule 67 (expression_compare -> expression NE expression .)
    $end            reduce using rule 67 (expression_compare -> expression NE expression .)
    RBRACE          reduce using rule 67 (expression_compare -> expression NE expression .)
    END_S           reduce using rule 67 (expression_compare -> expression NE expression .)
    DO              reduce using rule 67 (expression_compare -> expression NE expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 67 (expression_compare -> expression NE expression .) ]


state 190

    (68) expression_compare -> expression EQQ expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    OROR            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    AND             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    OR              reduce using rule 68 (expression_compare -> expression EQQ expression .)
    THEN            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    LBRACE          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    BREAK           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    NEXT            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    ELSIF           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    ELSE            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    RETURN          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    PRINT           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    PUTS            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    WHILE           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    FOR             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    DEF             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    IF              reduce using rule 68 (expression_compare -> expression EQQ expression .)
    NOT             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    NIL             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    TRUE            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    FALSE           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    LPAREN          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    INTEGER         reduce using rule 68 (expression_compare -> expression EQQ expression .)
    FLOAT           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    RATIONAL        reduce using rule 68 (expression_compare -> expression EQQ expression .)
    COMPLEX         reduce using rule 68 (expression_compare -> expression EQQ expression .)
    STR             reduce using rule 68 (expression_compare -> expression EQQ expression .)
    SYMBOL          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    REGEXP          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    CLASS           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    INSTANCE_VAR    reduce using rule 68 (expression_compare -> expression EQQ expression .)
    CLASS_VAR       reduce using rule 68 (expression_compare -> expression EQQ expression .)
    GLOBAL_VAR      reduce using rule 68 (expression_compare -> expression EQQ expression .)
    LOCAL_VAR       reduce using rule 68 (expression_compare -> expression EQQ expression .)
    CONSTANT        reduce using rule 68 (expression_compare -> expression EQQ expression .)
    LBRACKET        reduce using rule 68 (expression_compare -> expression EQQ expression .)
    $end            reduce using rule 68 (expression_compare -> expression EQQ expression .)
    RBRACE          reduce using rule 68 (expression_compare -> expression EQQ expression .)
    END_S           reduce using rule 68 (expression_compare -> expression EQQ expression .)
    DO              reduce using rule 68 (expression_compare -> expression EQQ expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 68 (expression_compare -> expression EQQ expression .) ]


state 191

    (69) expression_compare -> expression MATCH expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    OROR            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    AND             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    OR              reduce using rule 69 (expression_compare -> expression MATCH expression .)
    THEN            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    LBRACE          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    BREAK           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    NEXT            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    ELSIF           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    ELSE            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    RETURN          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    PRINT           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    PUTS            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    WHILE           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    FOR             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    DEF             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    IF              reduce using rule 69 (expression_compare -> expression MATCH expression .)
    NOT             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    NIL             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    TRUE            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    FALSE           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    LPAREN          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    INTEGER         reduce using rule 69 (expression_compare -> expression MATCH expression .)
    FLOAT           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    RATIONAL        reduce using rule 69 (expression_compare -> expression MATCH expression .)
    COMPLEX         reduce using rule 69 (expression_compare -> expression MATCH expression .)
    STR             reduce using rule 69 (expression_compare -> expression MATCH expression .)
    SYMBOL          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    REGEXP          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    CLASS           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    INSTANCE_VAR    reduce using rule 69 (expression_compare -> expression MATCH expression .)
    CLASS_VAR       reduce using rule 69 (expression_compare -> expression MATCH expression .)
    GLOBAL_VAR      reduce using rule 69 (expression_compare -> expression MATCH expression .)
    LOCAL_VAR       reduce using rule 69 (expression_compare -> expression MATCH expression .)
    CONSTANT        reduce using rule 69 (expression_compare -> expression MATCH expression .)
    LBRACKET        reduce using rule 69 (expression_compare -> expression MATCH expression .)
    $end            reduce using rule 69 (expression_compare -> expression MATCH expression .)
    RBRACE          reduce using rule 69 (expression_compare -> expression MATCH expression .)
    END_S           reduce using rule 69 (expression_compare -> expression MATCH expression .)
    DO              reduce using rule 69 (expression_compare -> expression MATCH expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 69 (expression_compare -> expression MATCH expression .) ]


state 192

    (70) expression_compare -> expression NMATCH expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    ANDAND          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    OROR            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    AND             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    OR              reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    THEN            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    LBRACE          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    BREAK           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    NEXT            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    ELSIF           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    ELSE            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    RETURN          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    PRINT           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    PUTS            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    WHILE           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    FOR             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    DEF             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    IF              reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    NOT             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    NIL             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    TRUE            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    FALSE           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    LPAREN          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    INTEGER         reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    FLOAT           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    RATIONAL        reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    COMPLEX         reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    STR             reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    SYMBOL          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    REGEXP          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    CLASS           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    INSTANCE_VAR    reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    CLASS_VAR       reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    GLOBAL_VAR      reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    LOCAL_VAR       reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    CONSTANT        reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    LBRACKET        reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    $end            reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    RBRACE          reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    END_S           reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    DO              reduce using rule 70 (expression_compare -> expression NMATCH expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 70 (expression_compare -> expression NMATCH expression .) ]


state 193

    (98) expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .

    EQLS            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LBRACKET        reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    DOT             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RANGE_INCL      reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RANGE_EXCL      reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    PLUS            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    MULT            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    DIV             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    MOD             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    POWER           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    BREAK           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    NEXT            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    ELSIF           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    ELSE            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RETURN          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    PRINT           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    PUTS            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    WHILE           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    FOR             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LBRACE          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    DEF             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    IF              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    THEN            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    NOT             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    NIL             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    TRUE            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    FALSE           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LPAREN          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    INTEGER         reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    FLOAT           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RATIONAL        reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    COMPLEX         reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    STR             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    SYMBOL          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    REGEXP          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    CLASS           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    INSTANCE_VAR    reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    CLASS_VAR       reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    GLOBAL_VAR      reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LOCAL_VAR       reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    CONSTANT        reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    $end            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RBRACE          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    END_S           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LT              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    LE              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    GT              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    GE              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    EQ              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    NE              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    EQQ             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    MATCH           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    NMATCH          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    ARROW           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    RBRACKET        reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    ANDAND          reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    OROR            reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    AND             reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    OR              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    DO              reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)
    COLON           reduce using rule 98 (expr_postfix -> LOCAL_VAR LPAREN expr_list RPAREN .)


state 194

    (99) expr_postfix -> expr_postfix LBRACKET expression RBRACKET .

    EQLS            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    DOT             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RANGE_INCL      reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RANGE_EXCL      reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    MULT            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    DIV             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    MOD             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    POWER           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    BREAK           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    NEXT            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    ELSIF           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RETURN          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    PRINT           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    PUTS            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    FOR             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LBRACE          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    DEF             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    IF              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    THEN            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    NOT             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    NIL             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    TRUE            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    FALSE           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    INTEGER         reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    FLOAT           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RATIONAL        reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    COMPLEX         reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    STR             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    SYMBOL          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    REGEXP          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    CLASS           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    INSTANCE_VAR    reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    CLASS_VAR       reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    GLOBAL_VAR      reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LOCAL_VAR       reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    CONSTANT        reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    $end            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    END_S           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LT              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    LE              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    GT              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    GE              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    EQ              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    NE              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    EQQ             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    MATCH           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    NMATCH          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    ARROW           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    ANDAND          reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    OROR            reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    AND             reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    OR              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    DO              reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)
    COLON           reduce using rule 99 (expr_postfix -> expr_postfix LBRACKET expression RBRACKET .)


state 195

    (147) expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN . RPAREN
    (148) expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN . expr_list RPAREN
    (83) expr_list -> . expression
    (84) expr_list -> . expression COMMA expr_list
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    RPAREN          shift and go to state 216
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expr_postfix                   shift and go to state 75
    expr_list                      shift and go to state 217
    expression                     shift and go to state 114
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 196

    (38) while_stmt -> WHILE expression_logic while_enter DO . statement_list END_S while_exit
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 218
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 197

    (39) while_stmt -> WHILE expression_logic while_enter statement_list . END_S while_exit
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 219
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 198

    (42) for_stmt -> FOR LOCAL_VAR IN expression . for_enter DO statement_list END_S for_exit
    (43) for_stmt -> FOR LOCAL_VAR IN expression . for_enter statement_list END_S for_exit
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression
    (44) for_enter -> .

  ! shift/reduce conflict for MINUS resolved as shift
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69
    DO              reduce using rule 44 (for_enter -> .)
    BREAK           reduce using rule 44 (for_enter -> .)
    NEXT            reduce using rule 44 (for_enter -> .)
    ELSIF           reduce using rule 44 (for_enter -> .)
    ELSE            reduce using rule 44 (for_enter -> .)
    RETURN          reduce using rule 44 (for_enter -> .)
    PRINT           reduce using rule 44 (for_enter -> .)
    PUTS            reduce using rule 44 (for_enter -> .)
    WHILE           reduce using rule 44 (for_enter -> .)
    FOR             reduce using rule 44 (for_enter -> .)
    LBRACE          reduce using rule 44 (for_enter -> .)
    DEF             reduce using rule 44 (for_enter -> .)
    IF              reduce using rule 44 (for_enter -> .)
    THEN            reduce using rule 44 (for_enter -> .)
    NOT             reduce using rule 44 (for_enter -> .)
    NIL             reduce using rule 44 (for_enter -> .)
    TRUE            reduce using rule 44 (for_enter -> .)
    FALSE           reduce using rule 44 (for_enter -> .)
    LPAREN          reduce using rule 44 (for_enter -> .)
    INTEGER         reduce using rule 44 (for_enter -> .)
    FLOAT           reduce using rule 44 (for_enter -> .)
    RATIONAL        reduce using rule 44 (for_enter -> .)
    COMPLEX         reduce using rule 44 (for_enter -> .)
    STR             reduce using rule 44 (for_enter -> .)
    SYMBOL          reduce using rule 44 (for_enter -> .)
    REGEXP          reduce using rule 44 (for_enter -> .)
    CLASS           reduce using rule 44 (for_enter -> .)
    INSTANCE_VAR    reduce using rule 44 (for_enter -> .)
    CLASS_VAR       reduce using rule 44 (for_enter -> .)
    GLOBAL_VAR      reduce using rule 44 (for_enter -> .)
    LOCAL_VAR       reduce using rule 44 (for_enter -> .)
    CONSTANT        reduce using rule 44 (for_enter -> .)
    LBRACKET        reduce using rule 44 (for_enter -> .)
    END_S           reduce using rule 44 (for_enter -> .)

  ! MINUS           [ reduce using rule 44 (for_enter -> .) ]

    for_enter                      shift and go to state 220

state 199

    (75) hash_pairs -> hash_pairs COMMA hash_pair .

    COMMA           reduce using rule 75 (hash_pairs -> hash_pairs COMMA hash_pair .)
    RBRACE          reduce using rule 75 (hash_pairs -> hash_pairs COMMA hash_pair .)


state 200

    (77) hash_pair -> expression ARROW expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    COMMA           reduce using rule 77 (hash_pair -> expression ARROW expression .)
    RBRACE          reduce using rule 77 (hash_pair -> expression ARROW expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 201

    (78) hash_pair -> SYMBOL COLON expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    COMMA           reduce using rule 78 (hash_pair -> SYMBOL COLON expression .)
    RBRACE          reduce using rule 78 (hash_pair -> SYMBOL COLON expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 202

    (79) hash_pair -> LOCAL_VAR COLON expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

    COMMA           reduce using rule 79 (hash_pair -> LOCAL_VAR COLON expression .)
    RBRACE          reduce using rule 79 (hash_pair -> LOCAL_VAR COLON expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69


state 203

    (110) parameter -> LOCAL_VAR EQLS . expression
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    LBRACE          shift and go to state 76
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    INSTANCE_VAR    shift and go to state 77
    CLASS_VAR       shift and go to state 78
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

    expression                     shift and go to state 221
    hash_literal                   shift and go to state 73
    variable                       shift and go to state 74
    expr_postfix                   shift and go to state 75
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 204

    (103) function_def -> DEF LOCAL_VAR statement_list END_S .

    BREAK           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    NEXT            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    ELSIF           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    ELSE            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    RETURN          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    PRINT           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    PUTS            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    WHILE           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    FOR             reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    LBRACE          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    DEF             reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    IF              reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    THEN            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    NOT             reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    NIL             reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    TRUE            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    FALSE           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    LPAREN          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    INTEGER         reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    FLOAT           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    RATIONAL        reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    COMPLEX         reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    STR             reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    SYMBOL          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    REGEXP          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    MINUS           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    CLASS           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    INSTANCE_VAR    reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    CLASS_VAR       reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    GLOBAL_VAR      reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    LOCAL_VAR       reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    CONSTANT        reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    LBRACKET        reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    $end            reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    RBRACE          reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)
    END_S           reduce using rule 103 (function_def -> DEF LOCAL_VAR statement_list END_S .)


state 205

    (104) function_def -> DEF LOCAL_VAR LPAREN param_list . RPAREN statement_list END_S
    (108) param_list -> param_list . COMMA parameter

    RPAREN          shift and go to state 222
    COMMA           shift and go to state 206


state 206

    (108) param_list -> param_list COMMA . parameter
    (109) parameter -> . LOCAL_VAR
    (110) parameter -> . LOCAL_VAR EQLS expression

    LOCAL_VAR       shift and go to state 224

    parameter                      shift and go to state 223

state 207

    (112) function_def -> DEF LOCAL_VAR optional_params optional_ret . statement_list END_S
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 225
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 208

    (113) optional_ret -> COLON . TYPE

    TYPE            shift and go to state 226


state 209

    (114) optional_ret -> empty .

    BREAK           reduce using rule 114 (optional_ret -> empty .)
    NEXT            reduce using rule 114 (optional_ret -> empty .)
    ELSIF           reduce using rule 114 (optional_ret -> empty .)
    ELSE            reduce using rule 114 (optional_ret -> empty .)
    RETURN          reduce using rule 114 (optional_ret -> empty .)
    PRINT           reduce using rule 114 (optional_ret -> empty .)
    PUTS            reduce using rule 114 (optional_ret -> empty .)
    WHILE           reduce using rule 114 (optional_ret -> empty .)
    FOR             reduce using rule 114 (optional_ret -> empty .)
    LBRACE          reduce using rule 114 (optional_ret -> empty .)
    DEF             reduce using rule 114 (optional_ret -> empty .)
    IF              reduce using rule 114 (optional_ret -> empty .)
    THEN            reduce using rule 114 (optional_ret -> empty .)
    NOT             reduce using rule 114 (optional_ret -> empty .)
    NIL             reduce using rule 114 (optional_ret -> empty .)
    TRUE            reduce using rule 114 (optional_ret -> empty .)
    FALSE           reduce using rule 114 (optional_ret -> empty .)
    LPAREN          reduce using rule 114 (optional_ret -> empty .)
    INTEGER         reduce using rule 114 (optional_ret -> empty .)
    FLOAT           reduce using rule 114 (optional_ret -> empty .)
    RATIONAL        reduce using rule 114 (optional_ret -> empty .)
    COMPLEX         reduce using rule 114 (optional_ret -> empty .)
    STR             reduce using rule 114 (optional_ret -> empty .)
    SYMBOL          reduce using rule 114 (optional_ret -> empty .)
    REGEXP          reduce using rule 114 (optional_ret -> empty .)
    MINUS           reduce using rule 114 (optional_ret -> empty .)
    CLASS           reduce using rule 114 (optional_ret -> empty .)
    INSTANCE_VAR    reduce using rule 114 (optional_ret -> empty .)
    CLASS_VAR       reduce using rule 114 (optional_ret -> empty .)
    GLOBAL_VAR      reduce using rule 114 (optional_ret -> empty .)
    LOCAL_VAR       reduce using rule 114 (optional_ret -> empty .)
    CONSTANT        reduce using rule 114 (optional_ret -> empty .)
    LBRACKET        reduce using rule 114 (optional_ret -> empty .)
    END_S           reduce using rule 114 (optional_ret -> empty .)


state 210

    (46) if_stmt -> IF expression_logic optional_then stmt_block . elsif_list else_part END_S
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (111) empty -> .
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PUTS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for DEF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for IF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for THEN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NIL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for STR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for REGEXP resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 227
    else_part                      shift and go to state 17
    statement                      shift and go to state 60
    empty                          shift and go to state 228
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 211

    (120) class_def -> CLASS CONSTANT stmt_block END_S .

    BREAK           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    NEXT            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    ELSIF           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    ELSE            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    RETURN          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    PRINT           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    PUTS            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    WHILE           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    FOR             reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    LBRACE          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    DEF             reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    IF              reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    THEN            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    NOT             reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    NIL             reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    TRUE            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    FALSE           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    LPAREN          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    INTEGER         reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    FLOAT           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    RATIONAL        reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    COMPLEX         reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    STR             reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    SYMBOL          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    REGEXP          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    MINUS           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    CLASS           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    INSTANCE_VAR    reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    CLASS_VAR       reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    GLOBAL_VAR      reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    LOCAL_VAR       reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    CONSTANT        reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    LBRACKET        reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    $end            reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    RBRACE          reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)
    END_S           reduce using rule 120 (class_def -> CLASS CONSTANT stmt_block END_S .)


state 212

    (121) class_def -> CLASS CONSTANT opt_inherit stmt_block . END_S
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 229
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 213

    (122) opt_inherit -> LT CONSTANT .

    LBRACE          reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    BREAK           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    NEXT            reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    ELSIF           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    ELSE            reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    RETURN          reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    PRINT           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    PUTS            reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    WHILE           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    FOR             reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    DEF             reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    IF              reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    THEN            reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    NOT             reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    NIL             reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    TRUE            reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    FALSE           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    LPAREN          reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    INTEGER         reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    FLOAT           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    RATIONAL        reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    COMPLEX         reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    STR             reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    SYMBOL          reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    REGEXP          reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    MINUS           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    CLASS           reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    INSTANCE_VAR    reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    CLASS_VAR       reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    GLOBAL_VAR      reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    LOCAL_VAR       reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    CONSTANT        reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    LBRACKET        reduce using rule 122 (opt_inherit -> LT CONSTANT .)
    END_S           reduce using rule 122 (opt_inherit -> LT CONSTANT .)


state 214

    (84) expr_list -> expression COMMA expr_list .

    RBRACKET        reduce using rule 84 (expr_list -> expression COMMA expr_list .)
    RPAREN          reduce using rule 84 (expr_list -> expression COMMA expr_list .)


state 215

    (50) elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for BREAK resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NEXT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSIF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RETURN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for PUTS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for DEF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for IF resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for THEN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for NIL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for STR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for REGEXP resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for $end resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for RBRACE resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    $end            reduce using rule 19 (statement -> stmt_block .)
    RBRACE          reduce using rule 19 (statement -> stmt_block .)
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! ELSIF           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! BREAK           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! NEXT            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! ELSE            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! RETURN          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! PRINT           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! PUTS            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! WHILE           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! FOR             [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! LBRACE          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! DEF             [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! IF              [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! THEN            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! NOT             [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! NIL             [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! TRUE            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! FALSE           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! LPAREN          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! INTEGER         [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! FLOAT           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! RATIONAL        [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! COMPLEX         [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! STR             [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! SYMBOL          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! REGEXP          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! MINUS           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! CLASS           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! CONSTANT        [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! LBRACKET        [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! $end            [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! RBRACE          [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! END_S           [ reduce using rule 50 (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! $end            [ reduce using rule 111 (empty -> .) ]
  ! RBRACE          [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    elsif_list                     shift and go to state 16
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 216

    (147) expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .

    EQLS            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LBRACKET        reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    DOT             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RANGE_INCL      reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RANGE_EXCL      reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    PLUS            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    MINUS           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    MULT            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    DIV             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    MOD             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    POWER           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    BREAK           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    NEXT            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    ELSIF           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    ELSE            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RETURN          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    PRINT           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    PUTS            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    WHILE           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    FOR             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LBRACE          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    DEF             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    IF              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    THEN            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    NOT             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    NIL             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    TRUE            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    FALSE           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LPAREN          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    INTEGER         reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    FLOAT           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RATIONAL        reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    COMPLEX         reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    STR             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    SYMBOL          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    REGEXP          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    CLASS           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    INSTANCE_VAR    reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    CLASS_VAR       reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    GLOBAL_VAR      reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LOCAL_VAR       reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    CONSTANT        reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    $end            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RBRACE          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    END_S           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LT              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    LE              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    GT              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    GE              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    EQ              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    NE              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    EQQ             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    MATCH           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    NMATCH          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    ARROW           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RPAREN          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    COMMA           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    RBRACKET        reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    ANDAND          reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    OROR            reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    AND             reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    OR              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    DO              reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)
    COLON           reduce using rule 147 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN RPAREN .)


state 217

    (148) expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list . RPAREN

    RPAREN          shift and go to state 230


state 218

    (38) while_stmt -> WHILE expression_logic while_enter DO statement_list . END_S while_exit
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 231
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 219

    (39) while_stmt -> WHILE expression_logic while_enter statement_list END_S . while_exit
    (41) while_exit -> .

    BREAK           reduce using rule 41 (while_exit -> .)
    NEXT            reduce using rule 41 (while_exit -> .)
    ELSIF           reduce using rule 41 (while_exit -> .)
    ELSE            reduce using rule 41 (while_exit -> .)
    RETURN          reduce using rule 41 (while_exit -> .)
    PRINT           reduce using rule 41 (while_exit -> .)
    PUTS            reduce using rule 41 (while_exit -> .)
    WHILE           reduce using rule 41 (while_exit -> .)
    FOR             reduce using rule 41 (while_exit -> .)
    LBRACE          reduce using rule 41 (while_exit -> .)
    DEF             reduce using rule 41 (while_exit -> .)
    IF              reduce using rule 41 (while_exit -> .)
    THEN            reduce using rule 41 (while_exit -> .)
    NOT             reduce using rule 41 (while_exit -> .)
    NIL             reduce using rule 41 (while_exit -> .)
    TRUE            reduce using rule 41 (while_exit -> .)
    FALSE           reduce using rule 41 (while_exit -> .)
    LPAREN          reduce using rule 41 (while_exit -> .)
    INTEGER         reduce using rule 41 (while_exit -> .)
    FLOAT           reduce using rule 41 (while_exit -> .)
    RATIONAL        reduce using rule 41 (while_exit -> .)
    COMPLEX         reduce using rule 41 (while_exit -> .)
    STR             reduce using rule 41 (while_exit -> .)
    SYMBOL          reduce using rule 41 (while_exit -> .)
    REGEXP          reduce using rule 41 (while_exit -> .)
    MINUS           reduce using rule 41 (while_exit -> .)
    CLASS           reduce using rule 41 (while_exit -> .)
    INSTANCE_VAR    reduce using rule 41 (while_exit -> .)
    CLASS_VAR       reduce using rule 41 (while_exit -> .)
    GLOBAL_VAR      reduce using rule 41 (while_exit -> .)
    LOCAL_VAR       reduce using rule 41 (while_exit -> .)
    CONSTANT        reduce using rule 41 (while_exit -> .)
    LBRACKET        reduce using rule 41 (while_exit -> .)
    $end            reduce using rule 41 (while_exit -> .)
    RBRACE          reduce using rule 41 (while_exit -> .)
    END_S           reduce using rule 41 (while_exit -> .)

    while_exit                     shift and go to state 232

state 220

    (42) for_stmt -> FOR LOCAL_VAR IN expression for_enter . DO statement_list END_S for_exit
    (43) for_stmt -> FOR LOCAL_VAR IN expression for_enter . statement_list END_S for_exit
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    DO              shift and go to state 233
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    expression                     shift and go to state 18
    statement_list                 shift and go to state 234
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 221

    (110) parameter -> LOCAL_VAR EQLS expression .
    (81) expression -> expression . RANGE_INCL expression
    (82) expression -> expression . RANGE_EXCL expression
    (130) expression -> expression . PLUS expression
    (131) expression -> expression . MINUS expression
    (132) expression -> expression . MULT expression
    (133) expression -> expression . DIV expression
    (134) expression -> expression . MOD expression
    (135) expression -> expression . POWER expression

  ! shift/reduce conflict for MINUS resolved as shift
    COMMA           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    COLON           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    BREAK           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    NEXT            reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    ELSIF           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    ELSE            reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    RETURN          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    PRINT           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    PUTS            reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    WHILE           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    FOR             reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    LBRACE          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    DEF             reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    IF              reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    THEN            reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    NOT             reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    NIL             reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    TRUE            reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    FALSE           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    LPAREN          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    INTEGER         reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    FLOAT           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    RATIONAL        reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    COMPLEX         reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    STR             reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    SYMBOL          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    REGEXP          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    CLASS           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    INSTANCE_VAR    reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    CLASS_VAR       reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    GLOBAL_VAR      reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    LOCAL_VAR       reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    CONSTANT        reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    LBRACKET        reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    END_S           reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    RPAREN          reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .)
    RANGE_INCL      shift and go to state 62
    RANGE_EXCL      shift and go to state 63
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65
    MULT            shift and go to state 66
    DIV             shift and go to state 67
    MOD             shift and go to state 68
    POWER           shift and go to state 69

  ! MINUS           [ reduce using rule 110 (parameter -> LOCAL_VAR EQLS expression .) ]


state 222

    (104) function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN . statement_list END_S
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 235
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 223

    (108) param_list -> param_list COMMA parameter .

    COMMA           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    COLON           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    BREAK           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    NEXT            reduce using rule 108 (param_list -> param_list COMMA parameter .)
    ELSIF           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    ELSE            reduce using rule 108 (param_list -> param_list COMMA parameter .)
    RETURN          reduce using rule 108 (param_list -> param_list COMMA parameter .)
    PRINT           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    PUTS            reduce using rule 108 (param_list -> param_list COMMA parameter .)
    WHILE           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    FOR             reduce using rule 108 (param_list -> param_list COMMA parameter .)
    LBRACE          reduce using rule 108 (param_list -> param_list COMMA parameter .)
    DEF             reduce using rule 108 (param_list -> param_list COMMA parameter .)
    IF              reduce using rule 108 (param_list -> param_list COMMA parameter .)
    THEN            reduce using rule 108 (param_list -> param_list COMMA parameter .)
    NOT             reduce using rule 108 (param_list -> param_list COMMA parameter .)
    NIL             reduce using rule 108 (param_list -> param_list COMMA parameter .)
    TRUE            reduce using rule 108 (param_list -> param_list COMMA parameter .)
    FALSE           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    LPAREN          reduce using rule 108 (param_list -> param_list COMMA parameter .)
    INTEGER         reduce using rule 108 (param_list -> param_list COMMA parameter .)
    FLOAT           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    RATIONAL        reduce using rule 108 (param_list -> param_list COMMA parameter .)
    COMPLEX         reduce using rule 108 (param_list -> param_list COMMA parameter .)
    STR             reduce using rule 108 (param_list -> param_list COMMA parameter .)
    SYMBOL          reduce using rule 108 (param_list -> param_list COMMA parameter .)
    REGEXP          reduce using rule 108 (param_list -> param_list COMMA parameter .)
    MINUS           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    CLASS           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    INSTANCE_VAR    reduce using rule 108 (param_list -> param_list COMMA parameter .)
    CLASS_VAR       reduce using rule 108 (param_list -> param_list COMMA parameter .)
    GLOBAL_VAR      reduce using rule 108 (param_list -> param_list COMMA parameter .)
    LOCAL_VAR       reduce using rule 108 (param_list -> param_list COMMA parameter .)
    CONSTANT        reduce using rule 108 (param_list -> param_list COMMA parameter .)
    LBRACKET        reduce using rule 108 (param_list -> param_list COMMA parameter .)
    END_S           reduce using rule 108 (param_list -> param_list COMMA parameter .)
    RPAREN          reduce using rule 108 (param_list -> param_list COMMA parameter .)


state 224

    (109) parameter -> LOCAL_VAR .
    (110) parameter -> LOCAL_VAR . EQLS expression

    COMMA           reduce using rule 109 (parameter -> LOCAL_VAR .)
    COLON           reduce using rule 109 (parameter -> LOCAL_VAR .)
    BREAK           reduce using rule 109 (parameter -> LOCAL_VAR .)
    NEXT            reduce using rule 109 (parameter -> LOCAL_VAR .)
    ELSIF           reduce using rule 109 (parameter -> LOCAL_VAR .)
    ELSE            reduce using rule 109 (parameter -> LOCAL_VAR .)
    RETURN          reduce using rule 109 (parameter -> LOCAL_VAR .)
    PRINT           reduce using rule 109 (parameter -> LOCAL_VAR .)
    PUTS            reduce using rule 109 (parameter -> LOCAL_VAR .)
    WHILE           reduce using rule 109 (parameter -> LOCAL_VAR .)
    FOR             reduce using rule 109 (parameter -> LOCAL_VAR .)
    LBRACE          reduce using rule 109 (parameter -> LOCAL_VAR .)
    DEF             reduce using rule 109 (parameter -> LOCAL_VAR .)
    IF              reduce using rule 109 (parameter -> LOCAL_VAR .)
    THEN            reduce using rule 109 (parameter -> LOCAL_VAR .)
    NOT             reduce using rule 109 (parameter -> LOCAL_VAR .)
    NIL             reduce using rule 109 (parameter -> LOCAL_VAR .)
    TRUE            reduce using rule 109 (parameter -> LOCAL_VAR .)
    FALSE           reduce using rule 109 (parameter -> LOCAL_VAR .)
    LPAREN          reduce using rule 109 (parameter -> LOCAL_VAR .)
    INTEGER         reduce using rule 109 (parameter -> LOCAL_VAR .)
    FLOAT           reduce using rule 109 (parameter -> LOCAL_VAR .)
    RATIONAL        reduce using rule 109 (parameter -> LOCAL_VAR .)
    COMPLEX         reduce using rule 109 (parameter -> LOCAL_VAR .)
    STR             reduce using rule 109 (parameter -> LOCAL_VAR .)
    SYMBOL          reduce using rule 109 (parameter -> LOCAL_VAR .)
    REGEXP          reduce using rule 109 (parameter -> LOCAL_VAR .)
    MINUS           reduce using rule 109 (parameter -> LOCAL_VAR .)
    CLASS           reduce using rule 109 (parameter -> LOCAL_VAR .)
    INSTANCE_VAR    reduce using rule 109 (parameter -> LOCAL_VAR .)
    CLASS_VAR       reduce using rule 109 (parameter -> LOCAL_VAR .)
    GLOBAL_VAR      reduce using rule 109 (parameter -> LOCAL_VAR .)
    LOCAL_VAR       reduce using rule 109 (parameter -> LOCAL_VAR .)
    CONSTANT        reduce using rule 109 (parameter -> LOCAL_VAR .)
    LBRACKET        reduce using rule 109 (parameter -> LOCAL_VAR .)
    END_S           reduce using rule 109 (parameter -> LOCAL_VAR .)
    RPAREN          reduce using rule 109 (parameter -> LOCAL_VAR .)
    EQLS            shift and go to state 203


state 225

    (112) function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list . END_S
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 236
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 226

    (113) optional_ret -> COLON TYPE .

    BREAK           reduce using rule 113 (optional_ret -> COLON TYPE .)
    NEXT            reduce using rule 113 (optional_ret -> COLON TYPE .)
    ELSIF           reduce using rule 113 (optional_ret -> COLON TYPE .)
    ELSE            reduce using rule 113 (optional_ret -> COLON TYPE .)
    RETURN          reduce using rule 113 (optional_ret -> COLON TYPE .)
    PRINT           reduce using rule 113 (optional_ret -> COLON TYPE .)
    PUTS            reduce using rule 113 (optional_ret -> COLON TYPE .)
    WHILE           reduce using rule 113 (optional_ret -> COLON TYPE .)
    FOR             reduce using rule 113 (optional_ret -> COLON TYPE .)
    LBRACE          reduce using rule 113 (optional_ret -> COLON TYPE .)
    DEF             reduce using rule 113 (optional_ret -> COLON TYPE .)
    IF              reduce using rule 113 (optional_ret -> COLON TYPE .)
    THEN            reduce using rule 113 (optional_ret -> COLON TYPE .)
    NOT             reduce using rule 113 (optional_ret -> COLON TYPE .)
    NIL             reduce using rule 113 (optional_ret -> COLON TYPE .)
    TRUE            reduce using rule 113 (optional_ret -> COLON TYPE .)
    FALSE           reduce using rule 113 (optional_ret -> COLON TYPE .)
    LPAREN          reduce using rule 113 (optional_ret -> COLON TYPE .)
    INTEGER         reduce using rule 113 (optional_ret -> COLON TYPE .)
    FLOAT           reduce using rule 113 (optional_ret -> COLON TYPE .)
    RATIONAL        reduce using rule 113 (optional_ret -> COLON TYPE .)
    COMPLEX         reduce using rule 113 (optional_ret -> COLON TYPE .)
    STR             reduce using rule 113 (optional_ret -> COLON TYPE .)
    SYMBOL          reduce using rule 113 (optional_ret -> COLON TYPE .)
    REGEXP          reduce using rule 113 (optional_ret -> COLON TYPE .)
    MINUS           reduce using rule 113 (optional_ret -> COLON TYPE .)
    CLASS           reduce using rule 113 (optional_ret -> COLON TYPE .)
    INSTANCE_VAR    reduce using rule 113 (optional_ret -> COLON TYPE .)
    CLASS_VAR       reduce using rule 113 (optional_ret -> COLON TYPE .)
    GLOBAL_VAR      reduce using rule 113 (optional_ret -> COLON TYPE .)
    LOCAL_VAR       reduce using rule 113 (optional_ret -> COLON TYPE .)
    CONSTANT        reduce using rule 113 (optional_ret -> COLON TYPE .)
    LBRACKET        reduce using rule 113 (optional_ret -> COLON TYPE .)
    END_S           reduce using rule 113 (optional_ret -> COLON TYPE .)


state 227

    (46) if_stmt -> IF expression_logic optional_then stmt_block elsif_list . else_part END_S
    (50) elsif_list -> elsif_list . ELSIF expression_logic optional_then stmt_block
    (20) statement -> elsif_list .
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (111) empty -> .

  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! reduce/reduce conflict for END_S resolved using rule 20 (statement -> elsif_list .)
    ELSIF           shift and go to state 61
    BREAK           reduce using rule 20 (statement -> elsif_list .)
    NEXT            reduce using rule 20 (statement -> elsif_list .)
    RETURN          reduce using rule 20 (statement -> elsif_list .)
    PRINT           reduce using rule 20 (statement -> elsif_list .)
    PUTS            reduce using rule 20 (statement -> elsif_list .)
    WHILE           reduce using rule 20 (statement -> elsif_list .)
    FOR             reduce using rule 20 (statement -> elsif_list .)
    LBRACE          reduce using rule 20 (statement -> elsif_list .)
    DEF             reduce using rule 20 (statement -> elsif_list .)
    IF              reduce using rule 20 (statement -> elsif_list .)
    THEN            reduce using rule 20 (statement -> elsif_list .)
    NOT             reduce using rule 20 (statement -> elsif_list .)
    NIL             reduce using rule 20 (statement -> elsif_list .)
    TRUE            reduce using rule 20 (statement -> elsif_list .)
    FALSE           reduce using rule 20 (statement -> elsif_list .)
    LPAREN          reduce using rule 20 (statement -> elsif_list .)
    INTEGER         reduce using rule 20 (statement -> elsif_list .)
    FLOAT           reduce using rule 20 (statement -> elsif_list .)
    RATIONAL        reduce using rule 20 (statement -> elsif_list .)
    COMPLEX         reduce using rule 20 (statement -> elsif_list .)
    STR             reduce using rule 20 (statement -> elsif_list .)
    SYMBOL          reduce using rule 20 (statement -> elsif_list .)
    REGEXP          reduce using rule 20 (statement -> elsif_list .)
    MINUS           reduce using rule 20 (statement -> elsif_list .)
    CLASS           reduce using rule 20 (statement -> elsif_list .)
    INSTANCE_VAR    reduce using rule 20 (statement -> elsif_list .)
    CLASS_VAR       reduce using rule 20 (statement -> elsif_list .)
    GLOBAL_VAR      reduce using rule 20 (statement -> elsif_list .)
    LOCAL_VAR       reduce using rule 20 (statement -> elsif_list .)
    CONSTANT        reduce using rule 20 (statement -> elsif_list .)
    LBRACKET        reduce using rule 20 (statement -> elsif_list .)
    END_S           reduce using rule 20 (statement -> elsif_list .)
    ELSE            shift and go to state 239

  ! ELSIF           [ reduce using rule 20 (statement -> elsif_list .) ]
  ! ELSE            [ reduce using rule 20 (statement -> elsif_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    else_part                      shift and go to state 237
    empty                          shift and go to state 238

state 228

    (49) elsif_list -> empty .
    (48) optional_then -> empty .
    (51) else_part -> empty .

  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NEXT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSIF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for ELSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RETURN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for PUTS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for DEF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for THEN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NOT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INTEGER resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for RATIONAL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for COMPLEX resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for STR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for REGEXP resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for MINUS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for INSTANCE_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CLASS_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for GLOBAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LOCAL_VAR resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for CONSTANT resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 48 (optional_then -> empty .)
  ! reduce/reduce conflict for END_S resolved using rule 48 (optional_then -> empty .)
    BREAK           reduce using rule 48 (optional_then -> empty .)
    NEXT            reduce using rule 48 (optional_then -> empty .)
    ELSIF           reduce using rule 48 (optional_then -> empty .)
    ELSE            reduce using rule 48 (optional_then -> empty .)
    RETURN          reduce using rule 48 (optional_then -> empty .)
    PRINT           reduce using rule 48 (optional_then -> empty .)
    PUTS            reduce using rule 48 (optional_then -> empty .)
    WHILE           reduce using rule 48 (optional_then -> empty .)
    FOR             reduce using rule 48 (optional_then -> empty .)
    LBRACE          reduce using rule 48 (optional_then -> empty .)
    DEF             reduce using rule 48 (optional_then -> empty .)
    IF              reduce using rule 48 (optional_then -> empty .)
    THEN            reduce using rule 48 (optional_then -> empty .)
    NOT             reduce using rule 48 (optional_then -> empty .)
    NIL             reduce using rule 48 (optional_then -> empty .)
    TRUE            reduce using rule 48 (optional_then -> empty .)
    FALSE           reduce using rule 48 (optional_then -> empty .)
    LPAREN          reduce using rule 48 (optional_then -> empty .)
    INTEGER         reduce using rule 48 (optional_then -> empty .)
    FLOAT           reduce using rule 48 (optional_then -> empty .)
    RATIONAL        reduce using rule 48 (optional_then -> empty .)
    COMPLEX         reduce using rule 48 (optional_then -> empty .)
    STR             reduce using rule 48 (optional_then -> empty .)
    SYMBOL          reduce using rule 48 (optional_then -> empty .)
    REGEXP          reduce using rule 48 (optional_then -> empty .)
    MINUS           reduce using rule 48 (optional_then -> empty .)
    CLASS           reduce using rule 48 (optional_then -> empty .)
    INSTANCE_VAR    reduce using rule 48 (optional_then -> empty .)
    CLASS_VAR       reduce using rule 48 (optional_then -> empty .)
    GLOBAL_VAR      reduce using rule 48 (optional_then -> empty .)
    LOCAL_VAR       reduce using rule 48 (optional_then -> empty .)
    CONSTANT        reduce using rule 48 (optional_then -> empty .)
    LBRACKET        reduce using rule 48 (optional_then -> empty .)
    END_S           reduce using rule 48 (optional_then -> empty .)

  ! ELSIF           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! ELSE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! END_S           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NEXT            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RETURN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PRINT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! PUTS            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! WHILE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FOR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACE          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! DEF             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! IF              [ reduce using rule 49 (elsif_list -> empty .) ]
  ! THEN            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NOT             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! NIL             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! TRUE            [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FALSE           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LPAREN          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INTEGER         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! FLOAT           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! RATIONAL        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! COMPLEX         [ reduce using rule 49 (elsif_list -> empty .) ]
  ! STR             [ reduce using rule 49 (elsif_list -> empty .) ]
  ! SYMBOL          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! REGEXP          [ reduce using rule 49 (elsif_list -> empty .) ]
  ! MINUS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS           [ reduce using rule 49 (elsif_list -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 49 (elsif_list -> empty .) ]
  ! CONSTANT        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! LBRACKET        [ reduce using rule 49 (elsif_list -> empty .) ]
  ! BREAK           [ reduce using rule 51 (else_part -> empty .) ]
  ! NEXT            [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSIF           [ reduce using rule 51 (else_part -> empty .) ]
  ! ELSE            [ reduce using rule 51 (else_part -> empty .) ]
  ! RETURN          [ reduce using rule 51 (else_part -> empty .) ]
  ! PRINT           [ reduce using rule 51 (else_part -> empty .) ]
  ! PUTS            [ reduce using rule 51 (else_part -> empty .) ]
  ! WHILE           [ reduce using rule 51 (else_part -> empty .) ]
  ! FOR             [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACE          [ reduce using rule 51 (else_part -> empty .) ]
  ! DEF             [ reduce using rule 51 (else_part -> empty .) ]
  ! IF              [ reduce using rule 51 (else_part -> empty .) ]
  ! THEN            [ reduce using rule 51 (else_part -> empty .) ]
  ! NOT             [ reduce using rule 51 (else_part -> empty .) ]
  ! NIL             [ reduce using rule 51 (else_part -> empty .) ]
  ! TRUE            [ reduce using rule 51 (else_part -> empty .) ]
  ! FALSE           [ reduce using rule 51 (else_part -> empty .) ]
  ! LPAREN          [ reduce using rule 51 (else_part -> empty .) ]
  ! INTEGER         [ reduce using rule 51 (else_part -> empty .) ]
  ! FLOAT           [ reduce using rule 51 (else_part -> empty .) ]
  ! RATIONAL        [ reduce using rule 51 (else_part -> empty .) ]
  ! COMPLEX         [ reduce using rule 51 (else_part -> empty .) ]
  ! STR             [ reduce using rule 51 (else_part -> empty .) ]
  ! SYMBOL          [ reduce using rule 51 (else_part -> empty .) ]
  ! REGEXP          [ reduce using rule 51 (else_part -> empty .) ]
  ! MINUS           [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS           [ reduce using rule 51 (else_part -> empty .) ]
  ! INSTANCE_VAR    [ reduce using rule 51 (else_part -> empty .) ]
  ! CLASS_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! GLOBAL_VAR      [ reduce using rule 51 (else_part -> empty .) ]
  ! LOCAL_VAR       [ reduce using rule 51 (else_part -> empty .) ]
  ! CONSTANT        [ reduce using rule 51 (else_part -> empty .) ]
  ! LBRACKET        [ reduce using rule 51 (else_part -> empty .) ]
  ! END_S           [ reduce using rule 51 (else_part -> empty .) ]


state 229

    (121) class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .

    BREAK           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    NEXT            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    ELSIF           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    ELSE            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    RETURN          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    PRINT           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    PUTS            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    WHILE           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    FOR             reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    LBRACE          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    DEF             reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    IF              reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    THEN            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    NOT             reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    NIL             reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    TRUE            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    FALSE           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    LPAREN          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    INTEGER         reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    FLOAT           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    RATIONAL        reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    COMPLEX         reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    STR             reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    SYMBOL          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    REGEXP          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    MINUS           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    CLASS           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    INSTANCE_VAR    reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    CLASS_VAR       reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    GLOBAL_VAR      reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    LOCAL_VAR       reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    CONSTANT        reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    LBRACKET        reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    $end            reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    RBRACE          reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)
    END_S           reduce using rule 121 (class_def -> CLASS CONSTANT opt_inherit stmt_block END_S .)


state 230

    (148) expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .

    EQLS            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LBRACKET        reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    DOT             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RANGE_INCL      reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RANGE_EXCL      reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    PLUS            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    MINUS           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    MULT            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    DIV             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    MOD             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    POWER           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    BREAK           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    NEXT            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    ELSIF           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    ELSE            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RETURN          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    PRINT           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    PUTS            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    WHILE           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    FOR             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LBRACE          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    DEF             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    IF              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    THEN            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    NOT             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    NIL             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    TRUE            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    FALSE           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LPAREN          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    INTEGER         reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    FLOAT           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RATIONAL        reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    COMPLEX         reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    STR             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    SYMBOL          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    REGEXP          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    CLASS           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    INSTANCE_VAR    reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    CLASS_VAR       reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    GLOBAL_VAR      reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LOCAL_VAR       reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    CONSTANT        reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    $end            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RBRACE          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    END_S           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LT              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    LE              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    GT              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    GE              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    EQ              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    NE              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    EQQ             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    MATCH           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    NMATCH          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    ARROW           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RPAREN          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    COMMA           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    RBRACKET        reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    ANDAND          reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    OROR            reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    AND             reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    OR              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    DO              reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)
    COLON           reduce using rule 148 (expr_postfix -> expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN .)


state 231

    (38) while_stmt -> WHILE expression_logic while_enter DO statement_list END_S . while_exit
    (41) while_exit -> .

    BREAK           reduce using rule 41 (while_exit -> .)
    NEXT            reduce using rule 41 (while_exit -> .)
    ELSIF           reduce using rule 41 (while_exit -> .)
    ELSE            reduce using rule 41 (while_exit -> .)
    RETURN          reduce using rule 41 (while_exit -> .)
    PRINT           reduce using rule 41 (while_exit -> .)
    PUTS            reduce using rule 41 (while_exit -> .)
    WHILE           reduce using rule 41 (while_exit -> .)
    FOR             reduce using rule 41 (while_exit -> .)
    LBRACE          reduce using rule 41 (while_exit -> .)
    DEF             reduce using rule 41 (while_exit -> .)
    IF              reduce using rule 41 (while_exit -> .)
    THEN            reduce using rule 41 (while_exit -> .)
    NOT             reduce using rule 41 (while_exit -> .)
    NIL             reduce using rule 41 (while_exit -> .)
    TRUE            reduce using rule 41 (while_exit -> .)
    FALSE           reduce using rule 41 (while_exit -> .)
    LPAREN          reduce using rule 41 (while_exit -> .)
    INTEGER         reduce using rule 41 (while_exit -> .)
    FLOAT           reduce using rule 41 (while_exit -> .)
    RATIONAL        reduce using rule 41 (while_exit -> .)
    COMPLEX         reduce using rule 41 (while_exit -> .)
    STR             reduce using rule 41 (while_exit -> .)
    SYMBOL          reduce using rule 41 (while_exit -> .)
    REGEXP          reduce using rule 41 (while_exit -> .)
    MINUS           reduce using rule 41 (while_exit -> .)
    CLASS           reduce using rule 41 (while_exit -> .)
    INSTANCE_VAR    reduce using rule 41 (while_exit -> .)
    CLASS_VAR       reduce using rule 41 (while_exit -> .)
    GLOBAL_VAR      reduce using rule 41 (while_exit -> .)
    LOCAL_VAR       reduce using rule 41 (while_exit -> .)
    CONSTANT        reduce using rule 41 (while_exit -> .)
    LBRACKET        reduce using rule 41 (while_exit -> .)
    $end            reduce using rule 41 (while_exit -> .)
    RBRACE          reduce using rule 41 (while_exit -> .)
    END_S           reduce using rule 41 (while_exit -> .)

    while_exit                     shift and go to state 240

state 232

    (39) while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .

    BREAK           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    NEXT            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    ELSIF           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    ELSE            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    RETURN          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    PRINT           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    PUTS            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    WHILE           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    FOR             reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    LBRACE          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    DEF             reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    IF              reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    THEN            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    NOT             reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    NIL             reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    TRUE            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    FALSE           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    LPAREN          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    INTEGER         reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    FLOAT           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    RATIONAL        reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    COMPLEX         reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    STR             reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    SYMBOL          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    REGEXP          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    MINUS           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    CLASS           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    INSTANCE_VAR    reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    CLASS_VAR       reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    GLOBAL_VAR      reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    LOCAL_VAR       reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    CONSTANT        reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    LBRACKET        reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    $end            reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    RBRACE          reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)
    END_S           reduce using rule 39 (while_stmt -> WHILE expression_logic while_enter statement_list END_S while_exit .)


state 233

    (42) for_stmt -> FOR LOCAL_VAR IN expression for_enter DO . statement_list END_S for_exit
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    expression                     shift and go to state 18
    statement_list                 shift and go to state 241
    statement                      shift and go to state 3
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 234

    (43) for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list . END_S for_exit
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 242
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    expression                     shift and go to state 18
    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 235

    (104) function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list . END_S
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 243
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 236

    (112) function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .

    BREAK           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    NEXT            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    ELSIF           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    ELSE            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    RETURN          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    PRINT           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    PUTS            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    WHILE           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    FOR             reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    LBRACE          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    DEF             reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    IF              reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    THEN            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    NOT             reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    NIL             reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    TRUE            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    FALSE           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    LPAREN          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    INTEGER         reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    FLOAT           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    RATIONAL        reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    COMPLEX         reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    STR             reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    SYMBOL          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    REGEXP          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    MINUS           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    CLASS           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    INSTANCE_VAR    reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    CLASS_VAR       reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    GLOBAL_VAR      reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    LOCAL_VAR       reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    CONSTANT        reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    LBRACKET        reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    $end            reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    RBRACE          reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)
    END_S           reduce using rule 112 (function_def -> DEF LOCAL_VAR optional_params optional_ret statement_list END_S .)


state 237

    (46) if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part . END_S

    END_S           shift and go to state 244


state 238

    (51) else_part -> empty .

    END_S           reduce using rule 51 (else_part -> empty .)


state 239

    (52) else_part -> ELSE . stmt_block
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    LBRACE          shift and go to state 81
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    END_S           reduce using rule 111 (empty -> .)
    LBRACKET        shift and go to state 55

  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 245
    statement                      shift and go to state 80
    statement_list                 shift and go to state 58
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 240

    (38) while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .

    BREAK           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    NEXT            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    ELSIF           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    ELSE            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    RETURN          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    PRINT           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    PUTS            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    WHILE           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    FOR             reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    LBRACE          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    DEF             reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    IF              reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    THEN            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    NOT             reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    NIL             reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    TRUE            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    FALSE           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    LPAREN          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    INTEGER         reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    FLOAT           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    RATIONAL        reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    COMPLEX         reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    STR             reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    SYMBOL          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    REGEXP          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    MINUS           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    CLASS           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    INSTANCE_VAR    reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    CLASS_VAR       reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    GLOBAL_VAR      reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    LOCAL_VAR       reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    CONSTANT        reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    LBRACKET        reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    $end            reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    RBRACE          reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)
    END_S           reduce using rule 38 (while_stmt -> WHILE expression_logic while_enter DO statement_list END_S while_exit .)


state 241

    (42) for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list . END_S for_exit
    (2) statement_list -> statement_list . statement
    (9) stmt_block -> statement_list .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for END_S resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 9 (stmt_block -> statement_list .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           shift and go to state 246
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! BREAK           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NEXT            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSIF           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! ELSE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RETURN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PRINT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! PUTS            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! WHILE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FOR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACE          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! DEF             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! IF              [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! THEN            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NOT             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! NIL             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! TRUE            [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FALSE           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LPAREN          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INTEGER         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! FLOAT           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! RATIONAL        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! COMPLEX         [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! STR             [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! SYMBOL          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! REGEXP          [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! MINUS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS           [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! INSTANCE_VAR    [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CLASS_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! GLOBAL_VAR      [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LOCAL_VAR       [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! CONSTANT        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! LBRACKET        [ reduce using rule 9 (stmt_block -> statement_list .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]

    expression                     shift and go to state 18
    statement_list                 shift and go to state 58
    statement                      shift and go to state 59
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    stmt_block                     shift and go to state 15
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 242

    (43) for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S . for_exit
    (45) for_exit -> .

    BREAK           reduce using rule 45 (for_exit -> .)
    NEXT            reduce using rule 45 (for_exit -> .)
    ELSIF           reduce using rule 45 (for_exit -> .)
    ELSE            reduce using rule 45 (for_exit -> .)
    RETURN          reduce using rule 45 (for_exit -> .)
    PRINT           reduce using rule 45 (for_exit -> .)
    PUTS            reduce using rule 45 (for_exit -> .)
    WHILE           reduce using rule 45 (for_exit -> .)
    FOR             reduce using rule 45 (for_exit -> .)
    LBRACE          reduce using rule 45 (for_exit -> .)
    DEF             reduce using rule 45 (for_exit -> .)
    IF              reduce using rule 45 (for_exit -> .)
    THEN            reduce using rule 45 (for_exit -> .)
    NOT             reduce using rule 45 (for_exit -> .)
    NIL             reduce using rule 45 (for_exit -> .)
    TRUE            reduce using rule 45 (for_exit -> .)
    FALSE           reduce using rule 45 (for_exit -> .)
    LPAREN          reduce using rule 45 (for_exit -> .)
    INTEGER         reduce using rule 45 (for_exit -> .)
    FLOAT           reduce using rule 45 (for_exit -> .)
    RATIONAL        reduce using rule 45 (for_exit -> .)
    COMPLEX         reduce using rule 45 (for_exit -> .)
    STR             reduce using rule 45 (for_exit -> .)
    SYMBOL          reduce using rule 45 (for_exit -> .)
    REGEXP          reduce using rule 45 (for_exit -> .)
    MINUS           reduce using rule 45 (for_exit -> .)
    CLASS           reduce using rule 45 (for_exit -> .)
    INSTANCE_VAR    reduce using rule 45 (for_exit -> .)
    CLASS_VAR       reduce using rule 45 (for_exit -> .)
    GLOBAL_VAR      reduce using rule 45 (for_exit -> .)
    LOCAL_VAR       reduce using rule 45 (for_exit -> .)
    CONSTANT        reduce using rule 45 (for_exit -> .)
    LBRACKET        reduce using rule 45 (for_exit -> .)
    $end            reduce using rule 45 (for_exit -> .)
    RBRACE          reduce using rule 45 (for_exit -> .)
    END_S           reduce using rule 45 (for_exit -> .)

    for_exit                       shift and go to state 247

state 243

    (104) function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .

    BREAK           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    NEXT            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    ELSIF           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    ELSE            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    RETURN          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    PRINT           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    PUTS            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    WHILE           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    FOR             reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    LBRACE          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    DEF             reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    IF              reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    THEN            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    NOT             reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    NIL             reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    TRUE            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    FALSE           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    LPAREN          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    INTEGER         reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    FLOAT           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    RATIONAL        reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    COMPLEX         reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    STR             reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    SYMBOL          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    REGEXP          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    MINUS           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    CLASS           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    INSTANCE_VAR    reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    CLASS_VAR       reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    GLOBAL_VAR      reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    LOCAL_VAR       reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    CONSTANT        reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    LBRACKET        reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    $end            reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    RBRACE          reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)
    END_S           reduce using rule 104 (function_def -> DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S .)


state 244

    (46) if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .

    BREAK           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    NEXT            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    ELSIF           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    ELSE            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    RETURN          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    PRINT           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    PUTS            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    WHILE           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    FOR             reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    LBRACE          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    DEF             reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    IF              reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    THEN            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    NOT             reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    NIL             reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    TRUE            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    FALSE           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    LPAREN          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    INTEGER         reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    FLOAT           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    RATIONAL        reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    COMPLEX         reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    STR             reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    SYMBOL          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    REGEXP          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    MINUS           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    CLASS           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    INSTANCE_VAR    reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    CLASS_VAR       reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    GLOBAL_VAR      reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    LOCAL_VAR       reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    CONSTANT        reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    LBRACKET        reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    $end            reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    RBRACE          reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)
    END_S           reduce using rule 46 (if_stmt -> IF expression_logic optional_then stmt_block elsif_list else_part END_S .)


state 245

    (52) else_part -> ELSE stmt_block .
    (7) stmt_block -> stmt_block . statement
    (19) statement -> stmt_block .
    (4) statement -> . BREAK
    (5) statement -> . NEXT
    (10) statement -> . print_stmt
    (11) statement -> . input_stmt
    (12) statement -> . assignment
    (13) statement -> . while_stmt
    (14) statement -> . for_stmt
    (15) statement -> . hash_literal
    (16) statement -> . function_def
    (17) statement -> . if_stmt
    (18) statement -> . optional_then
    (19) statement -> . stmt_block
    (20) statement -> . elsif_list
    (21) statement -> . else_part
    (22) statement -> . expression
    (53) statement -> . ELSIF expression_logic optional_then stmt_block
    (54) statement -> . ELSIF expression
    (55) statement -> . ELSE stmt_block
    (56) statement -> . ELSE
    (115) statement -> . RETURN
    (116) statement -> . RETURN expression
    (124) statement -> . class_def
    (127) statement -> . property_decl
    (129) statement -> . method_def
    (23) print_stmt -> . PRINT expression
    (24) print_stmt -> . PUTS expression
    (25) input_stmt -> . variable EQLS LOCAL_VAR
    (31) assignment -> . variable EQLS expression
    (32) assignment -> . variable PLUSEQLS expression
    (33) assignment -> . variable MINUSEQLS expression
    (34) assignment -> . variable MULTEQLS expression
    (35) assignment -> . variable DIVEQLS expression
    (36) assignment -> . variable MODEQLS expression
    (37) assignment -> . variable POWEREQLS expression
    (102) assignment -> . expr_postfix EQLS expression
    (38) while_stmt -> . WHILE expression_logic while_enter DO statement_list END_S while_exit
    (39) while_stmt -> . WHILE expression_logic while_enter statement_list END_S while_exit
    (42) for_stmt -> . FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit
    (43) for_stmt -> . FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit
    (72) hash_literal -> . LBRACE hash_pairs_opt RBRACE
    (103) function_def -> . DEF LOCAL_VAR statement_list END_S
    (104) function_def -> . DEF LOCAL_VAR LPAREN param_list RPAREN statement_list END_S
    (112) function_def -> . DEF LOCAL_VAR optional_params optional_ret statement_list END_S
    (46) if_stmt -> . IF expression_logic optional_then stmt_block elsif_list else_part END_S
    (47) optional_then -> . THEN
    (48) optional_then -> . empty
    (6) stmt_block -> . statement
    (7) stmt_block -> . stmt_block statement
    (8) stmt_block -> . LBRACE statement_list RBRACE
    (9) stmt_block -> . statement_list
    (49) elsif_list -> . empty
    (50) elsif_list -> . elsif_list ELSIF expression_logic optional_then stmt_block
    (51) else_part -> . empty
    (52) else_part -> . ELSE stmt_block
    (71) expression -> . NOT expression
    (80) expression -> . hash_literal
    (81) expression -> . expression RANGE_INCL expression
    (82) expression -> . expression RANGE_EXCL expression
    (117) expression -> . NIL
    (118) expression -> . TRUE
    (119) expression -> . FALSE
    (130) expression -> . expression PLUS expression
    (131) expression -> . expression MINUS expression
    (132) expression -> . expression MULT expression
    (133) expression -> . expression DIV expression
    (134) expression -> . expression MOD expression
    (135) expression -> . expression POWER expression
    (136) expression -> . LPAREN expression RPAREN
    (137) expression -> . INTEGER
    (138) expression -> . FLOAT
    (139) expression -> . RATIONAL
    (140) expression -> . COMPLEX
    (141) expression -> . STR
    (142) expression -> . SYMBOL
    (143) expression -> . REGEXP
    (144) expression -> . variable
    (145) expression -> . expr_postfix
    (149) expression -> . MINUS expression
    (120) class_def -> . CLASS CONSTANT stmt_block END_S
    (121) class_def -> . CLASS CONSTANT opt_inherit stmt_block END_S
    (125) property_decl -> . INSTANCE_VAR
    (126) property_decl -> . CLASS_VAR
    (128) method_def -> . function_def
    (26) variable -> . GLOBAL_VAR
    (27) variable -> . LOCAL_VAR
    (28) variable -> . INSTANCE_VAR
    (29) variable -> . CLASS_VAR
    (30) variable -> . CONSTANT
    (97) expr_postfix -> . LOCAL_VAR LPAREN RPAREN
    (98) expr_postfix -> . LOCAL_VAR LPAREN expr_list RPAREN
    (99) expr_postfix -> . expr_postfix LBRACKET expression RBRACKET
    (100) expr_postfix -> . primary
    (146) expr_postfix -> . expr_postfix DOT LOCAL_VAR
    (147) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN RPAREN
    (148) expr_postfix -> . expr_postfix DOT LOCAL_VAR LPAREN expr_list RPAREN
    (111) empty -> .
    (2) statement_list -> . statement_list statement
    (3) statement_list -> . statement
    (87) primary -> . INTEGER
    (88) primary -> . FLOAT
    (89) primary -> . STR
    (90) primary -> . SYMBOL
    (91) primary -> . variable
    (92) primary -> . TRUE
    (93) primary -> . FALSE
    (94) primary -> . NIL
    (95) primary -> . LPAREN expression RPAREN
    (96) primary -> . array_literal
    (85) array_literal -> . LBRACKET RBRACKET
    (86) array_literal -> . LBRACKET expr_list RBRACKET

  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for NEXT resolved as shift
  ! shift/reduce conflict for ELSIF resolved as shift
  ! shift/reduce conflict for ELSE resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for PUTS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LBRACE resolved as shift
  ! shift/reduce conflict for DEF resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for THEN resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for RATIONAL resolved as shift
  ! shift/reduce conflict for COMPLEX resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for SYMBOL resolved as shift
  ! shift/reduce conflict for REGEXP resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for INSTANCE_VAR resolved as shift
  ! shift/reduce conflict for CLASS_VAR resolved as shift
  ! shift/reduce conflict for GLOBAL_VAR resolved as shift
  ! shift/reduce conflict for LOCAL_VAR resolved as shift
  ! shift/reduce conflict for CONSTANT resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 19 (statement -> stmt_block .)
  ! reduce/reduce conflict for END_S resolved using rule 19 (statement -> stmt_block .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    END_S           reduce using rule 19 (statement -> stmt_block .)
    BREAK           shift and go to state 4
    NEXT            shift and go to state 5
    ELSIF           shift and go to state 19
    ELSE            shift and go to state 20
    RETURN          shift and go to state 21
    PRINT           shift and go to state 25
    PUTS            shift and go to state 26
    WHILE           shift and go to state 30
    FOR             shift and go to state 31
    LBRACE          shift and go to state 32
    DEF             shift and go to state 33
    IF              shift and go to state 35
    THEN            shift and go to state 36
    NOT             shift and go to state 38
    NIL             shift and go to state 39
    TRUE            shift and go to state 40
    FALSE           shift and go to state 41
    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    RATIONAL        shift and go to state 45
    COMPLEX         shift and go to state 46
    STR             shift and go to state 47
    SYMBOL          shift and go to state 48
    REGEXP          shift and go to state 49
    MINUS           shift and go to state 42
    CLASS           shift and go to state 50
    INSTANCE_VAR    shift and go to state 52
    CLASS_VAR       shift and go to state 53
    GLOBAL_VAR      shift and go to state 54
    LOCAL_VAR       shift and go to state 28
    CONSTANT        shift and go to state 51
    LBRACKET        shift and go to state 55

  ! END_S           [ reduce using rule 52 (else_part -> ELSE stmt_block .) ]
  ! BREAK           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NEXT            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSIF           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! ELSE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RETURN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PRINT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! PUTS            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! WHILE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FOR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACE          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! DEF             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! IF              [ reduce using rule 19 (statement -> stmt_block .) ]
  ! THEN            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NOT             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! NIL             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! TRUE            [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FALSE           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LPAREN          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INTEGER         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! FLOAT           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! RATIONAL        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! COMPLEX         [ reduce using rule 19 (statement -> stmt_block .) ]
  ! STR             [ reduce using rule 19 (statement -> stmt_block .) ]
  ! SYMBOL          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! REGEXP          [ reduce using rule 19 (statement -> stmt_block .) ]
  ! MINUS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS           [ reduce using rule 19 (statement -> stmt_block .) ]
  ! INSTANCE_VAR    [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CLASS_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! GLOBAL_VAR      [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LOCAL_VAR       [ reduce using rule 19 (statement -> stmt_block .) ]
  ! CONSTANT        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! LBRACKET        [ reduce using rule 19 (statement -> stmt_block .) ]
  ! BREAK           [ reduce using rule 111 (empty -> .) ]
  ! NEXT            [ reduce using rule 111 (empty -> .) ]
  ! ELSIF           [ reduce using rule 111 (empty -> .) ]
  ! ELSE            [ reduce using rule 111 (empty -> .) ]
  ! RETURN          [ reduce using rule 111 (empty -> .) ]
  ! PRINT           [ reduce using rule 111 (empty -> .) ]
  ! PUTS            [ reduce using rule 111 (empty -> .) ]
  ! WHILE           [ reduce using rule 111 (empty -> .) ]
  ! FOR             [ reduce using rule 111 (empty -> .) ]
  ! LBRACE          [ reduce using rule 111 (empty -> .) ]
  ! DEF             [ reduce using rule 111 (empty -> .) ]
  ! IF              [ reduce using rule 111 (empty -> .) ]
  ! THEN            [ reduce using rule 111 (empty -> .) ]
  ! NOT             [ reduce using rule 111 (empty -> .) ]
  ! NIL             [ reduce using rule 111 (empty -> .) ]
  ! TRUE            [ reduce using rule 111 (empty -> .) ]
  ! FALSE           [ reduce using rule 111 (empty -> .) ]
  ! LPAREN          [ reduce using rule 111 (empty -> .) ]
  ! INTEGER         [ reduce using rule 111 (empty -> .) ]
  ! FLOAT           [ reduce using rule 111 (empty -> .) ]
  ! RATIONAL        [ reduce using rule 111 (empty -> .) ]
  ! COMPLEX         [ reduce using rule 111 (empty -> .) ]
  ! STR             [ reduce using rule 111 (empty -> .) ]
  ! SYMBOL          [ reduce using rule 111 (empty -> .) ]
  ! REGEXP          [ reduce using rule 111 (empty -> .) ]
  ! MINUS           [ reduce using rule 111 (empty -> .) ]
  ! CLASS           [ reduce using rule 111 (empty -> .) ]
  ! INSTANCE_VAR    [ reduce using rule 111 (empty -> .) ]
  ! CLASS_VAR       [ reduce using rule 111 (empty -> .) ]
  ! GLOBAL_VAR      [ reduce using rule 111 (empty -> .) ]
  ! LOCAL_VAR       [ reduce using rule 111 (empty -> .) ]
  ! CONSTANT        [ reduce using rule 111 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 111 (empty -> .) ]
  ! END_S           [ reduce using rule 111 (empty -> .) ]

    stmt_block                     shift and go to state 15
    statement                      shift and go to state 60
    print_stmt                     shift and go to state 6
    input_stmt                     shift and go to state 7
    assignment                     shift and go to state 8
    while_stmt                     shift and go to state 9
    for_stmt                       shift and go to state 10
    hash_literal                   shift and go to state 11
    function_def                   shift and go to state 12
    if_stmt                        shift and go to state 13
    optional_then                  shift and go to state 14
    elsif_list                     shift and go to state 16
    else_part                      shift and go to state 17
    expression                     shift and go to state 18
    class_def                      shift and go to state 22
    property_decl                  shift and go to state 23
    method_def                     shift and go to state 24
    variable                       shift and go to state 27
    expr_postfix                   shift and go to state 29
    statement_list                 shift and go to state 58
    empty                          shift and go to state 37
    primary                        shift and go to state 56
    array_literal                  shift and go to state 57

state 246

    (42) for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S . for_exit
    (45) for_exit -> .

    BREAK           reduce using rule 45 (for_exit -> .)
    NEXT            reduce using rule 45 (for_exit -> .)
    ELSIF           reduce using rule 45 (for_exit -> .)
    ELSE            reduce using rule 45 (for_exit -> .)
    RETURN          reduce using rule 45 (for_exit -> .)
    PRINT           reduce using rule 45 (for_exit -> .)
    PUTS            reduce using rule 45 (for_exit -> .)
    WHILE           reduce using rule 45 (for_exit -> .)
    FOR             reduce using rule 45 (for_exit -> .)
    LBRACE          reduce using rule 45 (for_exit -> .)
    DEF             reduce using rule 45 (for_exit -> .)
    IF              reduce using rule 45 (for_exit -> .)
    THEN            reduce using rule 45 (for_exit -> .)
    NOT             reduce using rule 45 (for_exit -> .)
    NIL             reduce using rule 45 (for_exit -> .)
    TRUE            reduce using rule 45 (for_exit -> .)
    FALSE           reduce using rule 45 (for_exit -> .)
    LPAREN          reduce using rule 45 (for_exit -> .)
    INTEGER         reduce using rule 45 (for_exit -> .)
    FLOAT           reduce using rule 45 (for_exit -> .)
    RATIONAL        reduce using rule 45 (for_exit -> .)
    COMPLEX         reduce using rule 45 (for_exit -> .)
    STR             reduce using rule 45 (for_exit -> .)
    SYMBOL          reduce using rule 45 (for_exit -> .)
    REGEXP          reduce using rule 45 (for_exit -> .)
    MINUS           reduce using rule 45 (for_exit -> .)
    CLASS           reduce using rule 45 (for_exit -> .)
    INSTANCE_VAR    reduce using rule 45 (for_exit -> .)
    CLASS_VAR       reduce using rule 45 (for_exit -> .)
    GLOBAL_VAR      reduce using rule 45 (for_exit -> .)
    LOCAL_VAR       reduce using rule 45 (for_exit -> .)
    CONSTANT        reduce using rule 45 (for_exit -> .)
    LBRACKET        reduce using rule 45 (for_exit -> .)
    $end            reduce using rule 45 (for_exit -> .)
    RBRACE          reduce using rule 45 (for_exit -> .)
    END_S           reduce using rule 45 (for_exit -> .)

    for_exit                       shift and go to state 248

state 247

    (43) for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .

    BREAK           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    NEXT            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    ELSIF           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    ELSE            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    RETURN          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    PRINT           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    PUTS            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    WHILE           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    FOR             reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    LBRACE          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    DEF             reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    IF              reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    THEN            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    NOT             reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    NIL             reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    TRUE            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    FALSE           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    LPAREN          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    INTEGER         reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    FLOAT           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    RATIONAL        reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    COMPLEX         reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    STR             reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    SYMBOL          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    REGEXP          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    MINUS           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    CLASS           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    INSTANCE_VAR    reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    CLASS_VAR       reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    GLOBAL_VAR      reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    LOCAL_VAR       reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    CONSTANT        reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    LBRACKET        reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    $end            reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    RBRACE          reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)
    END_S           reduce using rule 43 (for_stmt -> FOR LOCAL_VAR IN expression for_enter statement_list END_S for_exit .)


state 248

    (42) for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .

    BREAK           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    NEXT            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    ELSIF           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    ELSE            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    RETURN          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    PRINT           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    PUTS            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    WHILE           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    FOR             reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    LBRACE          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    DEF             reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    IF              reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    THEN            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    NOT             reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    NIL             reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    TRUE            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    FALSE           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    LPAREN          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    INTEGER         reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    FLOAT           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    RATIONAL        reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    COMPLEX         reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    STR             reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    SYMBOL          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    REGEXP          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    MINUS           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    CLASS           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    INSTANCE_VAR    reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    CLASS_VAR       reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    GLOBAL_VAR      reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    LOCAL_VAR       reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    CONSTANT        reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    LBRACKET        reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    $end            reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    RBRACE          reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)
    END_S           reduce using rule 42 (for_stmt -> FOR LOCAL_VAR IN expression for_enter DO statement_list END_S for_exit .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for BREAK in state 0 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 0 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 0 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 0 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 0 resolved as shift
WARNING: shift/reduce conflict for DEF in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for THEN in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for NIL in state 0 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 0 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 0 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 0 resolved as shift
WARNING: shift/reduce conflict for STR in state 0 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 0 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 0 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 0 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 0 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 0 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 2 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 2 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 2 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 2 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 2 resolved as shift
WARNING: shift/reduce conflict for DEF in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for THEN in state 2 resolved as shift
WARNING: shift/reduce conflict for NOT in state 2 resolved as shift
WARNING: shift/reduce conflict for NIL in state 2 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 2 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 2 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 2 resolved as shift
WARNING: shift/reduce conflict for STR in state 2 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 2 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 2 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 2 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 2 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 2 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 2 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 2 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 2 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 2 resolved as shift
WARNING: shift/reduce conflict for DEF in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for THEN in state 2 resolved as shift
WARNING: shift/reduce conflict for NOT in state 2 resolved as shift
WARNING: shift/reduce conflict for NIL in state 2 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 2 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 2 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 2 resolved as shift
WARNING: shift/reduce conflict for STR in state 2 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 2 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 2 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 2 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 2 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 2 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 15 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 15 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 15 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 15 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 15 resolved as shift
WARNING: shift/reduce conflict for FOR in state 15 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 15 resolved as shift
WARNING: shift/reduce conflict for DEF in state 15 resolved as shift
WARNING: shift/reduce conflict for IF in state 15 resolved as shift
WARNING: shift/reduce conflict for THEN in state 15 resolved as shift
WARNING: shift/reduce conflict for NOT in state 15 resolved as shift
WARNING: shift/reduce conflict for NIL in state 15 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 15 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 15 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 15 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 15 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 15 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 15 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 15 resolved as shift
WARNING: shift/reduce conflict for STR in state 15 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 15 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 15 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 15 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 15 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 15 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 15 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 15 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 15 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 15 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 15 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 15 resolved as shift
WARNING: shift/reduce conflict for FOR in state 15 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 15 resolved as shift
WARNING: shift/reduce conflict for DEF in state 15 resolved as shift
WARNING: shift/reduce conflict for IF in state 15 resolved as shift
WARNING: shift/reduce conflict for THEN in state 15 resolved as shift
WARNING: shift/reduce conflict for NOT in state 15 resolved as shift
WARNING: shift/reduce conflict for NIL in state 15 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 15 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 15 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 15 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 15 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 15 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 15 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 15 resolved as shift
WARNING: shift/reduce conflict for STR in state 15 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 15 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 15 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 15 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 15 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 15 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 15 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 16 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 18 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 20 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 20 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 20 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 20 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 20 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 20 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 20 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for FOR in state 20 resolved as shift
WARNING: shift/reduce conflict for DEF in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for THEN in state 20 resolved as shift
WARNING: shift/reduce conflict for NOT in state 20 resolved as shift
WARNING: shift/reduce conflict for NIL in state 20 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 20 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 20 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 20 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 20 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 20 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 20 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 20 resolved as shift
WARNING: shift/reduce conflict for STR in state 20 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 20 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 20 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 20 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 20 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 20 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 20 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 20 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 20 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 20 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 20 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 20 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for FOR in state 20 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 20 resolved as shift
WARNING: shift/reduce conflict for DEF in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for THEN in state 20 resolved as shift
WARNING: shift/reduce conflict for NOT in state 20 resolved as shift
WARNING: shift/reduce conflict for NIL in state 20 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 20 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 20 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 20 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 20 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 20 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 20 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 20 resolved as shift
WARNING: shift/reduce conflict for STR in state 20 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 20 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 20 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 20 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 20 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 20 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 20 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 20 resolved as shift
WARNING: shift/reduce conflict for NOT in state 21 resolved as shift
WARNING: shift/reduce conflict for NIL in state 21 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 21 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 21 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 21 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 21 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 21 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 21 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 21 resolved as shift
WARNING: shift/reduce conflict for STR in state 21 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 21 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 21 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 21 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 21 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 21 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 21 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 21 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 21 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 21 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 21 resolved as shift
WARNING: shift/reduce conflict for EQLS in state 27 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 29 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 32 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 32 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 32 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 32 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 32 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 32 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 32 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 32 resolved as shift
WARNING: shift/reduce conflict for FOR in state 32 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 32 resolved as shift
WARNING: shift/reduce conflict for DEF in state 32 resolved as shift
WARNING: shift/reduce conflict for IF in state 32 resolved as shift
WARNING: shift/reduce conflict for THEN in state 32 resolved as shift
WARNING: shift/reduce conflict for NOT in state 32 resolved as shift
WARNING: shift/reduce conflict for NIL in state 32 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 32 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 32 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 32 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 32 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 32 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 32 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 32 resolved as shift
WARNING: shift/reduce conflict for STR in state 32 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 32 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 32 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 32 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 32 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 32 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 32 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 32 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 32 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 32 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 32 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 58 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 58 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 58 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 58 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 58 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 58 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 58 resolved as shift
WARNING: shift/reduce conflict for DEF in state 58 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for THEN in state 58 resolved as shift
WARNING: shift/reduce conflict for NOT in state 58 resolved as shift
WARNING: shift/reduce conflict for NIL in state 58 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 58 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 58 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 58 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 58 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 58 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 58 resolved as shift
WARNING: shift/reduce conflict for STR in state 58 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 58 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 58 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 58 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 58 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 58 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 58 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 58 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 58 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 58 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 58 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 58 resolved as shift
WARNING: shift/reduce conflict for FOR in state 58 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 58 resolved as shift
WARNING: shift/reduce conflict for DEF in state 58 resolved as shift
WARNING: shift/reduce conflict for IF in state 58 resolved as shift
WARNING: shift/reduce conflict for THEN in state 58 resolved as shift
WARNING: shift/reduce conflict for NOT in state 58 resolved as shift
WARNING: shift/reduce conflict for NIL in state 58 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 58 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 58 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 58 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 58 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 58 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 58 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 58 resolved as shift
WARNING: shift/reduce conflict for STR in state 58 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 58 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 58 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 58 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 58 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 58 resolved as shift
WARNING: shift/reduce conflict for THEN in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 71 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 75 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 79 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 79 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 79 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 79 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 79 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 79 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 79 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 79 resolved as shift
WARNING: shift/reduce conflict for FOR in state 79 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 79 resolved as shift
WARNING: shift/reduce conflict for DEF in state 79 resolved as shift
WARNING: shift/reduce conflict for IF in state 79 resolved as shift
WARNING: shift/reduce conflict for THEN in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT in state 79 resolved as shift
WARNING: shift/reduce conflict for NIL in state 79 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 79 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 79 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 79 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 79 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 79 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 79 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 79 resolved as shift
WARNING: shift/reduce conflict for STR in state 79 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 79 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 79 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 79 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 79 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 79 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 79 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 79 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 79 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 79 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 79 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 79 resolved as shift
WARNING: shift/reduce conflict for FOR in state 79 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 79 resolved as shift
WARNING: shift/reduce conflict for DEF in state 79 resolved as shift
WARNING: shift/reduce conflict for IF in state 79 resolved as shift
WARNING: shift/reduce conflict for THEN in state 79 resolved as shift
WARNING: shift/reduce conflict for NOT in state 79 resolved as shift
WARNING: shift/reduce conflict for NIL in state 79 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 79 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 79 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 79 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 79 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 79 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 79 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 79 resolved as shift
WARNING: shift/reduce conflict for STR in state 79 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 79 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 79 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 79 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 79 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 79 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 81 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 81 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 81 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 81 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 81 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 81 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for FOR in state 81 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 81 resolved as shift
WARNING: shift/reduce conflict for DEF in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for THEN in state 81 resolved as shift
WARNING: shift/reduce conflict for NOT in state 81 resolved as shift
WARNING: shift/reduce conflict for NIL in state 81 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 81 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 81 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 81 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 81 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 81 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 81 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 81 resolved as shift
WARNING: shift/reduce conflict for STR in state 81 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 81 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 81 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 81 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 81 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 81 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 84 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 100 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 100 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 100 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 100 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 100 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 100 resolved as shift
WARNING: shift/reduce conflict for FOR in state 100 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for DEF in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for THEN in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT in state 100 resolved as shift
WARNING: shift/reduce conflict for NIL in state 100 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 100 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 100 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 100 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 100 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 100 resolved as shift
WARNING: shift/reduce conflict for STR in state 100 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 100 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 100 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 100 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 100 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 100 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 100 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 100 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 100 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 100 resolved as shift
WARNING: shift/reduce conflict for FOR in state 100 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for DEF in state 100 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for THEN in state 100 resolved as shift
WARNING: shift/reduce conflict for NOT in state 100 resolved as shift
WARNING: shift/reduce conflict for NIL in state 100 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 100 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 100 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 100 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 100 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 100 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 100 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 100 resolved as shift
WARNING: shift/reduce conflict for STR in state 100 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 100 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 100 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 100 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 100 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 100 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 100 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 100 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 103 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 105 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 106 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 106 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 106 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 106 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 106 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 106 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 106 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 106 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 106 resolved as shift
WARNING: shift/reduce conflict for FOR in state 106 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 106 resolved as shift
WARNING: shift/reduce conflict for DEF in state 106 resolved as shift
WARNING: shift/reduce conflict for IF in state 106 resolved as shift
WARNING: shift/reduce conflict for THEN in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT in state 106 resolved as shift
WARNING: shift/reduce conflict for NIL in state 106 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 106 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 106 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 106 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 106 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 106 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 106 resolved as shift
WARNING: shift/reduce conflict for STR in state 106 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 106 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 106 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 106 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 106 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 106 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 106 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 106 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for THEN in state 108 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCL in state 109 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCL in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MULT in state 109 resolved as shift
WARNING: shift/reduce conflict for DIV in state 109 resolved as shift
WARNING: shift/reduce conflict for MOD in state 109 resolved as shift
WARNING: shift/reduce conflict for POWER in state 109 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 111 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 111 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 111 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 111 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 111 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 111 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 111 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 111 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 111 resolved as shift
WARNING: shift/reduce conflict for FOR in state 111 resolved as shift
WARNING: shift/reduce conflict for DEF in state 111 resolved as shift
WARNING: shift/reduce conflict for IF in state 111 resolved as shift
WARNING: shift/reduce conflict for THEN in state 111 resolved as shift
WARNING: shift/reduce conflict for NOT in state 111 resolved as shift
WARNING: shift/reduce conflict for NIL in state 111 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 111 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 111 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 111 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 111 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 111 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 111 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 111 resolved as shift
WARNING: shift/reduce conflict for STR in state 111 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 111 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 111 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 111 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 111 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 111 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 111 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 111 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 111 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 111 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 111 resolved as shift
WARNING: shift/reduce conflict for THEN in state 115 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCL in state 116 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCL in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MULT in state 116 resolved as shift
WARNING: shift/reduce conflict for DIV in state 116 resolved as shift
WARNING: shift/reduce conflict for MOD in state 116 resolved as shift
WARNING: shift/reduce conflict for POWER in state 116 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCL in state 117 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCL in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MULT in state 117 resolved as shift
WARNING: shift/reduce conflict for DIV in state 117 resolved as shift
WARNING: shift/reduce conflict for MOD in state 117 resolved as shift
WARNING: shift/reduce conflict for POWER in state 117 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 124 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 124 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 124 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 124 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 124 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 124 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 124 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 124 resolved as shift
WARNING: shift/reduce conflict for FOR in state 124 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 124 resolved as shift
WARNING: shift/reduce conflict for DEF in state 124 resolved as shift
WARNING: shift/reduce conflict for IF in state 124 resolved as shift
WARNING: shift/reduce conflict for THEN in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT in state 124 resolved as shift
WARNING: shift/reduce conflict for NIL in state 124 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 124 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 124 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 124 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 124 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 124 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 124 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 124 resolved as shift
WARNING: shift/reduce conflict for STR in state 124 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 124 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 124 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 124 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 124 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 124 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 124 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 124 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 124 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 147 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 149 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 154 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 155 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 155 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 155 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 155 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 155 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 155 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 155 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 155 resolved as shift
WARNING: shift/reduce conflict for FOR in state 155 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 155 resolved as shift
WARNING: shift/reduce conflict for DEF in state 155 resolved as shift
WARNING: shift/reduce conflict for IF in state 155 resolved as shift
WARNING: shift/reduce conflict for THEN in state 155 resolved as shift
WARNING: shift/reduce conflict for NOT in state 155 resolved as shift
WARNING: shift/reduce conflict for NIL in state 155 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 155 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 155 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 155 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 155 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 155 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 155 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 155 resolved as shift
WARNING: shift/reduce conflict for STR in state 155 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 155 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 155 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 155 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 155 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 155 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 155 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 155 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 155 resolved as shift
WARNING: shift/reduce conflict for EQLS in state 163 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for END_S in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 164 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 164 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 164 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 164 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 164 resolved as shift
WARNING: shift/reduce conflict for DEF in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for THEN in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT in state 164 resolved as shift
WARNING: shift/reduce conflict for NIL in state 164 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 164 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 164 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 164 resolved as shift
WARNING: shift/reduce conflict for STR in state 164 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 164 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 164 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 164 resolved as shift
WARNING: shift/reduce conflict for END_S in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 164 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 164 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 164 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 164 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 164 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 164 resolved as shift
WARNING: shift/reduce conflict for DEF in state 164 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for THEN in state 164 resolved as shift
WARNING: shift/reduce conflict for NOT in state 164 resolved as shift
WARNING: shift/reduce conflict for NIL in state 164 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 164 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 164 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 164 resolved as shift
WARNING: shift/reduce conflict for STR in state 164 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 164 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 164 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 164 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 164 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 171 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 171 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 171 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 171 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 171 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 171 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 171 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 171 resolved as shift
WARNING: shift/reduce conflict for FOR in state 171 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 171 resolved as shift
WARNING: shift/reduce conflict for DEF in state 171 resolved as shift
WARNING: shift/reduce conflict for IF in state 171 resolved as shift
WARNING: shift/reduce conflict for THEN in state 171 resolved as shift
WARNING: shift/reduce conflict for NOT in state 171 resolved as shift
WARNING: shift/reduce conflict for NIL in state 171 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 171 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 171 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 171 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 171 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 171 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 171 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 171 resolved as shift
WARNING: shift/reduce conflict for STR in state 171 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 171 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 171 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 171 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 171 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 171 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 171 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 171 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 171 resolved as shift
WARNING: shift/reduce conflict for END_S in state 172 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 172 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 172 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 172 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 172 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 172 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 172 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 172 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 172 resolved as shift
WARNING: shift/reduce conflict for FOR in state 172 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 172 resolved as shift
WARNING: shift/reduce conflict for DEF in state 172 resolved as shift
WARNING: shift/reduce conflict for IF in state 172 resolved as shift
WARNING: shift/reduce conflict for THEN in state 172 resolved as shift
WARNING: shift/reduce conflict for NOT in state 172 resolved as shift
WARNING: shift/reduce conflict for NIL in state 172 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 172 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 172 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 172 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 172 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 172 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 172 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 172 resolved as shift
WARNING: shift/reduce conflict for STR in state 172 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 172 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 172 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 172 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 172 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 172 resolved as shift
WARNING: shift/reduce conflict for END_S in state 172 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 172 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 172 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 172 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 172 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 172 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 172 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 172 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 172 resolved as shift
WARNING: shift/reduce conflict for FOR in state 172 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 172 resolved as shift
WARNING: shift/reduce conflict for DEF in state 172 resolved as shift
WARNING: shift/reduce conflict for IF in state 172 resolved as shift
WARNING: shift/reduce conflict for THEN in state 172 resolved as shift
WARNING: shift/reduce conflict for NOT in state 172 resolved as shift
WARNING: shift/reduce conflict for NIL in state 172 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 172 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 172 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 172 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 172 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 172 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 172 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 172 resolved as shift
WARNING: shift/reduce conflict for STR in state 172 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 172 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 172 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 172 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 172 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 172 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 172 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 173 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 173 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 173 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 173 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 173 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 173 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 173 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 173 resolved as shift
WARNING: shift/reduce conflict for FOR in state 173 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 173 resolved as shift
WARNING: shift/reduce conflict for DEF in state 173 resolved as shift
WARNING: shift/reduce conflict for IF in state 173 resolved as shift
WARNING: shift/reduce conflict for THEN in state 173 resolved as shift
WARNING: shift/reduce conflict for NOT in state 173 resolved as shift
WARNING: shift/reduce conflict for NIL in state 173 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 173 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 173 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 173 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 173 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 173 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 173 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 173 resolved as shift
WARNING: shift/reduce conflict for STR in state 173 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 173 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 173 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 173 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 173 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 173 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 173 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 178 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 178 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 178 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 178 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 178 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 178 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 178 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 178 resolved as shift
WARNING: shift/reduce conflict for FOR in state 178 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 178 resolved as shift
WARNING: shift/reduce conflict for DEF in state 178 resolved as shift
WARNING: shift/reduce conflict for IF in state 178 resolved as shift
WARNING: shift/reduce conflict for THEN in state 178 resolved as shift
WARNING: shift/reduce conflict for NOT in state 178 resolved as shift
WARNING: shift/reduce conflict for NIL in state 178 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 178 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 178 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 178 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 178 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 178 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 178 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 178 resolved as shift
WARNING: shift/reduce conflict for STR in state 178 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 178 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 178 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 178 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 178 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 178 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 178 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 178 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 178 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 178 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 178 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 179 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 179 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 179 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 179 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 179 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 179 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 179 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 179 resolved as shift
WARNING: shift/reduce conflict for FOR in state 179 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 179 resolved as shift
WARNING: shift/reduce conflict for DEF in state 179 resolved as shift
WARNING: shift/reduce conflict for IF in state 179 resolved as shift
WARNING: shift/reduce conflict for THEN in state 179 resolved as shift
WARNING: shift/reduce conflict for NOT in state 179 resolved as shift
WARNING: shift/reduce conflict for NIL in state 179 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 179 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 179 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 179 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 179 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 179 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 179 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 179 resolved as shift
WARNING: shift/reduce conflict for STR in state 179 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 179 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 179 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 179 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 179 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 179 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 179 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 179 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 179 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 179 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 179 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 179 resolved as shift
WARNING: shift/reduce conflict for FOR in state 179 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 179 resolved as shift
WARNING: shift/reduce conflict for DEF in state 179 resolved as shift
WARNING: shift/reduce conflict for IF in state 179 resolved as shift
WARNING: shift/reduce conflict for THEN in state 179 resolved as shift
WARNING: shift/reduce conflict for NOT in state 179 resolved as shift
WARNING: shift/reduce conflict for NIL in state 179 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 179 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 179 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 179 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 179 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 179 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 179 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 179 resolved as shift
WARNING: shift/reduce conflict for STR in state 179 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 179 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 179 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 179 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 179 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 196 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 196 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 196 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 196 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 196 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 196 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 196 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 196 resolved as shift
WARNING: shift/reduce conflict for FOR in state 196 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 196 resolved as shift
WARNING: shift/reduce conflict for DEF in state 196 resolved as shift
WARNING: shift/reduce conflict for IF in state 196 resolved as shift
WARNING: shift/reduce conflict for THEN in state 196 resolved as shift
WARNING: shift/reduce conflict for NOT in state 196 resolved as shift
WARNING: shift/reduce conflict for NIL in state 196 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 196 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 196 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 196 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 196 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 196 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 196 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 196 resolved as shift
WARNING: shift/reduce conflict for STR in state 196 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 196 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 196 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 196 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 196 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 196 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 196 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 196 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 196 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 196 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 196 resolved as shift
WARNING: shift/reduce conflict for END_S in state 197 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 197 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 197 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 197 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 197 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 197 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 197 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 197 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 197 resolved as shift
WARNING: shift/reduce conflict for FOR in state 197 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 197 resolved as shift
WARNING: shift/reduce conflict for DEF in state 197 resolved as shift
WARNING: shift/reduce conflict for IF in state 197 resolved as shift
WARNING: shift/reduce conflict for THEN in state 197 resolved as shift
WARNING: shift/reduce conflict for NOT in state 197 resolved as shift
WARNING: shift/reduce conflict for NIL in state 197 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 197 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 197 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 197 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 197 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 197 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 197 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 197 resolved as shift
WARNING: shift/reduce conflict for STR in state 197 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 197 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 197 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 197 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 197 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 197 resolved as shift
WARNING: shift/reduce conflict for END_S in state 197 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 197 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 197 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 197 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 197 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 197 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 197 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 197 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 197 resolved as shift
WARNING: shift/reduce conflict for FOR in state 197 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 197 resolved as shift
WARNING: shift/reduce conflict for DEF in state 197 resolved as shift
WARNING: shift/reduce conflict for IF in state 197 resolved as shift
WARNING: shift/reduce conflict for THEN in state 197 resolved as shift
WARNING: shift/reduce conflict for NOT in state 197 resolved as shift
WARNING: shift/reduce conflict for NIL in state 197 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 197 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 197 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 197 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 197 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 197 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 197 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 197 resolved as shift
WARNING: shift/reduce conflict for STR in state 197 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 197 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 197 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 197 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 197 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 197 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 197 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 197 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 198 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 207 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 207 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 207 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 207 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 207 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 207 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 207 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 207 resolved as shift
WARNING: shift/reduce conflict for FOR in state 207 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 207 resolved as shift
WARNING: shift/reduce conflict for DEF in state 207 resolved as shift
WARNING: shift/reduce conflict for IF in state 207 resolved as shift
WARNING: shift/reduce conflict for THEN in state 207 resolved as shift
WARNING: shift/reduce conflict for NOT in state 207 resolved as shift
WARNING: shift/reduce conflict for NIL in state 207 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 207 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 207 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 207 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 207 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 207 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 207 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 207 resolved as shift
WARNING: shift/reduce conflict for STR in state 207 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 207 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 207 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 207 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 207 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 207 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 207 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 207 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 207 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 207 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 207 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 210 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 210 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 210 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 210 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 210 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 210 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 210 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 210 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 210 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 210 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 210 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 210 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 210 resolved as shift
WARNING: shift/reduce conflict for FOR in state 210 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 210 resolved as shift
WARNING: shift/reduce conflict for DEF in state 210 resolved as shift
WARNING: shift/reduce conflict for IF in state 210 resolved as shift
WARNING: shift/reduce conflict for THEN in state 210 resolved as shift
WARNING: shift/reduce conflict for NOT in state 210 resolved as shift
WARNING: shift/reduce conflict for NIL in state 210 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 210 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 210 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 210 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 210 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 210 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 210 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 210 resolved as shift
WARNING: shift/reduce conflict for STR in state 210 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 210 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 210 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 210 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 210 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 210 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 210 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 210 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 210 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 210 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 210 resolved as shift
WARNING: shift/reduce conflict for END_S in state 212 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 212 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 212 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 212 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 212 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 212 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 212 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 212 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 212 resolved as shift
WARNING: shift/reduce conflict for FOR in state 212 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 212 resolved as shift
WARNING: shift/reduce conflict for DEF in state 212 resolved as shift
WARNING: shift/reduce conflict for IF in state 212 resolved as shift
WARNING: shift/reduce conflict for THEN in state 212 resolved as shift
WARNING: shift/reduce conflict for NOT in state 212 resolved as shift
WARNING: shift/reduce conflict for NIL in state 212 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 212 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 212 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 212 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 212 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 212 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 212 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 212 resolved as shift
WARNING: shift/reduce conflict for STR in state 212 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 212 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 212 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 212 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 212 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 212 resolved as shift
WARNING: shift/reduce conflict for END_S in state 212 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 212 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 212 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 212 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 212 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 212 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 212 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 212 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 212 resolved as shift
WARNING: shift/reduce conflict for FOR in state 212 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 212 resolved as shift
WARNING: shift/reduce conflict for DEF in state 212 resolved as shift
WARNING: shift/reduce conflict for IF in state 212 resolved as shift
WARNING: shift/reduce conflict for THEN in state 212 resolved as shift
WARNING: shift/reduce conflict for NOT in state 212 resolved as shift
WARNING: shift/reduce conflict for NIL in state 212 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 212 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 212 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 212 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 212 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 212 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 212 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 212 resolved as shift
WARNING: shift/reduce conflict for STR in state 212 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 212 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 212 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 212 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 212 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 212 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 212 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 212 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 215 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 215 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 215 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 215 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 215 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 215 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 215 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 215 resolved as shift
WARNING: shift/reduce conflict for FOR in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 215 resolved as shift
WARNING: shift/reduce conflict for DEF in state 215 resolved as shift
WARNING: shift/reduce conflict for IF in state 215 resolved as shift
WARNING: shift/reduce conflict for THEN in state 215 resolved as shift
WARNING: shift/reduce conflict for NOT in state 215 resolved as shift
WARNING: shift/reduce conflict for NIL in state 215 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 215 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 215 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 215 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 215 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 215 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 215 resolved as shift
WARNING: shift/reduce conflict for STR in state 215 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 215 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 215 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 215 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 215 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 215 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 215 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 215 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 215 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 215 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 215 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 215 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 215 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 215 resolved as shift
WARNING: shift/reduce conflict for FOR in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 215 resolved as shift
WARNING: shift/reduce conflict for DEF in state 215 resolved as shift
WARNING: shift/reduce conflict for IF in state 215 resolved as shift
WARNING: shift/reduce conflict for THEN in state 215 resolved as shift
WARNING: shift/reduce conflict for NOT in state 215 resolved as shift
WARNING: shift/reduce conflict for NIL in state 215 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 215 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 215 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 215 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 215 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 215 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 215 resolved as shift
WARNING: shift/reduce conflict for STR in state 215 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 215 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 215 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 215 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 215 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 215 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 215 resolved as shift
WARNING: shift/reduce conflict for END_S in state 218 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 218 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 218 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 218 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 218 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 218 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 218 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 218 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 218 resolved as shift
WARNING: shift/reduce conflict for FOR in state 218 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 218 resolved as shift
WARNING: shift/reduce conflict for DEF in state 218 resolved as shift
WARNING: shift/reduce conflict for IF in state 218 resolved as shift
WARNING: shift/reduce conflict for THEN in state 218 resolved as shift
WARNING: shift/reduce conflict for NOT in state 218 resolved as shift
WARNING: shift/reduce conflict for NIL in state 218 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 218 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 218 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 218 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 218 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 218 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 218 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 218 resolved as shift
WARNING: shift/reduce conflict for STR in state 218 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 218 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 218 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 218 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 218 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 218 resolved as shift
WARNING: shift/reduce conflict for END_S in state 218 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 218 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 218 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 218 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 218 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 218 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 218 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 218 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 218 resolved as shift
WARNING: shift/reduce conflict for FOR in state 218 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 218 resolved as shift
WARNING: shift/reduce conflict for DEF in state 218 resolved as shift
WARNING: shift/reduce conflict for IF in state 218 resolved as shift
WARNING: shift/reduce conflict for THEN in state 218 resolved as shift
WARNING: shift/reduce conflict for NOT in state 218 resolved as shift
WARNING: shift/reduce conflict for NIL in state 218 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 218 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 218 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 218 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 218 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 218 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 218 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 218 resolved as shift
WARNING: shift/reduce conflict for STR in state 218 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 218 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 218 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 218 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 218 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 218 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 218 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 218 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 220 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 220 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 220 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 220 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 220 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 220 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 220 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 220 resolved as shift
WARNING: shift/reduce conflict for FOR in state 220 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 220 resolved as shift
WARNING: shift/reduce conflict for DEF in state 220 resolved as shift
WARNING: shift/reduce conflict for IF in state 220 resolved as shift
WARNING: shift/reduce conflict for THEN in state 220 resolved as shift
WARNING: shift/reduce conflict for NOT in state 220 resolved as shift
WARNING: shift/reduce conflict for NIL in state 220 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 220 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 220 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 220 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 220 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 220 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 220 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 220 resolved as shift
WARNING: shift/reduce conflict for STR in state 220 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 220 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 220 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 220 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 220 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 220 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 220 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 220 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 220 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 220 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 220 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 221 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 222 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 222 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 222 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 222 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 222 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 222 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 222 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 222 resolved as shift
WARNING: shift/reduce conflict for FOR in state 222 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 222 resolved as shift
WARNING: shift/reduce conflict for DEF in state 222 resolved as shift
WARNING: shift/reduce conflict for IF in state 222 resolved as shift
WARNING: shift/reduce conflict for THEN in state 222 resolved as shift
WARNING: shift/reduce conflict for NOT in state 222 resolved as shift
WARNING: shift/reduce conflict for NIL in state 222 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 222 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 222 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 222 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 222 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 222 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 222 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 222 resolved as shift
WARNING: shift/reduce conflict for STR in state 222 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 222 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 222 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 222 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 222 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 222 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 222 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 222 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 222 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 222 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 222 resolved as shift
WARNING: shift/reduce conflict for END_S in state 225 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 225 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 225 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 225 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 225 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 225 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 225 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 225 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 225 resolved as shift
WARNING: shift/reduce conflict for FOR in state 225 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 225 resolved as shift
WARNING: shift/reduce conflict for DEF in state 225 resolved as shift
WARNING: shift/reduce conflict for IF in state 225 resolved as shift
WARNING: shift/reduce conflict for THEN in state 225 resolved as shift
WARNING: shift/reduce conflict for NOT in state 225 resolved as shift
WARNING: shift/reduce conflict for NIL in state 225 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 225 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 225 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 225 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 225 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 225 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 225 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 225 resolved as shift
WARNING: shift/reduce conflict for STR in state 225 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 225 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 225 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 225 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 225 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 225 resolved as shift
WARNING: shift/reduce conflict for END_S in state 225 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 225 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 225 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 225 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 225 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 225 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 225 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 225 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 225 resolved as shift
WARNING: shift/reduce conflict for FOR in state 225 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 225 resolved as shift
WARNING: shift/reduce conflict for DEF in state 225 resolved as shift
WARNING: shift/reduce conflict for IF in state 225 resolved as shift
WARNING: shift/reduce conflict for THEN in state 225 resolved as shift
WARNING: shift/reduce conflict for NOT in state 225 resolved as shift
WARNING: shift/reduce conflict for NIL in state 225 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 225 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 225 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 225 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 225 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 225 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 225 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 225 resolved as shift
WARNING: shift/reduce conflict for STR in state 225 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 225 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 225 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 225 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 225 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 225 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 225 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 225 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 227 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 227 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 233 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 233 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 233 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 233 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 233 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 233 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 233 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 233 resolved as shift
WARNING: shift/reduce conflict for FOR in state 233 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 233 resolved as shift
WARNING: shift/reduce conflict for DEF in state 233 resolved as shift
WARNING: shift/reduce conflict for IF in state 233 resolved as shift
WARNING: shift/reduce conflict for THEN in state 233 resolved as shift
WARNING: shift/reduce conflict for NOT in state 233 resolved as shift
WARNING: shift/reduce conflict for NIL in state 233 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 233 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 233 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 233 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 233 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 233 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 233 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 233 resolved as shift
WARNING: shift/reduce conflict for STR in state 233 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 233 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 233 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 233 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 233 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 233 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 233 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 233 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 233 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 233 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 233 resolved as shift
WARNING: shift/reduce conflict for END_S in state 234 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 234 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 234 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 234 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 234 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 234 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 234 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 234 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 234 resolved as shift
WARNING: shift/reduce conflict for FOR in state 234 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 234 resolved as shift
WARNING: shift/reduce conflict for DEF in state 234 resolved as shift
WARNING: shift/reduce conflict for IF in state 234 resolved as shift
WARNING: shift/reduce conflict for THEN in state 234 resolved as shift
WARNING: shift/reduce conflict for NOT in state 234 resolved as shift
WARNING: shift/reduce conflict for NIL in state 234 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 234 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 234 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 234 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 234 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 234 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 234 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 234 resolved as shift
WARNING: shift/reduce conflict for STR in state 234 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 234 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 234 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 234 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 234 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 234 resolved as shift
WARNING: shift/reduce conflict for END_S in state 234 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 234 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 234 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 234 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 234 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 234 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 234 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 234 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 234 resolved as shift
WARNING: shift/reduce conflict for FOR in state 234 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 234 resolved as shift
WARNING: shift/reduce conflict for DEF in state 234 resolved as shift
WARNING: shift/reduce conflict for IF in state 234 resolved as shift
WARNING: shift/reduce conflict for THEN in state 234 resolved as shift
WARNING: shift/reduce conflict for NOT in state 234 resolved as shift
WARNING: shift/reduce conflict for NIL in state 234 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 234 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 234 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 234 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 234 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 234 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 234 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 234 resolved as shift
WARNING: shift/reduce conflict for STR in state 234 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 234 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 234 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 234 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 234 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 234 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 234 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 234 resolved as shift
WARNING: shift/reduce conflict for END_S in state 235 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 235 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 235 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 235 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 235 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 235 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 235 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 235 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 235 resolved as shift
WARNING: shift/reduce conflict for FOR in state 235 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 235 resolved as shift
WARNING: shift/reduce conflict for DEF in state 235 resolved as shift
WARNING: shift/reduce conflict for IF in state 235 resolved as shift
WARNING: shift/reduce conflict for THEN in state 235 resolved as shift
WARNING: shift/reduce conflict for NOT in state 235 resolved as shift
WARNING: shift/reduce conflict for NIL in state 235 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 235 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 235 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 235 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 235 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 235 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 235 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 235 resolved as shift
WARNING: shift/reduce conflict for STR in state 235 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 235 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 235 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 235 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 235 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 235 resolved as shift
WARNING: shift/reduce conflict for END_S in state 235 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 235 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 235 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 235 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 235 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 235 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 235 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 235 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 235 resolved as shift
WARNING: shift/reduce conflict for FOR in state 235 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 235 resolved as shift
WARNING: shift/reduce conflict for DEF in state 235 resolved as shift
WARNING: shift/reduce conflict for IF in state 235 resolved as shift
WARNING: shift/reduce conflict for THEN in state 235 resolved as shift
WARNING: shift/reduce conflict for NOT in state 235 resolved as shift
WARNING: shift/reduce conflict for NIL in state 235 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 235 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 235 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 235 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 235 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 235 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 235 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 235 resolved as shift
WARNING: shift/reduce conflict for STR in state 235 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 235 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 235 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 235 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 235 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 235 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 235 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 235 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 239 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 239 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 239 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 239 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 239 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 239 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 239 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 239 resolved as shift
WARNING: shift/reduce conflict for FOR in state 239 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 239 resolved as shift
WARNING: shift/reduce conflict for DEF in state 239 resolved as shift
WARNING: shift/reduce conflict for IF in state 239 resolved as shift
WARNING: shift/reduce conflict for THEN in state 239 resolved as shift
WARNING: shift/reduce conflict for NOT in state 239 resolved as shift
WARNING: shift/reduce conflict for NIL in state 239 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 239 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 239 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 239 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 239 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 239 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 239 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 239 resolved as shift
WARNING: shift/reduce conflict for STR in state 239 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 239 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 239 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 239 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 239 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 239 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 239 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 239 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 239 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 239 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 239 resolved as shift
WARNING: shift/reduce conflict for END_S in state 241 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 241 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 241 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 241 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 241 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 241 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 241 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 241 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 241 resolved as shift
WARNING: shift/reduce conflict for FOR in state 241 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 241 resolved as shift
WARNING: shift/reduce conflict for DEF in state 241 resolved as shift
WARNING: shift/reduce conflict for IF in state 241 resolved as shift
WARNING: shift/reduce conflict for THEN in state 241 resolved as shift
WARNING: shift/reduce conflict for NOT in state 241 resolved as shift
WARNING: shift/reduce conflict for NIL in state 241 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 241 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 241 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 241 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 241 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 241 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 241 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 241 resolved as shift
WARNING: shift/reduce conflict for STR in state 241 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 241 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 241 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 241 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 241 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 241 resolved as shift
WARNING: shift/reduce conflict for END_S in state 241 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 241 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 241 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 241 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 241 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 241 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 241 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 241 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 241 resolved as shift
WARNING: shift/reduce conflict for FOR in state 241 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 241 resolved as shift
WARNING: shift/reduce conflict for DEF in state 241 resolved as shift
WARNING: shift/reduce conflict for IF in state 241 resolved as shift
WARNING: shift/reduce conflict for THEN in state 241 resolved as shift
WARNING: shift/reduce conflict for NOT in state 241 resolved as shift
WARNING: shift/reduce conflict for NIL in state 241 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 241 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 241 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 241 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 241 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 241 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 241 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 241 resolved as shift
WARNING: shift/reduce conflict for STR in state 241 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 241 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 241 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 241 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 241 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 241 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 241 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 241 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 245 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 245 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 245 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 245 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 245 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 245 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 245 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 245 resolved as shift
WARNING: shift/reduce conflict for FOR in state 245 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 245 resolved as shift
WARNING: shift/reduce conflict for DEF in state 245 resolved as shift
WARNING: shift/reduce conflict for IF in state 245 resolved as shift
WARNING: shift/reduce conflict for THEN in state 245 resolved as shift
WARNING: shift/reduce conflict for NOT in state 245 resolved as shift
WARNING: shift/reduce conflict for NIL in state 245 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 245 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 245 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 245 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 245 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 245 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 245 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 245 resolved as shift
WARNING: shift/reduce conflict for STR in state 245 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 245 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 245 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 245 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 245 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 245 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 245 resolved as shift
WARNING: shift/reduce conflict for NEXT in state 245 resolved as shift
WARNING: shift/reduce conflict for ELSIF in state 245 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 245 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 245 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 245 resolved as shift
WARNING: shift/reduce conflict for PUTS in state 245 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 245 resolved as shift
WARNING: shift/reduce conflict for FOR in state 245 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 245 resolved as shift
WARNING: shift/reduce conflict for DEF in state 245 resolved as shift
WARNING: shift/reduce conflict for IF in state 245 resolved as shift
WARNING: shift/reduce conflict for THEN in state 245 resolved as shift
WARNING: shift/reduce conflict for NOT in state 245 resolved as shift
WARNING: shift/reduce conflict for NIL in state 245 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 245 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 245 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 245 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 245 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 245 resolved as shift
WARNING: shift/reduce conflict for RATIONAL in state 245 resolved as shift
WARNING: shift/reduce conflict for COMPLEX in state 245 resolved as shift
WARNING: shift/reduce conflict for STR in state 245 resolved as shift
WARNING: shift/reduce conflict for SYMBOL in state 245 resolved as shift
WARNING: shift/reduce conflict for REGEXP in state 245 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 245 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 245 resolved as shift
WARNING: shift/reduce conflict for INSTANCE_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for CLASS_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for GLOBAL_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for LOCAL_VAR in state 245 resolved as shift
WARNING: shift/reduce conflict for CONSTANT in state 245 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 245 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> statement_list)
WARNING: rejected rule (stmt_block -> statement_list) in state 2
WARNING: reduce/reduce conflict in state 2 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 3 resolved using rule (statement_list -> statement)
WARNING: rejected rule (stmt_block -> statement) in state 3
WARNING: reduce/reduce conflict in state 11 resolved using rule (statement -> hash_literal)
WARNING: rejected rule (expression -> hash_literal) in state 11
WARNING: reduce/reduce conflict in state 12 resolved using rule (statement -> function_def)
WARNING: rejected rule (method_def -> function_def) in state 12
WARNING: reduce/reduce conflict in state 15 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 15
WARNING: reduce/reduce conflict in state 20 resolved using rule (statement -> ELSE)
WARNING: rejected rule (empty -> <empty>) in state 20
WARNING: reduce/reduce conflict in state 27 resolved using rule (primary -> variable)
WARNING: rejected rule (expression -> variable) in state 27
WARNING: reduce/reduce conflict in state 32 resolved using rule (hash_pairs_opt -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 32
WARNING: reduce/reduce conflict in state 37 resolved using rule (optional_then -> empty)
WARNING: rejected rule (elsif_list -> empty) in state 37
WARNING: reduce/reduce conflict in state 37 resolved using rule (optional_then -> empty)
WARNING: rejected rule (else_part -> empty) in state 37
WARNING: reduce/reduce conflict in state 39 resolved using rule (primary -> NIL)
WARNING: rejected rule (expression -> NIL) in state 39
WARNING: reduce/reduce conflict in state 40 resolved using rule (primary -> TRUE)
WARNING: rejected rule (expression -> TRUE) in state 40
WARNING: reduce/reduce conflict in state 41 resolved using rule (primary -> FALSE)
WARNING: rejected rule (expression -> FALSE) in state 41
WARNING: reduce/reduce conflict in state 43 resolved using rule (primary -> INTEGER)
WARNING: rejected rule (expression -> INTEGER) in state 43
WARNING: reduce/reduce conflict in state 44 resolved using rule (primary -> FLOAT)
WARNING: rejected rule (expression -> FLOAT) in state 44
WARNING: reduce/reduce conflict in state 47 resolved using rule (primary -> STR)
WARNING: rejected rule (expression -> STR) in state 47
WARNING: reduce/reduce conflict in state 48 resolved using rule (primary -> SYMBOL)
WARNING: rejected rule (expression -> SYMBOL) in state 48
WARNING: reduce/reduce conflict in state 52 resolved using rule (variable -> INSTANCE_VAR)
WARNING: rejected rule (property_decl -> INSTANCE_VAR) in state 52
WARNING: reduce/reduce conflict in state 53 resolved using rule (variable -> CLASS_VAR)
WARNING: rejected rule (property_decl -> CLASS_VAR) in state 53
WARNING: reduce/reduce conflict in state 58 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 58
WARNING: reduce/reduce conflict in state 59 resolved using rule (statement_list -> statement_list statement)
WARNING: rejected rule (stmt_block -> statement) in state 59
WARNING: reduce/reduce conflict in state 59 resolved using rule (statement_list -> statement_list statement)
WARNING: rejected rule (statement_list -> statement) in state 59
WARNING: reduce/reduce conflict in state 60 resolved using rule (stmt_block -> statement)
WARNING: rejected rule (stmt_block -> stmt_block statement) in state 60
WARNING: reduce/reduce conflict in state 60 resolved using rule (statement_list -> statement)
WARNING: rejected rule (stmt_block -> statement) in state 60
WARNING: reduce/reduce conflict in state 74 resolved using rule (primary -> variable)
WARNING: rejected rule (expression -> variable) in state 74
WARNING: reduce/reduce conflict in state 79 resolved using rule (else_part -> ELSE stmt_block)
WARNING: rejected rule (statement -> ELSE stmt_block) in state 79
WARNING: reduce/reduce conflict in state 79 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (else_part -> ELSE stmt_block) in state 79
WARNING: reduce/reduce conflict in state 79 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 79
WARNING: reduce/reduce conflict in state 80 resolved using rule (statement_list -> statement)
WARNING: rejected rule (stmt_block -> statement) in state 80
WARNING: reduce/reduce conflict in state 81 resolved using rule (hash_pairs_opt -> <empty>)
WARNING: rejected rule (empty -> <empty>) in state 81
WARNING: reduce/reduce conflict in state 100 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 100
WARNING: reduce/reduce conflict in state 104 resolved using rule (primary -> SYMBOL)
WARNING: rejected rule (expression -> SYMBOL) in state 104
WARNING: reduce/reduce conflict in state 141 resolved using rule (primary -> SYMBOL)
WARNING: rejected rule (expression -> SYMBOL) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (input_stmt -> variable EQLS LOCAL_VAR)
WARNING: rejected rule (variable -> LOCAL_VAR) in state 142
WARNING: reduce/reduce conflict in state 163 resolved using rule (variable -> LOCAL_VAR)
WARNING: rejected rule (parameter -> LOCAL_VAR) in state 163
WARNING: reduce/reduce conflict in state 164 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 164
WARNING: reduce/reduce conflict in state 168 resolved using rule (optional_then -> empty)
WARNING: rejected rule (optional_params -> empty) in state 168
WARNING: reduce/reduce conflict in state 168 resolved using rule (optional_then -> empty)
WARNING: rejected rule (elsif_list -> empty) in state 168
WARNING: reduce/reduce conflict in state 168 resolved using rule (optional_then -> empty)
WARNING: rejected rule (else_part -> empty) in state 168
WARNING: reduce/reduce conflict in state 170 resolved using rule (primary -> LPAREN expression RPAREN)
WARNING: rejected rule (expression -> LPAREN expression RPAREN) in state 170
WARNING: reduce/reduce conflict in state 172 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 172
WARNING: reduce/reduce conflict in state 175 resolved using rule (optional_then -> empty)
WARNING: rejected rule (opt_inherit -> empty) in state 175
WARNING: reduce/reduce conflict in state 175 resolved using rule (optional_then -> empty)
WARNING: rejected rule (elsif_list -> empty) in state 175
WARNING: reduce/reduce conflict in state 175 resolved using rule (optional_then -> empty)
WARNING: rejected rule (else_part -> empty) in state 175
WARNING: reduce/reduce conflict in state 179 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (statement -> ELSIF expression_logic optional_then stmt_block) in state 179
WARNING: reduce/reduce conflict in state 179 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 179
WARNING: reduce/reduce conflict in state 197 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 197
WARNING: reduce/reduce conflict in state 210 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 210
WARNING: reduce/reduce conflict in state 212 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 212
WARNING: reduce/reduce conflict in state 215 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block) in state 215
WARNING: reduce/reduce conflict in state 215 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 215
WARNING: reduce/reduce conflict in state 218 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 218
WARNING: reduce/reduce conflict in state 225 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 225
WARNING: reduce/reduce conflict in state 227 resolved using rule (statement -> elsif_list)
WARNING: rejected rule (empty -> <empty>) in state 227
WARNING: reduce/reduce conflict in state 228 resolved using rule (optional_then -> empty)
WARNING: rejected rule (elsif_list -> empty) in state 228
WARNING: reduce/reduce conflict in state 228 resolved using rule (optional_then -> empty)
WARNING: rejected rule (else_part -> empty) in state 228
WARNING: reduce/reduce conflict in state 234 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 234
WARNING: reduce/reduce conflict in state 235 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 235
WARNING: reduce/reduce conflict in state 241 resolved using rule (stmt_block -> statement_list)
WARNING: rejected rule (empty -> <empty>) in state 241
WARNING: reduce/reduce conflict in state 245 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (else_part -> ELSE stmt_block) in state 245
WARNING: reduce/reduce conflict in state 245 resolved using rule (statement -> stmt_block)
WARNING: rejected rule (empty -> <empty>) in state 245
WARNING: Rule (stmt_block -> statement) is never reduced
WARNING: Rule (method_def -> function_def) is never reduced
WARNING: Rule (expression -> variable) is never reduced
WARNING: Rule (elsif_list -> empty) is never reduced
WARNING: Rule (expression -> NIL) is never reduced
WARNING: Rule (expression -> TRUE) is never reduced
WARNING: Rule (expression -> FALSE) is never reduced
WARNING: Rule (expression -> INTEGER) is never reduced
WARNING: Rule (expression -> FLOAT) is never reduced
WARNING: Rule (expression -> STR) is never reduced
WARNING: Rule (expression -> SYMBOL) is never reduced
WARNING: Rule (property_decl -> INSTANCE_VAR) is never reduced
WARNING: Rule (property_decl -> CLASS_VAR) is never reduced
WARNING: Rule (stmt_block -> stmt_block statement) is never reduced
WARNING: Rule (statement -> ELSE stmt_block) is never reduced
WARNING: Rule (else_part -> ELSE stmt_block) is never reduced
WARNING: Rule (expression -> LPAREN expression RPAREN) is never reduced
WARNING: Rule (opt_inherit -> empty) is never reduced
WARNING: Rule (statement -> ELSIF expression_logic optional_then stmt_block) is never reduced
WARNING: Rule (elsif_list -> elsif_list ELSIF expression_logic optional_then stmt_block) is never reduced
